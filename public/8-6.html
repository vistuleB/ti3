<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 8.6 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 8, Section 6</title>
</head>
<body>
  <div class="body-wrapper">
    <div id="top-menu">
      <div class="top-menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./8-5.html"
        >&lt;&lt; Kapitel 8.5<span
            style="visibility:hidden"
            id="top-prev-page-tooltip"
          >Turing-Maschinen simulieren Turing-Maschinen: die universelle Turing-Maschine</span></a>
      </div>
      <div class="top-menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./8-7.html"
        >Kapitel 8.7 &gt;&gt;<span
            style="visibility:hidden"
            id="top-next-page-tooltip"
          >Mehr über Unentscheidbarkeit: Das Postsche Korrespondenzproblem</span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        8.6&ensp;Unentscheidbarkeit
      </p>
    </div>
    <p class="main-column">
      Im vorherigen Teilkapitel haben wir die
      <i>universelle
        Turingmaschine</i>
      $U$ konstruiert, die eine andere Turingmaschine,
      deren Codierung und Inputwort sie als Input gegeben hat, simulieren
      kann. Technisch gesprochen: $U$ akzeptiert die Sprache
    </p>
    <div class="math-block main-column">
      $$
      \begin{align}
      \{ c w \ | \ c = \enc(M) \textnormal{ und $M$ akzeptiert $w$} \} \ .
      \label{halting-language-old-encoding}
      \end{align}
      $$
    </div>
    <p class="main-column">
      Allerdings: wenn $M$ auf $x$ nicht terminiert, dann terminiert $U$
      auf $\enc(M)x$ auch nicht. $U$
      <i>akzeptiert</i>
      die Sprache also,
      <i>entscheidet</i>
      sie aber nicht. Wäre es nicht schön, eine
      Turingmaschine zu haben, die diese Sprache entscheidet? Dann
      könnten wir jede Turingmaschine simulieren und gleichzeitig
      Endlosschleifen und eventuell ganz allgemein "Programmierfehler"
      vorhersagen und abfangen. Wir werden zeigen, dass dies leider
      <i>nicht</i>
      möglich ist. In der Literatur ist dies als die
      <i>Unentscheidbarkeit des Halteproblems</i>
      (englisch
      <i>undecidability of
        the Halting problem</i>
      bekannt). Als vorbereitenden Schritt schauen
      wir uns kurz die Codierungsfunktion nochmal genauer an. Wir
      bezeichnen mit $\tm_{\Sigma}$ die Menge aller Turingmaschinen mit
      Inputalphabet $\Sigma$ . Wir hatten die Codierungsfunktion
      $\enc: \tm_{\Sigma} \rightarrow \Lambda^*$ definiert, für das
      Codierungsalphabet
      <span class="nowrap">$\Lambda := \writelambda$.</span>
      In diesem
      Teilkapitel wird es nötig sein, die Turingmaschine über dem
      Alphabet $\Sigma$ selbst zu codieren. Dies ist nicht besonders
      schwierig, solange $\Sigma$ mindestens zwei Zeichen hat. Wenn z.B.
      $\Sigma$ die Zeichen $0$ und $1$ enthält, dann können wir alle
      Zeichen in $\Lambda$ wiederum als Strings in $\Sigma^*$ codieren.
      Wir müssen hier nur vorsichtig sein, dass der Code
      <i>präfixfrei</i>
      ist. Wenn wir zum Beispiel naiv $1$ als $1$ und $0$ als $0$ und
      $\texttt{#}$ als $01$ codieren, dann wissen wir nicht mehr, was
      mit dem Codewort $01$ gemeint ist. Am einfachsten geht das mit
      einem
      <span class="nowrap"><i>Blockcode</i>,</span>
      in dem alle Codewörter die gleiche Länge $k$
      haben, also
      <span class="nowrap">$\Lambda \rightarrow \{0,1\}^k$.</span>
      Mit
      $k = \ceil{\log_2 |\Lambda|}$ ist das kein Problem. Unsere "neue"
      Codierungsfunktion $\enc$ ist nun also
      <span class="nowrap">$\enc: \tm_{\Sigma} \rightarrow \Sigma^*$.</span>
      Wir definieren nun die
      Haltesprache
      <span class="nowrap">$\halt \in \Sigma^*$:</span>
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \halt := \{ \enc(M) w \ | \ w \in \Sigma^* \textnormal{ und } M \textnormal{ akzeptiert } w\} \ .
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Da $\enc$ präfixfrei ist, können wir erkennen, wo
      $\enc(\texttt{;})$ steht, wo also $\enc(M)$ aufhört und $w$
      beginnt. Wir können die universelle Turingmaschine $U$ leicht
      abwandeln, dass sie $\halt$ akzeptiert; wir müssen nur einen
      Decodierungsschritt vorausschicken, der die neue Codierung
      $\enc(M) \in \Sigma^*$ in unsere "alte" in $\Lambda^*$ übersetzt.
      Wir zeigen nun, dass $\halt$ unentscheidbar ist, dass es also
      keine Möglichkeit gibt, das Nichtterminieren einer Maschine $M$
      auf Eingabe $x$ vorauszusehen und abzufangen.
    </p>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>8.6.1</b>
        <b>(Unentscheidbarkeit des Halteproblems).</b>
        Die Sprache $\halt$
        ist unentscheidbar.
      </p>
    </div>
    <p class="main-column">
      Ich gebe erst einmal einen kurzen und knappen Widerspruchsbeweis.
      Falls das ihnen zu schnell ging, lesen Sie den zweiten Beweis, in
      dem ich mir mehr Zeit nehme.
    </p>
    <div class="well highlight out">
      <p>
        <b>Kurzer Beweis per Wiederspruch.</b>
        Nehmen wir an, es gäbe eine
        Maschine
        <span class="nowrap">$H$,</span>
        die $\halt$ entscheidet. Dann wäre auch die
        Sprache
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \diag := \{\enc(M) \ | \ \textnormal{$M$ akzeptiert $\enc(M)$} \}
        \end{align*}
        $$
      </div>
      <p>
        entscheidbar. Warum? Wir können einfach schauen, ob das
        Eingabewort $c$ die Form $\enc(M)$ hat und in diesem Fall das
        Wort $\enc(M) \enc(M)$ der Maschine $H$ übergeben. Die Sprache
        $\diag$ ist, salopp ausgedrückt, die Menge aller
        Turingmaschinen, die ihre eigene Codierung als Inputwort
        akzeptieren. Ebenso wäre auch
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \negdiag := \{\enc(M) \ | \ \textnormal{$M$ akzeptiert $\enc(M)$ nicht}\}
        \end{align*}
        $$
      </div>
      <p>
        entscheidbar; wir müssen ja nur $\diag$ entscheiden und dann das
        Ergebnis negieren. $\negdiag$ ist sozusagen die Menge aller
        Turingmaschinen, die
        <i>nicht</i>
        ihre eigene Codierung als Inputwort
        akzeptieren. Da $\negdiag$ nach Annahme entscheidbar ist, gibt
        es eine Maschine
        <span class="nowrap">$D$,</span>
        die $\negdiag$ entscheidet. Wir fragen uns
        jetzt: gehört $\enc(D)$ selbst zu
        <span class="nowrap">$\negdiag$?</span>
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \enc(D) \in \negdiag&amp;\Longleftrightarrow \textnormal{$D$ akzeptiert $\enc(D)$ nicht}
        \tag{nach Definition von $\negdiag$} \\
        &amp;\Longleftrightarrow \textnormal{$\enc(D) \not \in L(D)$} \tag{Bedeutung der Notation $L(D)$}
        \\
        &amp;\Longleftrightarrow \enc(D) \not \in \negdiag \tag{nach Annahme $L(D) = \negdiag$}
        \end{align*}
        $$
      </div>
      <p>
        Also
        <span class="nowrap">$\enc(D) \in \negdiag \Longleftrightarrow \enc(M) \not \in
          \negdiag$,</span>
        ein Widerspruch. Unsere Annahme, dass $\halt$ entscheidbar sei,
        ist also falsch.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Ausführlicher Beweis.</b>
        Ich finde Beweise durch Widerspruch
        immer etwas unintuitiv, weil man die ganze Zeit im Konjunktiv
        argumentieren muss. Daher hier ein Beweis ohne Widerspruch. Wir
        zeigen, dass $\halt$ unentscheidbar ist, indem wir für eine
        beliebige Turingmaschine $M$ zeigen, dass sie $\halt$ nicht
        entscheidet, indem wir nämlich ein Eingabewort $z \in \Sigma^*$
        konstruieren, auf dem $M$ scheitert, also entweder
      </p>
      <ol>
        <li>
          <p>
            $f_H(z) = \texttt{accept}$ aber
            <span class="nowrap">$z \not \in \halt$,</span>
            oder
          </p>
        </li>
        <li>
          <p>
            $f_H(z) = \texttt{reject}$ aber $z \in \halt$ , oder
          </p>
        </li>
        <li>
          <p>
            <span class="nowrap">$f_H(z) = \texttt{undefined}$,</span>
            d.h. $H$ terminiert auf
            Eingabewort $z$ nicht.
          </p>
        </li>
      </ol>
      <p>
        Wir setzen nun $y := \enc(D)$ und
        <span class="nowrap">$z := yy$,</span>
        wobei $D$ eine neue
        Turingmaschine ist, die wir auf Basis von $H$ konstruieren
        werden. Also noch einmal. Für eine beliebige, uns gegebene
        Turingmaschine
        <span class="nowrap">$H$,</span>
        werden wir eine neue Turingmaschine $D$
        bauen und sie codieren als
        <span class="nowrap">$y := \enc(D)$,</span>
        so dass entweder
      </p>
      <ol>
        <li>
          <p>
            $f_H(yy) = \texttt{accept}$ aber
            <span class="nowrap">$yy \not \in \halt$,</span>
            oder
          </p>
        </li>
        <li>
          <p>
            $f_H(yy) = \texttt{reject}$ aber
            <span class="nowrap">$yy \in \halt$,</span>
            oder
          </p>
        </li>
        <li>
          <p>
            <span class="nowrap">$f_H(yy) = \texttt{undefined}$.</span>
          </p>
        </li>
      </ol>
      <p>
        Wenn uns dies gelingt, so haben wir gezeigt, dass $H$ nicht die
        Sprache $\halt$ entscheidet: im Fall 3 terminiert $H$ ja nicht
        einmal; in Fall 1 und 2 liefert $H$ zwar eine Antwort, aber die
        falsche. Der Code für $D$ ist sehr einfach:
      </p>
<pre class="listing">
<span class="listing-bol"></span>
<p>
def D(x):
    if H(xx) == accept then
    reject
    else
    accept
</p>
</pre>
      <p>
        Zur Erinnerung:
        <span class="nowrap">$y := \enc(D)$.</span>
        Wir unterscheiden drei Fälle.
      </p>
      <ul>
        <li>
          <p>
            <span class="nowrap">$H(yy) = \texttt{reject}$.</span>
            Dann geht der Aufruf von $D(y)$
            also in den
            <span class="nowrap"><code>else</code>-Teil</span>
            in den Zeilen 4-5 und
            <span class="nowrap">$D(y) = \texttt{accept}$,</span>
            somit $yy = \enc(D)y \in \halt$
            Wir befinden uns in Fall 1: $y y \in \halt$ aber
            <span class="nowrap">$H(yy)= \texttt{reject}$.</span>
            Die Maschine $H$ hat eine falsche
            Antwort für $\halt$ geliefert.
          </p>
        </li>
        <li>
          <p>
            <span class="nowrap">$H(yy) = \texttt{accept}$.</span>
            Dann geht der Aufruf von $D(y)$
            in Zeile 3, und
            <span class="nowrap">$D(y) = \texttt{reject}$,</span>
            somit
            <span class="nowrap">$yy = \enc(D) y \not \in \halt$.</span>
            Wir befinden uns in Fall 2:
            $yy \not \in \halt$ und
            <span class="nowrap">$H(yy) = \texttt{accept}$.</span>
            Die
            Maschine $H$ hat abermals eine falsche Antwort geliefert.
          </p>
        </li>
        <li>
          <p>
            $H(yy)$ terminiert nicht. Dann befinden wir uns in Fall 3:
            $H$ kann $\halt$ nicht entscheiden, denn Mindestbedingung
            hierfür wäre ja, auf jedem Eingabewort zu terminieren.
          </p>
        </li>
      </ul>
      <p>
        In jedem Fall sehen wir, dass $H$ auf dem Eingabewort $yy$ einen
        Fehler macht und somit $\halt$ nicht entscheidet. Da das für
        <i>jede</i>
        Turingmaschine geht, schließen wir: keine Turingmaschine
        kann die Sprache $\halt$ entscheiden; sie ist unentscheidbar.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p class="main-column">
      Ein Student hat am 26. Juni 2024 angemerkt, dass die Sprache
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \negdiag = \{\enc(M) \ | \ \textnormal{$M$ akzeptiert $\enc(M)$ nicht}\}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      ja eine extrem konstruierte, nicht wirklich relevante Sprache sei
      (da hatte er Recht). Insofern sei es auch nicht relevant, dass
      $\negdiag$ unentscheidbar ist. Das ist allerdings auch nicht, was
      uns interessiert: unser Ziel war, zu zeigen, dass $\halt$
      unentscheidbar ist, und die Unentscheidbarkeit von $\negdiag$ war
      ein Schritt auf diesem Weg. Dass $\halt$ unentscheidbar ist, ist
      in der Tat relevant, denn daraus folgt (nicht direkt, aber mit ein
      paar technischen Tricks), dass im Prinzip
      <i>jede</i>
      nichttriviale
      Frage über das Verhalten eines Programmcodes unentscheidbar ist.
      Also sind auch Fragen wie "Kann das Programm abstürzen?" oder "Kann
      ein unautorisierter Nutzer Zugang zu XYZ erhalten?" unentscheidbar.
    </p>
    <div class="alert-info well out main-column">
      <p>
        ℹ️ Das Wort
        <i>Unentscheidbarkeit</i>
        verwenden wir hier in seiner
        technischen Bedeutung, die wir definiert haben: es gibt keine
        Turingmaschine, die das Problem entscheidet, also auf jeder
        Eingabeinstanz terminiert und die richtige Antwort liefert. Es
        gibt also in der Tat Raum für Algorithmen, die Software
        untersuchen und diese gegebenenfalls verifizieren oder Fehler /
        Sicherheitslücken finden. Dies ist im Prinzip das sehr real
        existierende Forschungsfeld der Programmverifikation. Die
        Unentscheidbarkeit des Halteproblems impliziert nicht, dass man
        auf dem Feld der Programmverifikation keine Fortschritte erzielen
        kann; sie impliziert nur, dass es keinen ultimaten
        Programmverifikator bzw. Bugfinder gibt.
      </p>
    </div>
    <div id="end-of-page-elt">
    </div>
    <div id="bottom-menu">
      <div class="bottom-menu-left">
        <a href="./8-5.html">&lt;&lt; Kapitel 8.5<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >Turing-Maschinen simulieren Turing-Maschinen: die universelle Turing-Maschine</span></a>
      </div>
      <div class="bottom-menu-right">
        <a href="./8-7.html">Kapitel 8.7 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >Mehr über Unentscheidbarkeit: Das Postsche Korrespondenzproblem</span></a>
      </div>
    </div>
  </div>
</body>
</html>
