<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 8.6 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 8, Section 6</title>
</head>
<body class="page-sub chapter-8 sub-6">
  <div id="menu">
    <div class="menu-left">
      <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
        </span>Inhaltsverzeichnis</a><a
        id="prev-page"
        href="./8-5.html"
      >&lt;&lt; Kapitel 8.5<span
          style="visibility:hidden"
          id="prev-page-tooltip"
        >Turing-Maschinen simulieren Turing-Maschinen: die universelle Turing-Maschine</span></a>
    </div>
    <div class="menu-right">
      <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
        id="next-page"
        href="./8-7.html"
      >Kapitel 8.7 &gt;&gt;<span
          style="visibility:hidden"
          id="next-page-tooltip"
        >Mehr über Unentscheidbarkeit: Das Postsche Korrespondenzproblem</span></a>
    </div>
  </div>
  <div class="main-column page-title">
    <p>
      8.6&ensp;Unentscheidbarkeit
    </p>
  </div>
  <p class="main-column">
    Im vorherigen Teilkapitel haben wir die
    <i>universelle
      Turingmaschine</i>
    $U$ konstruiert, die eine andere Turingmaschine,
    deren Codierung und Inputwort sie als Input gegeben hat, simulieren
    kann. Technisch gesprochen: $U$ akzeptiert die Sprache
  </p>
  <div class="math-block main-column">
    $$
    \begin{align}
    \{ c w \ | \ c = \enc(M) \textnormal{ und $M$ akzeptiert $w$} \} \ .
    \label{halting-language-old-encoding}
    \end{align}
    $$
  </div>
  <p class="main-column">
    Allerdings: wenn $M$ auf $x$ nicht terminiert, dann terminiert $U$
    auf $\enc(M)x$ auch nicht. $U$
    <i>akzeptiert</i>
    die Sprache also,
    <i>entscheidet</i>
    sie aber nicht. Wäre es nicht schön, eine
    Turingmaschine zu haben, die diese Sprache entscheidet? Dann
    könnten wir jede Turingmaschine simulieren und gleichzeitig
    Endlosschleifen und eventuell ganz allgemein "Programmierfehler"
    vorhersagen und abfangen. Wir werden zeigen, dass dies leider
    <i>nicht</i>
    möglich ist. In der Literatur ist dies als die
    <i>Unentscheidbarkeit des Halteproblems</i>
    (englisch
    <i>undecidability of
      the Halting problem</i>
    bekannt). Als vorbereitenden Schritt schauen
    wir uns kurz die Codierungsfunktion nochmal genauer an. Wir
    bezeichnen mit $\tm_{\Sigma}$ die Menge aller Turingmaschinen mit
    Inputalphabet $\Sigma$ . Wir hatten die Codierungsfunktion
    $\enc: \tm_{\Sigma} \rightarrow \Lambda^*$ definiert, für das
    Codierungsalphabet
    <span class="nowrap">$\Lambda := \writelambda$.</span>
    In diesem
    Teilkapitel wird es nötig sein, die Turingmaschine über dem
    Alphabet $\Sigma$ selbst zu codieren. Dies ist nicht besonders
    schwierig, solange $\Sigma$ mindestens zwei Zeichen hat. Wenn z.B.
    $\Sigma$ die Zeichen $0$ und $1$ enthält, dann können wir alle
    Zeichen in $\Lambda$ wiederum als Strings in $\Sigma^*$ codieren.
    Wir müssen hier nur vorsichtig sein, dass der Code
    <i>präfixfrei</i>
    ist. Wenn wir zum Beispiel naiv $1$ als $1$ und $0$ als $0$ und
    $\texttt{#}$ als $01$ codieren, dann wissen wir nicht mehr, was
    mit dem Codewort $01$ gemeint ist. Am einfachsten geht das mit
    einem
    <span class="nowrap"><i>Blockcode</i>,</span>
    in dem alle Codewörter die gleiche Länge $k$
    haben, also
    <span class="nowrap">$\Lambda \rightarrow \{0,1\}^k$.</span>
    Mit
    $k = \ceil{\log_2 |\Lambda|}$ ist das kein Problem. Unsere "neue"
    Codierungsfunktion $\enc$ ist nun also
    <span class="nowrap">$\enc: \tm_{\Sigma} \rightarrow \Sigma^*$.</span>
    Wir definieren nun die
    Haltesprache
    <span class="nowrap">$\halt \in \Sigma^*$:</span>
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \halt := \{ \enc(M) w \ | \ w \in \Sigma^* \textnormal{ und } M \textnormal{ akzeptiert } w\} \ .
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Da $\enc$ präfixfrei ist, können wir erkennen, wo
    $\enc(\texttt{;})$ steht, wo also $\enc(M)$ aufhört und $w$
    beginnt. Wir können die universelle Turingmaschine $U$ leicht
    abwandeln, dass sie $\halt$ akzeptiert; wir müssen nur einen
    Decodierungsschritt vorausschicken, der die neue Codierung
    $\enc(M) \in \Sigma^*$ in unsere "alte" in $\Lambda^*$ übersetzt.
    Wir zeigen nun, dass $\halt$ unentscheidbar ist, dass es also
    keine Möglichkeit gibt, das Nichtterminieren einer Maschine $M$
    auf Eingabe $x$ vorauszusehen und abzufangen.
  </p>
  <div class="well statement out">
    <p>
      <b>Theorem</b>
      <b>8.6.1</b>
      <b>(Unentscheidbarkeit des Halteproblems).</b>
      Die Sprache $\halt$
      ist unentscheidbar.
    </p>
  </div>
  <p class="main-column">
    Ich gebe erst einmal einen kurzen und knappen Widerspruchsbeweis.
    Falls das ihnen zu schnell ging, lesen Sie den zweiten Beweis, in
    dem ich mir mehr Zeit nehme.
  </p>
  <div class="well highlight out">
    <p>
      <b>Kurzer Beweis per Wiederspruch.</b>
      Nehmen wir an, es gäbe eine
      Maschine
      <span class="nowrap">$H$,</span>
      die $\halt$ entscheidet. Dann wäre auch die
      Sprache
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \diag := \{\enc(M) \ | \ \textnormal{$M$ akzeptiert $\enc(M)$} \}
      \end{align*}
      $$
    </div>
    <p>
      entscheidbar. Warum? Wir können einfach schauen, ob das
      Eingabewort $c$ die Form $\enc(M)$ hat und in diesem Fall das
      Wort $\enc(M) \enc(M)$ der Maschine $H$ übergeben. Die Sprache
      $\diag$ ist, salopp ausgedrückt, die Menge aller
      Turingmaschinen, die ihre eigene Codierung als Inputwort
      akzeptieren. Ebenso wäre auch
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \negdiag := \{\enc(M) \ | \ \textnormal{$M$ akzeptiert $\enc(M)$ nicht}\}
      \end{align*}
      $$
    </div>
    <p>
      entscheidbar; wir müssen ja nur $\diag$ entscheiden und dann das
      Ergebnis negieren. $\negdiag$ ist sozusagen die Menge aller
      Turingmaschinen, die
      <i>nicht</i>
      ihre eigene Codierung als Inputwort
      akzeptieren. Da $\negdiag$ nach Annahme entscheidbar ist, gibt
      es eine Maschine
      <span class="nowrap">$D$,</span>
      die $\negdiag$ entscheidet. Wir fragen uns
      jetzt: gehört $\enc(D)$ selbst zu
      <span class="nowrap">$\negdiag$?</span>
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \enc(D) \in \negdiag&amp;\Longleftrightarrow \textnormal{$D$ akzeptiert $\enc(D)$ nicht}
      \tag{nach Definition von $\negdiag$} \\
      &amp;\Longleftrightarrow \textnormal{$\enc(D) \not \in L(D)$} \tag{Bedeutung der Notation $L(D)$}
      \\
      &amp;\Longleftrightarrow \enc(D) \not \in \negdiag \tag{nach Annahme $L(D) = \negdiag$}
      \end{align*}
      $$
    </div>
    <p>
      Also
      <span class="nowrap">$\enc(D) \in \negdiag \Longleftrightarrow \enc(M) \not \in
        \negdiag$,</span>
      ein Widerspruch. Unsere Annahme, dass $\halt$ entscheidbar sei,
      ist also falsch.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
    </p>
  </div>
  <div class="well highlight out">
    <p>
      <b>Ausführlicher Beweis.</b>
      Ich finde Beweise durch Widerspruch
      immer etwas unintuitiv, weil man die ganze Zeit im Konjunktiv
      argumentieren muss. Daher hier ein Beweis ohne Widerspruch. Wir
      zeigen, dass $\halt$ unentscheidbar ist, indem wir für eine
      beliebige Turingmaschine $M$ zeigen, dass sie $\halt$ nicht
      entscheidet, indem wir nämlich ein Eingabewort $z \in \Sigma^*$
      konstruieren, auf dem $M$ scheitert, also entweder
    </p>
    <ol>
      <li>
        <p>
          $f_H(z) = \texttt{accept}$ aber
          <span class="nowrap">$z \not \in \halt$,</span>
          oder
        </p>
      </li>
      <li>
        <p>
          $f_H(z) = \texttt{reject}$ aber $z \in \halt$ , oder
        </p>
      </li>
      <li>
        <p>
          <span class="nowrap">$f_H(z) = \texttt{undefined}$,</span>
          d.h. $H$ terminiert auf
          Eingabewort $z$ nicht.
        </p>
      </li>
    </ol>
    <p>
      Wir setzen nun $y := \enc(D)$ und
      <span class="nowrap">$z := yy$,</span>
      wobei $D$ eine neue
      Turingmaschine ist, die wir auf Basis von $H$ konstruieren
      werden. Also noch einmal. Für eine beliebige, uns gegebene
      Turingmaschine
      <span class="nowrap">$H$,</span>
      werden wir eine neue Turingmaschine $D$
      bauen und sie codieren als
      <span class="nowrap">$y := \enc(D)$,</span>
      so dass entweder
    </p>
    <ol>
      <li>
        <p>
          $f_H(yy) = \texttt{accept}$ aber
          <span class="nowrap">$yy \not \in \halt$,</span>
          oder
        </p>
      </li>
      <li>
        <p>
          $f_H(yy) = \texttt{reject}$ aber
          <span class="nowrap">$yy \in \halt$,</span>
          oder
        </p>
      </li>
      <li>
        <p>
          <span class="nowrap">$f_H(yy) = \texttt{undefined}$.</span>
        </p>
      </li>
    </ol>
    <p>
      Wenn uns dies gelingt, so haben wir gezeigt, dass $H$ nicht die
      Sprache $\halt$ entscheidet: im Fall 3 terminiert $H$ ja nicht
      einmal; in Fall 1 und 2 liefert $H$ zwar eine Antwort, aber die
      falsche. Der Code für $D$ ist sehr einfach:
    </p>
    <p>
<pre class="listing">
<span class="listing-bol"></span>def D(x):
<span class="listing-bol"></span>    if H(xx) == accept then
<span class="listing-bol"></span>    reject
<span class="listing-bol"></span>    else
<span class="listing-bol"></span>    accept
</pre>
    </p>
    <p>
      Zur Erinnerung:
      <span class="nowrap">$y := \enc(D)$.</span>
      Wir unterscheiden drei Fälle.
    </p>
    <ul>
      <li>
        <p>
          <span class="nowrap">$H(yy) = \texttt{reject}$.</span>
          Dann geht der Aufruf von $D(y)$
          also in den
          <span class="nowrap"><code>else</code>-Teil</span>
          in den Zeilen 4-5 und
          <span class="nowrap">$D(y) = \texttt{accept}$,</span>
          somit $yy = \enc(D)y \in \halt$
          Wir befinden uns in Fall 1: $y y \in \halt$ aber
          <span class="nowrap">$H(yy)= \texttt{reject}$.</span>
          Die Maschine $H$ hat eine falsche
          Antwort für $\halt$ geliefert.
        </p>
      </li>
      <li>
        <p>
          <span class="nowrap">$H(yy) = \texttt{accept}$.</span>
          Dann geht der Aufruf von $D(y)$
          in Zeile 3, und
          <span class="nowrap">$D(y) = \texttt{reject}$,</span>
          somit
          <span class="nowrap">$yy = \enc(D) y \not \in \halt$.</span>
          Wir befinden uns in Fall 2:
          $yy \not \in \halt$ und
          <span class="nowrap">$H(yy) = \texttt{accept}$.</span>
          Die
          Maschine $H$ hat abermals eine falsche Antwort geliefert.
        </p>
      </li>
      <li>
        <p>
          $H(yy)$ terminiert nicht. Dann befinden wir uns in Fall 3:
          $H$ kann $\halt$ nicht entscheiden, denn Mindestbedingung
          hierfür wäre ja, auf jedem Eingabewort zu terminieren.
        </p>
      </li>
    </ul>
    <p>
      In jedem Fall sehen wir, dass $H$ auf dem Eingabewort $yy$ einen
      Fehler macht und somit $\halt$ nicht entscheidet. Da das für
      <i>jede</i>
      Turingmaschine geht, schließen wir: keine Turingmaschine
      kann die Sprache $\halt$ entscheiden; sie ist unentscheidbar.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
    </p>
  </div>
  <p class="main-column">
    Ein Student hat am 26. Juni 2024 angemerkt, dass die Sprache
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \negdiag = \{\enc(M) \ | \ \textnormal{$M$ akzeptiert $\enc(M)$ nicht}\}
    \end{align*}
    $$
  </div>
  <p class="main-column">
    ja eine extrem konstruierte, nicht wirklich relevante Sprache sei
    (da hatte er Recht). Insofern sei es auch nicht relevant, dass
    $\negdiag$ unentscheidbar ist. Das ist allerdings auch nicht, was
    uns interessiert: unser Ziel war, zu zeigen, dass $\halt$
    unentscheidbar ist, und die Unentscheidbarkeit von $\negdiag$ war
    ein Schritt auf diesem Weg. Dass $\halt$ unentscheidbar ist, ist
    in der Tat relevant, denn daraus folgt (nicht direkt, aber mit ein
    paar technischen Tricks), dass im Prinzip
    <i>jede</i>
    nichttriviale
    Frage über das Verhalten eines Programmcodes unentscheidbar ist.
    Also sind auch Fragen wie "Kann das Programm abstürzen?" oder "Kann
    ein unautorisierter Nutzer Zugang zu XYZ erhalten?" unentscheidbar.
  </p>
  <div class="alert-info well out main-column">
    <p>
      ℹ️ Das Wort
      <i>Unentscheidbarkeit</i>
      verwenden wir hier in seiner
      technischen Bedeutung, die wir definiert haben: es gibt keine
      Turingmaschine, die das Problem entscheidet, also auf jeder
      Eingabeinstanz terminiert und die richtige Antwort liefert. Es
      gibt also in der Tat Raum für Algorithmen, die Software
      untersuchen und diese gegebenenfalls verifizieren oder Fehler /
      Sicherheitslücken finden. Dies ist im Prinzip das sehr real
      existierende Forschungsfeld der Programmverifikation. Die
      Unentscheidbarkeit des Halteproblems impliziert nicht, dass man
      auf dem Feld der Programmverifikation keine Fortschritte erzielen
      kann; sie impliziert nur, dass es keinen ultimaten
      Programmverifikator bzw. Bugfinder gibt.
    </p>
  </div>
  <div id="bottom-menu">
    <div class="bottom-menu-left">
      <a href="./8-5.html">&lt;&lt; Kapitel 8.5<span
          style="visibility:hidden"
          id="bottom-prev-page-tooltip"
        >Turing-Maschinen simulieren Turing-Maschinen: die universelle Turing-Maschine</span></a>
    </div>
    <div class="bottom-menu-right">
      <a href="./8-7.html">Kapitel 8.7 &gt;&gt;<span
          style="visibility:hidden"
          id="bottom-next-page-tooltip"
        >Mehr über Unentscheidbarkeit: Das Postsche Korrespondenzproblem</span></a>
    </div>
  </div>
</body>
</html>
