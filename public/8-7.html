<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 8.7 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 8, Section 7</title>
</head>
<body>
  <div class="body-wrapper">
    <div id="menu">
      <div class="menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./8-6.html"
        >&lt;&lt; Kapitel 8.6<span
            style="visibility:hidden"
            id="prev-page-tooltip"
          >
            <p>
              Unentscheidbarkeit
            </p>
          </span></a>
      </div>
      <div class="menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./8-8.html"
        >Kapitel 8.8 &gt;&gt;<span
            style="visibility:hidden"
            id="next-page-tooltip"
          >
            <p>
              Anwendungen des Postschen Korrespondenzproblems
            </p>
          </span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        8.7&ensp;Mehr über Unentscheidbarkeit: Das Postsche Korrespondenzproblem
      </p>
    </div>
    <p class="main-column">
      Die Unentscheidbarkeit des Halteproblems mag auf den ersten Blick
      esoterisch anmuten. Es taucht ja nur auf, weil die Problemstellung
      irgendwie selbstreferenziell ist. Das täuscht: Unentscheidbarkeit
      taucht in vielen Bereichen der theoretischen Informatik und der
      Mathematik auf, auch bei Fragestellungen, die auf den ersten Blick
      nichts mit Turingmaschinen zu tun haben und völlig harmlos wirken.
      Wie zum Beispiel das rein kombinatorische
      <i>Postsche
        Korrespondenzproblem.</i>
      Im Postschen Korrespondenzproblem haben wir
      endlich viele Kärtchen (auch
      <i>Kacheln</i>
      genannt) gegeben, die oben
      und unten jeweils ein Wort haben. Wir müssen die Kärtchen so
      nebeneinander legen, dass oben und unten das gleiche Wort entsteht;
      jedes Kärtchen kann beliebig oft verwendet werden. Im folgenden
      Beispiel wird das beige-farbene Kärtchen zweimal verwendet:
    </p>
    <div class="pseudowell">
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-wikipedia/01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-wikipedia/02.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-wikipedia/03.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-wikipedia/04.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-wikipedia/05.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-wikipedia/06.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-wikipedia/07.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-wikipedia/08.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-wikipedia/09.svg"
              >
            </div>
          </div>
        </div>
      </div>
    </div>
    <p class="main-column">
      (Diese Beispielinstanz ist von
      <a href="https://en.wikipedia.org/wiki/Post_correspondence_problem">Wikipedia</a>;
      die graphische Darstellung stammt von mir.) Schauen wir uns ein
      weiteres, komplizierteres Beispiel an. Hier führen wir eine
      Sonderregel ein, nämlich dass man mit der türkisen Kachel (der
      ersten) anfangen muss:
    </p>
    <div class="pseudowell">
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/02.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/03.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/04.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/05.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/06.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/07.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/08.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/09.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/10.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/11.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/12.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/13.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/14.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/15.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/16.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/17.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/18.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/19.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/20.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/21.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/22.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/23.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/24.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:18em"
                src="img/pcp/example-expo/25.svg"
              >
            </div>
          </div>
        </div>
      </div>
    </div>
    <p class="main-column">
      Können Sie das zweie PCP-Puzzle lösen und zu Ende führen?
      Informell sehen wir bereits: um das Puzzle zu lösen, müssen wir die
      $\texttt{x}$ loswerden. Das geht nur, indem wir jedes $\texttt{x}$
      mit Hilfe des fünften (beigefarbenen) Kärtchens nach rechts
      schieben, bis es auf ein $\texttt{a}$ stösst, wo wir es mit dem
      sechsten (violetten) verschwinden lassen können. Jedes $\texttt{x}$
      verdoppelt also die Anzahl der Einsen. Dieses PCP "berechnet" in
      gewisser Weise die Funktion
      <span class="nowrap">$n \mapsto 2^n$.</span>
      In ganz ähnlicher
      Weise können wir zu jeder Turingmaschine ein PCP-Puzzle bauen, das
      diese Maschine "simuliert". Aber eins nach dem anderen. Wir
      beginnen mit Terminologie.
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>8.7.1</b>
        Sei $\Sigma$ ein endliches Alphabet.
      </p>
      <ul>
        <li>
          <p>
            Eine
            <i>Kachel</i>
            (auch
            <i>Kärtchen</i>
            genannt) ist ein Paar
            <span class="nowrap">$(\alpha : \beta) \in \Sigma^* \times \Sigma^*$.</span>
            Hier
            bezeichnet $\alpha$ das Wort auf der oberen Hälfte der
            Kachel und $\beta$ das auf der unteren.
          </p>
        </li>
        <li>
          <p>
            Ein PCP-Puzzle (oder einfach nur Puzzle in diesem
            Zusammenhang) ist eine endliche Menge $S$ von Kacheln.
          </p>
        </li>
        <li>
          <p>
            Eine Kachelung ist eine Folge $s$ von Kacheln aus
            <span class="nowrap">$S$,</span>
            also
          </p>
          <div class="math-block">
            $$
            \begin{align*}
            s = (\alpha_{1} : \beta_{1}) (\alpha_{2} : \beta_{2}) \dots
            (\alpha_{m} : \beta_{m})
            \end{align*}
            $$
          </div>
          <p>
            Für eine Kachelung $s$ definieren wir den
            <i>oberen Teil</i>
            $\top(s)$ und den
            <i>unteren Teil</i>
            <span class="nowrap">$\bottom(s)$:</span>
          </p>
          <div class="math-block">
            $$
            \begin{align*}
            \top(s)&amp;:= \alpha_1 \alpha_2 \dots \alpha_m \\
            \bottom(s)&amp;:= \beta_1 \beta_2 \dots \beta_m \\
            \end{align*}
            $$
          </div>
        </li>
        <li>
          <p>
            Eine Kachelung $s$ ist eine
            <i>Lösung</i>
            des Puzzles, wenn
            $\top(s) = \bottom(s)$ gilt.
          </p>
        </li>
      </ul>
    </div>
    <p class="main-column">
      Illustrieren wir die Definitionen noch einmal anhand des ersten
      Beispiels:
    </p>
    <div class="pseudowell">
      <figure>
        <img
          style="height:12em"
          src="img/pcp/example-wikipedia/04.svg"
        >
      </figure>
    </div>
    <p class="main-column">
      Das Puzzle besteht aus drei Kacheln:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      k_1 &amp;:= (a : baa) \\
      k_2 &amp;:= (ab : aa) \\
      k_3 &amp;:= (bba : bb) \ .
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Oben sehen wir eine Kachelung $s := k_3 k_2 k_3$ und
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \top(s) &amp;= bbaabbba \\
      \bottom(s) &amp;= bbaabb \ .
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Die Kachelung $k_3 k_2 k_3$ ist noch keine Lösung, aber
      $k_3 k_2 k_3 k_1$ ist eine. Für ein festes $\Sigma$ können wir
      natürlich ein PCP-Puzzle codieren, indem wir die Menge $S$ der
      Kacheln codieren, z.B. über dem Alphabet
      <span class="nowrap">$\Sigma \cup \{(, :, )\}$.</span>
      Das erste Beispielpuzzle $S$ wäre dann
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \enc(S) := (a:baa)(ab:aa)(bba:bb)
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Somit können wir das Postsche Korrespondenzproblem formal als
      Sprache definieren:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm PCP} := \{ \enc(S) \ | \ S \textnormal{ ist ein PCP-Puzzle und hat eine Lösung} \} \ .
      \end{align*}
      $$
    </div>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>8.7.2</b>
        PCP ist unentscheidbar.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Wir zeigen: wenn PCP entscheidbar
        <span class="nowrap"><i>wäre</i>,</span>
        dann
        <i>wäre</i>
        auch $\halt$ entscheidbar. Da letzteres jedoch unentscheidbar
        ist, muss auch PCP unentscheidbar sein. Mehr im Detail: für eine
        Turingmaschine $M$ und ein Eingabewort $x$ konstruieren wir ein
        Puzzle
        <span class="nowrap">$S$,</span>
        so dass $S$ genau dann eine Lösung hat, wenn $M(x)$
        akzeptiert. Ein Entscheidungsalgorithmus für das PCP könnte somit
        auch $\halt$ entscheiden. Wie so oft in ähnlichen Beweisen
        machen wir einen Zwischenschritt. Das _Modifizierte Postsche
        Korrespondenzproblem (MPCP) _ ist genau das gleiche wie das PCP,
        nur dass es in $S$ eine markierte Startkachel gibt und jede
        Lösung mit dieser Startkachel beginnen muss. Es ist also ein
        "strengeres" Problem als das PCP.
      </p>
      <div class="well statement">
        <p>
          <b>Lemma</b>
          <b>8.7.3</b>
          Gegeben ein MPCP-Puzzle
          <span class="nowrap">$S$,</span>
          so können wir ein (normales)
          PCP-Puzzle $S'$ erstellen, mit der Eigenschaft, dass $S$ eine
          Lösung hat genau dann, wenn $S'$ eine Lösung hat.
        </p>
      </div>
      <div class="well remark">
        <p>
          <b>Beweis.</b>
          Im MPCP zwingen uns bereits die Spielregeln, mit der
          markierten Startkachel zu beginnen. Wir müssen nun, von $S$
          ausgehend, ein ähnliches Puzzle bauen, in welchem es zwar keine
          Startkachel gibt, aber dennoch nur eine Kachel überhaupt als
          Anfang in Frage kommt. Das geht mit einem Trick, in dem wir
          jede Kachel durch eine "gesternte Variante" ersetzen:
        </p>
        <div class="figure__container">
          <figure>
            <img
              style="height:5em"
              src="img/pcp/mpcp-to-pcp-01.svg"
            >
          </figure>
        </div>
        <p>
          wobei * ein neues Symbol ist. Offensichtlich kann keine solche
          Kachel ganz links stehen, da ja dann bereits das erste Symbol
          nicht übereinstimmen würde. Für die markierte Startkachel
          erstellen wir eine weitere "gesternte" Variante:
        </p>
        <div class="figure__container">
          <figure>
            <img
              style="height:5em"
              src="img/pcp/mpcp-to-pcp-02.svg"
            >
          </figure>
        </div>
        <p>
          Die gesternten Kacheln zwingen uns nun dazu, mit der
          markierten zu beginnen, da diese ja die einzige ist, wo das
          erste Symbol oben und unten übereinstimmt. Wir können nun jede
          $S'$ -Kachelung in eine
          <span class="nowrap">$S$-Kachelung</span>
          übersetzen; allerdings
          steht bei der
          <span class="nowrap">$S$-Kachelung</span>
          rechts unten ein *, rechts oben
          aber nicht. Wir erstellen nun eine weitere Kachel, die am
          rechten Rand und nur dort eingesetzt werden kann:
        </p>
        <div class="figure__container">
          <figure>
            <img
              style="height:4em"
              src="img/pcp/mpcp-to-pcp-03.svg"
            >
          </figure>
        </div>
        <p>
          Sie sehen: die letzte Kachel ist die einzige, die am rechten
          Rand stehen kann. Sollte nun das MPCP-Puzzle $S$ eine Lösung
          haben (die dann laut Spielregeln auch mit der markierten
          Startkachel beginnt), so können wir daraus eine Lösung des
          PCP-Puzzles $S'$ konstruieren, indem wir einfach jede $S$
          -Kachel durch die entsprechende $S'$ -Kachel ersetzen
          (Vorsicht: sollte die markierte Startkachel in der
          <span class="nowrap">$S$-Lösung</span>
          mehrfach vorkommen, so muss in $S'$ anfangs die "türkise"
          Version der Kachel genommen werden, mit * oben und unten; jedes
          weitere Exemplar muss dann in $S'$ durch die violette türkise
          Kachel ersetzt werden). Ganz zum Schluss hängen wir noch die
          Kachel für den rechten Rand an. Sollte umgekehrt das PCP-Puzzle
          $S'$ eine Lösung haben, so erhalten wir eine Lösung des MPCP
          Puzzles
          <span class="nowrap">$S$,</span>
          indem wir alle Sterne herausstreichen und die
          rechte Endkachel entfernen.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
        </p>
      </div>
      <p>
        Nun wissen wir also, dass wir den "Spieler" zwingen können, mit
        einer bestimmten Kachel zu beginnen, ohne dies explizit in die
        Spielregeln aufnehmen zu müssen. Unser Ziel ist nun: gegeben eine
        Turingmaschine $M$ und ein Inputwort
        <span class="nowrap">$x$,</span>
        darauf aufbauend ein
        MPCP-Puzzle $S$ zu konstruieren, das genau dann eine Lösung hat,
        wenn $M(x) = \texttt{accept}$ gilt. Erinneren wir uns: eine
        <i>Konfiguration</i>
        einer Turingmaschine ist eine Folge
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        w_1 w_2 \dots w_{j-1} q w_j \dots w_m
        \end{align*}
        $$
      </div>
      <p>
        mit $w_i \in \Gamma$ und
        <span class="nowrap">$q \in Q$.</span>
        Die Bedeutung ist, dass auf
        dem Band das Wort $w_1 w_2 \dots w_m$ steht, die Turingmaschine
        im Zustand $q$ ist und der Schreib-Lese-Kopf über den Zeichen
        $w_j$ steht. Wir schreiben also den Zustand unmittelbar
        <i>links</i>
        von dem Zeichen, über dem er steht. Wenn das Eingabewort
        $x_1 \dots x_n$ und $q_0 \in Q$ der Startzustand, dann ist
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        C_0 := q_0 x_1 \dots x_n
        \end{align*}
        $$
      </div>
      <p>
        die Startkonfiguration. Die Berechnung einer Turingmaschine ist
        nun eine Folge von Konfigurationen, die wir mit dem $\#$
        -Zeichen separieren, also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \#\# C_0 \# C_1 \# C_2 \# C_3 \# \dots \# C_t
        \end{align*}
        $$
      </div>
      <p>
        Zwei aufeinanderfolgende Konfigurationen $C_i, C_{i+1}$
        unterscheiden sich nur in der unmittelbaren Umgebung des
        Schreib-Lese-Kopfes. Der Rest ist in beiden Konfigurationen
        identisch. Die Idee ist nun, zuerst eine Startkachel
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:3em"
            src="img/pcp/halt-to-pcp-01.svg"
          >
        </figure>
      </div>
      <p>
        zu bauen. Wir sehen: oben "steht etwas über", und zwar genau die
        Startkonfiguration. Wir wollen nun weitere Kacheln entwerfen, die
        es dem Spieler erlauben, unten auch die Konfiguration zu legen,
        ihn dabei allerdings zwingen, oben die Folgekonfiguration zu
        legen. Hierfür brauchen wir "Kopierkacheln", die es uns erlauben,
        Zeichen in die Folgekonfiguration zu kopieren und "Kopf-Kacheln",
        die die Aktion am Schreib-Lese-Kopf simulieren.
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \delta(q_0, x_1) = (q_1, y, \texttt{R})
        \end{align*}
        $$
      </div>
      <p>
        ist, dann würden wir folgende Kachel erzeugen und wie folgt
        einsetzen:
      </p>
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img
                style="height:12em"
                src="img/pcp/step-right/01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:12em"
                src="img/pcp/step-right/02.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:12em"
                src="img/pcp/step-right/03.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:12em"
                src="img/pcp/step-right/04.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:12em"
                src="img/pcp/step-right/05.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:12em"
                src="img/pcp/step-right/06.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:12em"
                src="img/pcp/step-right/07.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:12em"
                src="img/pcp/step-right/08.svg"
              >
            </div>
          </div>
        </div>
      </div>
      <p>
        Was geschieht nun? Für das Symbol
        <span class="nowrap">$q_1$,</span>
        das ja einen Zustand
        bezeichnet, gibt es keine Kopierkachel. Wenn nun beispielsweise
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \delta(q_1, x_2) = (q_3, z, \texttt{L})
        \end{align*}
        $$
      </div>
      <p>
        gilt, dann müssten wir den Kopf wieder nach links verschieben,
        und er würde wiederum ganz am Anfang der Konfiguration stehen. Es
        war also ein Fehler, $y$ per Kopierkachel zu kopieren. Wir
        machen es rückgängig und legen eine der Regel
        $\delta(q_1, x_2) = (q_3, z, \texttt{L})$ entsprechende
        Kopfkachel:
      </p>
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img
                style="height:12em"
                src="img/pcp/step-left/01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:12em"
                src="img/pcp/step-left/02.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:12em"
                src="img/pcp/step-left/03.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:12em"
                src="img/pcp/step-left/04.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:12em"
                src="img/pcp/step-left/05.svg"
              >
            </div>
          </div>
        </div>
      </div>
      <p>
        Hier brauchen wir halt eine Kopfkachel $(q_2yz:yq_1x_2)$ für
        <i>jedes</i>
        Bandsymbol
        <span class="nowrap">$y$,</span>
        da die Regel immer anzuwenden ist, egal,
        welches Symbol $y$ links vom Schreib-Lese-Kopf steht. Fassen wir
        zusammen, was wir bis jetzt gesehen haben. Wir konstruieren
        Kopierkacheln
        <span class="nowrap">$(x:x)$,</span>
        die es dem Spieler erlauben, die
        Konfiguration zu kopieren; Kopfkacheln, die den Spieler zwingen,
        in der Umgebung des Schreib-Lese-Kopfes den Regeln der
        Turingmaschine zu folgen; und eine Startkachel, die die
        Startkonfiguration abbildet. Also:
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:20em"
            src="img/pcp/almost-all-tiles.svg"
          >
        </figure>
      </div>
      <p>
        Wir sind noch nicht ganz fertig. Wir brauchen noch Regeln für
        den Fall, dass der Schreib-Lese-Kopf am Rand des Bandinhaltes
        steht, konkret also die "Umgebung" des Kopfes ein $\texttt{#}$
        -Zeichen beinhaltet. Wir können entweder weitere Kopf-Kacheln
        entwerfen, die diese Fälle behandeln, oder aber
        "Bandwrweiterungskacheln", die uns erlauben, der Konfiguration
        $C$ links oder rechts ein Leersymbol $\_$ anzuhängen. Ich
        überlasse es an dieser Stelle dem Leser / der Leserin, die
        Details hierfür auszuarbeiten. Ganz zum Schluss müssen wir noch
        beschreiben, was geschieht, wenn die Maschine in den
        akzeptierenden Zustand $q^*$ wechselt. Wir erschaffen Kacheln,
        die erlauben, alle Bandsymbole zu löschen, bis das Band leer ist:
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:6em"
            src="img/pcp/tile-delete-symbols.svg"
          >
        </figure>
      </div>
      <p>
        und ganz am Schluss eine Kachel $(\# : q^* \# \#)$ , um alles
        abzuschließen. Die letzten zwei Schritte sehen dann so aus:
      </p>
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img
                style="height:10em"
                src="img/pcp/finish-00.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:10em"
                src="img/pcp/finish-01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:10em"
                src="img/pcp/finish-03.svg"
              >
            </div>
          </div>
        </div>
      </div>
      <p>
        Strenggenommen müssten wir jetzt beweisen, dass das MPCP-Puzzle
        genau dann lösbar ist, wenn die Turingmaschine akzeptiert.
        Hierfür könnten wir zum Beispiel zeigen, dass, wenn $s$ eine
        Kachelung ist, in welcher $\top(s)$ und $\bottom(s)$ beide auf
        dem Zeichen $\#$ enden und wenn $\bottom(s)$ nicht das Zeichen
        $q^*$ enthält, dann ist
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \top(s)&amp;= \#\# C_0 \# C_1 \# \dots \# C_{j+1}\# \\
        \bottom(s)&amp;= \#\# C_0 \# C_1 \# \dots \# C_j\# \\
        \end{align*}
        $$
      </div>
      <p>
        wobei $C_0 = q_0 x_1 \dots x_n$ die Startkonfiguration der
        Turingmaschine ist und jedes $C_{i+1}$ die Folgekonfiguration
        von
        <span class="nowrap">$C_i$;</span>
        dass also die Teillösung $s$ des Puzzles getreu die
        Berechnung der Turingmaschine abbildet. Wir ersparen uns weitere
        Details.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <div id="end-of-page-elt">
    </div>
    <div id="bottom-menu">
      <div class="bottom-menu-left">
        <a href="./8-6.html">&lt;&lt; Kapitel 8.6<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >
            <p>
              Unentscheidbarkeit
            </p>
          </span></a>
      </div>
      <div class="bottom-menu-right">
        <a href="./8-8.html">Kapitel 8.8 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >
            <p>
              Anwendungen des Postschen Korrespondenzproblems
            </p>
          </span></a>
      </div>
    </div>
  </div>
</body>
</html>
