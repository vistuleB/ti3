<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 8.7 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 8, Section 7</title>
</head>
<body class="page-sub chapter-8 sub-7">
  <div id="menu">
    <div class="menu-left">
      <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
        </span>Inhaltsverzeichnis</a>
      <div>
        <a
          id="prev-page"
          href="./8-6.html"
        >&lt;&lt; Kapitel 8.6<span
            style="visibility:hidden"
            id="prev-page-tooltip"
          >Unentscheidbarkeit</span></a>
      </div>
    </div>
    <div class="menu-right">
      <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a>
      <div>
        <a
          id="next-page"
          href="./8-8.html"
        >Kapitel 8.8 &gt;&gt;<span
            style="visibility:hidden"
            id="next-page-tooltip"
          >Anwendungen des Postschen Korrespondenzproblems</span></a>
      </div>
    </div>
  </div>
  <div class="main-column page-title">
    <p>
      8.7&ensp;Mehr über Unentscheidbarkeit: Das Postsche Korrespondenzproblem
    </p>
  </div>
  <p class="main-column">
    Die Unentscheidbarkeit des Halteproblems mag auf den ersten Blick
    esoterisch anmuten. Es taucht ja nur auf, weil die Problemstellung
    irgendwie selbstreferenziell ist. Das täuscht: Unentscheidbarkeit
    taucht in vielen Bereichen der theoretischen Informatik und der
    Mathematik auf, auch bei Fragestellungen, die auf den ersten Blick
    nichts mit Turingmaschinen zu tun haben und völlig harmlos wirken.
    Wie zum Beispiel das rein kombinatorische
    <i>Postsche
      Korrespondenzproblem.</i>
    Im Postschen Korrespondenzproblem haben wir
    endlich viele Kärtchen (auch
    <i>Kacheln</i>
    genannt) gegeben, die oben
    und unten jeweils ein Wort haben. Wir müssen die Kärtchen so
    nebeneinander legen, dass oben und unten das gleiche Wort entsteht;
    jedes Kärtchen kann beliebig oft verwendet werden. Im folgenden
    Beispiel wird das beige-farbene Kärtchen zweimal verwendet:
  </p>
  <div class="pseudowell">
    <div class="carousel__container">
      <div class="carousel">
        <div class="carousel__items">
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-wikipedia/01.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-wikipedia/02.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-wikipedia/03.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-wikipedia/04.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-wikipedia/05.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-wikipedia/06.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-wikipedia/07.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-wikipedia/08.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-wikipedia/09.svg"
            >
          </div>
        </div>
      </div>
    </div>
  </div>
  <p class="main-column">
    (Diese Beispielinstanz ist von
    <a href="https://en.wikipedia.org/wiki/Post_correspondence_problem">Wikipedia</a>;
    die graphische Darstellung stammt von mir.) Schauen wir uns ein
    weiteres, komplizierteres Beispiel an. Hier führen wir eine
    Sonderregel ein, nämlich dass man mit der türkisen Kachel (der
    ersten) anfangen muss:
  </p>
  <div class="pseudowell">
    <div class="carousel__container">
      <div class="carousel">
        <div class="carousel__items">
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/01.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/02.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/03.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/04.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/05.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/06.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/07.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/08.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/09.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/10.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/11.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/12.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/13.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/14.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/15.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/16.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/17.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/18.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/19.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/20.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/21.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/22.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/23.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/24.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:18em"
              src="img/pcp/example-expo/25.svg"
            >
          </div>
        </div>
      </div>
    </div>
  </div>
  <p class="main-column">
    Können Sie das zweie PCP-Puzzle lösen und zu Ende führen?
    Informell sehen wir bereits: um das Puzzle zu lösen, müssen wir die
    $\texttt{x}$ loswerden. Das geht nur, indem wir jedes $\texttt{x}$
    mit Hilfe des fünften (beigefarbenen) Kärtchens nach rechts
    schieben, bis es auf ein $\texttt{a}$ stösst, wo wir es mit dem
    sechsten (violetten) verschwinden lassen können. Jedes $\texttt{x}$
    verdoppelt also die Anzahl der Einsen. Dieses PCP "berechnet" in
    gewisser Weise die Funktion
    <span class="nowrap">$n \mapsto 2^n$.</span>
    In ganz ähnlicher
    Weise können wir zu jeder Turingmaschine ein PCP-Puzzle bauen, das
    diese Maschine "simuliert". Aber eins nach dem anderen. Wir
    beginnen mit Terminologie.
  </p>
  <div class="well statement out">
    <p>
      <b>Definition</b>
      <b>8.7.1</b>
      Sei $\Sigma$ ein endliches Alphabet.
    </p>
    <ul>
      <li>
        <p>
          Eine
          <i>Kachel</i>
          (auch
          <i>Kärtchen</i>
          genannt) ist ein Paar
          <span class="nowrap">$(\alpha : \beta) \in \Sigma^* \times \Sigma^*$.</span>
          Hier
          bezeichnet $\alpha$ das Wort auf der oberen Hälfte der
          Kachel und $\beta$ das auf der unteren.
        </p>
      </li>
      <li>
        <p>
          Ein PCP-Puzzle (oder einfach nur Puzzle in diesem
          Zusammenhang) ist eine endliche Menge $S$ von Kacheln.
        </p>
      </li>
      <li>
        <p>
          Eine Kachelung ist eine Folge $s$ von Kacheln aus
          <span class="nowrap">$S$,</span>
          also
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          s = (\alpha_{1} : \beta_{1}) (\alpha_{2} : \beta_{2}) \dots
          (\alpha_{m} : \beta_{m})
          \end{align*}
          $$
        </div>
        <p>
          Für eine Kachelung $s$ definieren wir den
          <i>oberen Teil</i>
          $\top(s)$ und den
          <i>unteren Teil</i>
          <span class="nowrap">$\bottom(s)$:</span>
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          \top(s)&amp;:= \alpha_1 \alpha_2 \dots \alpha_m \\
          \bottom(s)&amp;:= \beta_1 \beta_2 \dots \beta_m \\
          \end{align*}
          $$
        </div>
      </li>
      <li>
        <p>
          Eine Kachelung $s$ ist eine
          <i>Lösung</i>
          des Puzzles, wenn
          $\top(s) = \bottom(s)$ gilt.
        </p>
      </li>
    </ul>
  </div>
  <p class="main-column">
    Illustrieren wir die Definitionen noch einmal anhand des ersten
    Beispiels:
  </p>
  <div class="pseudowell">
    <figure>
      <img
        style="height:12em"
        src="img/pcp/example-wikipedia/04.svg"
      >
    </figure>
  </div>
  <p class="main-column">
    Das Puzzle besteht aus drei Kacheln:
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    k_1 &amp;:= (a : baa) \\
    k_2 &amp;:= (ab : aa) \\
    k_3 &amp;:= (bba : bb) \ .
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Oben sehen wir eine Kachelung $s := k_3 k_2 k_3$ und
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \top(s) &amp;= bbaabbba \\
    \bottom(s) &amp;= bbaabb \ .
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Die Kachelung $k_3 k_2 k_3$ ist noch keine Lösung, aber
    $k_3 k_2 k_3 k_1$ ist eine. Für ein festes $\Sigma$ können wir
    natürlich ein PCP-Puzzle codieren, indem wir die Menge $S$ der
    Kacheln codieren, z.B. über dem Alphabet
    <span class="nowrap">$\Sigma \cup \{(, :, )\}$.</span>
    Das erste Beispielpuzzle $S$ wäre dann
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \enc(S) := (a:baa)(ab:aa)(bba:bb)
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Somit können wir das Postsche Korrespondenzproblem formal als
    Sprache definieren:
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    {\rm PCP} := \{ \enc(S) \ | \ S \textnormal{ ist ein PCP-Puzzle und hat eine Lösung} \} \ .
    \end{align*}
    $$
  </div>
  <div class="well statement out">
    <p>
      <b>Theorem</b>
      <b>8.7.2</b>
      PCP ist unentscheidbar.
    </p>
  </div>
  <div class="well highlight out">
    <p>
      <b>Beweis.</b>
      Wir zeigen: wenn PCP entscheidbar
      <span class="nowrap"><i>wäre</i>,</span>
      dann
      <i>wäre</i>
      auch $\halt$ entscheidbar. Da letzteres jedoch unentscheidbar
      ist, muss auch PCP unentscheidbar sein. Mehr im Detail: für eine
      Turingmaschine $M$ und ein Eingabewort $x$ konstruieren wir ein
      Puzzle
      <span class="nowrap">$S$,</span>
      so dass $S$ genau dann eine Lösung hat, wenn $M(x)$
      akzeptiert. Ein Entscheidungsalgorithmus für das PCP könnte somit
      auch $\halt$ entscheiden. Wie so oft in ähnlichen Beweisen
      machen wir einen Zwischenschritt. Das _Modifizierte Postsche
      Korrespondenzproblem (MPCP) _ ist genau das gleiche wie das PCP,
      nur dass es in $S$ eine markierte Startkachel gibt und jede
      Lösung mit dieser Startkachel beginnen muss. Es ist also ein
      "strengeres" Problem als das PCP.
    </p>
    <div class="well statement">
      <p>
        <b>Lemma</b>
        <b>8.7.3</b>
        Gegeben ein MPCP-Puzzle
        <span class="nowrap">$S$,</span>
        so können wir ein (normales)
        PCP-Puzzle $S'$ erstellen, mit der Eigenschaft, dass $S$ eine
        Lösung hat genau dann, wenn $S'$ eine Lösung hat.
      </p>
    </div>
    <div class="well remark">
      <p>
        <b>Beweis.</b>
        Im MPCP zwingen uns bereits die Spielregeln, mit der
        markierten Startkachel zu beginnen. Wir müssen nun, von $S$
        ausgehend, ein ähnliches Puzzle bauen, in welchem es zwar keine
        Startkachel gibt, aber dennoch nur eine Kachel überhaupt als
        Anfang in Frage kommt. Das geht mit einem Trick, in dem wir
        jede Kachel durch eine "gesternte Variante" ersetzen:
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:5em"
            src="img/pcp/mpcp-to-pcp-01.svg"
          >
        </figure>
      </div>
      <p>
        wobei * ein neues Symbol ist. Offensichtlich kann keine solche
        Kachel ganz links stehen, da ja dann bereits das erste Symbol
        nicht übereinstimmen würde. Für die markierte Startkachel
        erstellen wir eine weitere "gesternte" Variante:
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:5em"
            src="img/pcp/mpcp-to-pcp-02.svg"
          >
        </figure>
      </div>
      <p>
        Die gesternten Kacheln zwingen uns nun dazu, mit der
        markierten zu beginnen, da diese ja die einzige ist, wo das
        erste Symbol oben und unten übereinstimmt. Wir können nun jede
        $S'$ -Kachelung in eine
        <span class="nowrap">$S$-Kachelung</span>
        übersetzen; allerdings
        steht bei der
        <span class="nowrap">$S$-Kachelung</span>
        rechts unten ein *, rechts oben
        aber nicht. Wir erstellen nun eine weitere Kachel, die am
        rechten Rand und nur dort eingesetzt werden kann:
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:4em"
            src="img/pcp/mpcp-to-pcp-03.svg"
          >
        </figure>
      </div>
      <p>
        Sie sehen: die letzte Kachel ist die einzige, die am rechten
        Rand stehen kann. Sollte nun das MPCP-Puzzle $S$ eine Lösung
        haben (die dann laut Spielregeln auch mit der markierten
        Startkachel beginnt), so können wir daraus eine Lösung des
        PCP-Puzzles $S'$ konstruieren, indem wir einfach jede $S$
        -Kachel durch die entsprechende $S'$ -Kachel ersetzen
        (Vorsicht: sollte die markierte Startkachel in der
        <span class="nowrap">$S$-Lösung</span>
        mehrfach vorkommen, so muss in $S'$ anfangs die "türkise"
        Version der Kachel genommen werden, mit * oben und unten; jedes
        weitere Exemplar muss dann in $S'$ durch die violette türkise
        Kachel ersetzt werden). Ganz zum Schluss hängen wir noch die
        Kachel für den rechten Rand an. Sollte umgekehrt das PCP-Puzzle
        $S'$ eine Lösung haben, so erhalten wir eine Lösung des MPCP
        Puzzles
        <span class="nowrap">$S$,</span>
        indem wir alle Sterne herausstreichen und die
        rechte Endkachel entfernen.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p>
      Nun wissen wir also, dass wir den "Spieler" zwingen können, mit
      einer bestimmten Kachel zu beginnen, ohne dies explizit in die
      Spielregeln aufnehmen zu müssen. Unser Ziel ist nun: gegeben eine
      Turingmaschine $M$ und ein Inputwort
      <span class="nowrap">$x$,</span>
      darauf aufbauend ein
      MPCP-Puzzle $S$ zu konstruieren, das genau dann eine Lösung hat,
      wenn $M(x) = \texttt{accept}$ gilt. Erinneren wir uns: eine
      <i>Konfiguration</i>
      einer Turingmaschine ist eine Folge
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      w_1 w_2 \dots w_{j-1} q w_j \dots w_m
      \end{align*}
      $$
    </div>
    <p>
      mit $w_i \in \Gamma$ und
      <span class="nowrap">$q \in Q$.</span>
      Die Bedeutung ist, dass auf
      dem Band das Wort $w_1 w_2 \dots w_m$ steht, die Turingmaschine
      im Zustand $q$ ist und der Schreib-Lese-Kopf über den Zeichen
      $w_j$ steht. Wir schreiben also den Zustand unmittelbar
      <i>links</i>
      von dem Zeichen, über dem er steht. Wenn das Eingabewort
      $x_1 \dots x_n$ und $q_0 \in Q$ der Startzustand, dann ist
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      C_0 := q_0 x_1 \dots x_n
      \end{align*}
      $$
    </div>
    <p>
      die Startkonfiguration. Die Berechnung einer Turingmaschine ist
      nun eine Folge von Konfigurationen, die wir mit dem $\#$
      -Zeichen separieren, also
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \#\# C_0 \# C_1 \# C_2 \# C_3 \# \dots \# C_t
      \end{align*}
      $$
    </div>
    <p>
      Zwei aufeinanderfolgende Konfigurationen $C_i, C_{i+1}$
      unterscheiden sich nur in der unmittelbaren Umgebung des
      Schreib-Lese-Kopfes. Der Rest ist in beiden Konfigurationen
      identisch. Die Idee ist nun, zuerst eine Startkachel
    </p>
    <div class="figure__container">
      <figure>
        <img
          style="height:3em"
          src="img/pcp/halt-to-pcp-01.svg"
        >
      </figure>
    </div>
    <p>
      zu bauen. Wir sehen: oben "steht etwas über", und zwar genau die
      Startkonfiguration. Wir wollen nun weitere Kacheln entwerfen, die
      es dem Spieler erlauben, unten auch die Konfiguration zu legen,
      ihn dabei allerdings zwingen, oben die Folgekonfiguration zu
      legen. Hierfür brauchen wir "Kopierkacheln", die es uns erlauben,
      Zeichen in die Folgekonfiguration zu kopieren und "Kopf-Kacheln",
      die die Aktion am Schreib-Lese-Kopf simulieren.
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \delta(q_0, x_1) = (q_1, y, \texttt{R})
      \end{align*}
      $$
    </div>
    <p>
      ist, dann würden wir folgende Kachel erzeugen und wie folgt
      einsetzen:
    </p>
    <div class="carousel__container">
      <div class="carousel">
        <div class="carousel__items">
          <div class="carousel__item">
            <img
              style="height:12em"
              src="img/pcp/step-right/01.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:12em"
              src="img/pcp/step-right/02.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:12em"
              src="img/pcp/step-right/03.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:12em"
              src="img/pcp/step-right/04.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:12em"
              src="img/pcp/step-right/05.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:12em"
              src="img/pcp/step-right/06.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:12em"
              src="img/pcp/step-right/07.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:12em"
              src="img/pcp/step-right/08.svg"
            >
          </div>
        </div>
      </div>
    </div>
    <p>
      Was geschieht nun? Für das Symbol
      <span class="nowrap">$q_1$,</span>
      das ja einen Zustand
      bezeichnet, gibt es keine Kopierkachel. Wenn nun beispielsweise
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \delta(q_1, x_2) = (q_3, z, \texttt{L})
      \end{align*}
      $$
    </div>
    <p>
      gilt, dann müssten wir den Kopf wieder nach links verschieben,
      und er würde wiederum ganz am Anfang der Konfiguration stehen. Es
      war also ein Fehler, $y$ per Kopierkachel zu kopieren. Wir
      machen es rückgängig und legen eine der Regel
      $\delta(q_1, x_2) = (q_3, z, \texttt{L})$ entsprechende
      Kopfkachel:
    </p>
    <div class="carousel__container">
      <div class="carousel">
        <div class="carousel__items">
          <div class="carousel__item">
            <img
              style="height:12em"
              src="img/pcp/step-left/01.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:12em"
              src="img/pcp/step-left/02.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:12em"
              src="img/pcp/step-left/03.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:12em"
              src="img/pcp/step-left/04.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:12em"
              src="img/pcp/step-left/05.svg"
            >
          </div>
        </div>
      </div>
    </div>
    <p>
      Hier brauchen wir halt eine Kopfkachel $(q_2yz:yq_1x_2)$ für
      <i>jedes</i>
      Bandsymbol
      <span class="nowrap">$y$,</span>
      da die Regel immer anzuwenden ist, egal,
      welches Symbol $y$ links vom Schreib-Lese-Kopf steht. Fassen wir
      zusammen, was wir bis jetzt gesehen haben. Wir konstruieren
      Kopierkacheln
      <span class="nowrap">$(x:x)$,</span>
      die es dem Spieler erlauben, die
      Konfiguration zu kopieren; Kopfkacheln, die den Spieler zwingen,
      in der Umgebung des Schreib-Lese-Kopfes den Regeln der
      Turingmaschine zu folgen; und eine Startkachel, die die
      Startkonfiguration abbildet. Also:
    </p>
    <div class="figure__container">
      <figure>
        <img
          style="height:20em"
          src="img/pcp/almost-all-tiles.svg"
        >
      </figure>
    </div>
    <p>
      Wir sind noch nicht ganz fertig. Wir brauchen noch Regeln für
      den Fall, dass der Schreib-Lese-Kopf am Rand des Bandinhaltes
      steht, konkret also die "Umgebung" des Kopfes ein $\texttt{#}$
      -Zeichen beinhaltet. Wir können entweder weitere Kopf-Kacheln
      entwerfen, die diese Fälle behandeln, oder aber
      "Bandwrweiterungskacheln", die uns erlauben, der Konfiguration
      $C$ links oder rechts ein Leersymbol $\_$ anzuhängen. Ich
      überlasse es an dieser Stelle dem Leser / der Leserin, die
      Details hierfür auszuarbeiten. Ganz zum Schluss müssen wir noch
      beschreiben, was geschieht, wenn die Maschine in den
      akzeptierenden Zustand $q^*$ wechselt. Wir erschaffen Kacheln,
      die erlauben, alle Bandsymbole zu löschen, bis das Band leer ist:
    </p>
    <div class="figure__container">
      <figure>
        <img
          style="height:6em"
          src="img/pcp/tile-delete-symbols.svg"
        >
      </figure>
    </div>
    <p>
      und ganz am Schluss eine Kachel $(\# : q^* \# \#)$ , um alles
      abzuschließen. Die letzten zwei Schritte sehen dann so aus:
    </p>
    <div class="carousel__container">
      <div class="carousel">
        <div class="carousel__items">
          <div class="carousel__item">
            <img
              style="height:10em"
              src="img/pcp/finish-00.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:10em"
              src="img/pcp/finish-01.svg"
            >
          </div>
          <div class="carousel__item">
            <img
              style="height:10em"
              src="img/pcp/finish-03.svg"
            >
          </div>
        </div>
      </div>
    </div>
    <p>
      Strenggenommen müssten wir jetzt beweisen, dass das MPCP-Puzzle
      genau dann lösbar ist, wenn die Turingmaschine akzeptiert.
      Hierfür könnten wir zum Beispiel zeigen, dass, wenn $s$ eine
      Kachelung ist, in welcher $\top(s)$ und $\bottom(s)$ beide auf
      dem Zeichen $\#$ enden und wenn $\bottom(s)$ nicht das Zeichen
      $q^*$ enthält, dann ist
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \top(s)&amp;= \#\# C_0 \# C_1 \# \dots \# C_{j+1}\# \\
      \bottom(s)&amp;= \#\# C_0 \# C_1 \# \dots \# C_j\# \\
      \end{align*}
      $$
    </div>
    <p>
      wobei $C_0 = q_0 x_1 \dots x_n$ die Startkonfiguration der
      Turingmaschine ist und jedes $C_{i+1}$ die Folgekonfiguration
      von
      <span class="nowrap">$C_i$;</span>
      dass also die Teillösung $s$ des Puzzles getreu die
      Berechnung der Turingmaschine abbildet. Wir ersparen uns weitere
      Details.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
    </p>
  </div>
</body>
</html>
