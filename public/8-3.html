<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 8.3 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 8, Section 3</title>
</head>
<body>
  <div class="body-wrapper">
    <div id="menu">
      <div class="menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./8-2.html"
        >&lt;&lt; Kapitel 8.2<span
            style="visibility:hidden"
            id="prev-page-tooltip"
          >
            <p>
              Beispiele
            </p>
          </span></a>
      </div>
      <div class="menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./8-4.html"
        >Kapitel 8.4 &gt;&gt;<span
            style="visibility:hidden"
            id="next-page-tooltip"
          >
            <p>
              Turing-Maschinen codieren
            </p>
          </span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        8.3&ensp;Variationen: Mehrband-Maschinen, nichtdeterministische Maschinen
      </p>
    </div>
    <h2 class="main-column topic-announcement">
      Turingmaschinen mit mehreren Bändern
    </h2>
    <p class="main-column">
      Im letzten Teilkapitel ist Ihnen bestimmt aufgefallen, dass es
      auffallend lästig ist, selbst für einfache Sprachen wie
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \{a^n b^n c^n \ | \ n \geq 0 \}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      oder
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \{wcw
      | \ w \in \{a,b\}^*\}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Turingmaschinen zu programmieren. Ein Grund dafür ist, dass die
      Maschine nur an einer Position des Bandes lesen und schreiben kann
      und man deswegen ständig zwischen verschiedenen Stellen hin- und
      herfahren muss. Es bietet sich daher an, an etwas allgemeineres
      Modell einer Rechenmaschine zu definieren, das dann auch leichter
      zu programmieren ist. Dies ist die
      <span class="nowrap"><i>Mehrband-Turingmaschine</i>.</span>
      Eine
      Mehrband-Turingmaschine ist wie eine Turingmaschine, nur dass sie
      statt einem $k$ viele Bänder und somit auch $k$ viele
      Schreib-Lese-Köpfe hat. Die Zustandsübergangsfunktion $\delta$ hat
      somit auch die Signatur
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \delta : Q \times \Gamma^k
      \rightarrow Q \times \Gamma^k \times \lsr^k
      \end{align*}
      $$
    </div>
    <div class="pseudowell">
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img
                style="height:21em"
                src="img/turing-machines/example-3-multitape/01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:21em"
                src="img/turing-machines/example-3-multitape/02.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:21em"
                src="img/turing-machines/example-3-multitape/03.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:21em"
                src="img/turing-machines/example-3-multitape/04.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:21em"
                src="img/turing-machines/example-3-multitape/05.svg"
              >
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="well statement out">
      <p>
        <b>Beispiel</b>
        <b>8.3.1</b>
        Entwerfen wir nun eine Turingmaschine für die Palindromsprache
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        L := \{ w \in \{a,b\}^* \ | \ w = w^R \} \ ,
        \end{align*}
        $$
      </div>
      <p>
        In
        <a
          href="./8-2.html#_30_hgi_"
          class=""
        >Beispiel 8.2.2</a>
        haben wir dafür eine
        Einband-Turingmaschine geschrieben. Deren Nachteil war, dass sie
        ständig zwischen dem linken und rechten Rand hin-und-herlaufen
        musste. Bauen wir nun eine Mehrband-Turingmaschine. Diese
        arbeitet in drei einfachen und kurzen Phasen:
      </p>
      <ol>
        <li>
          <p>
            <span class="nowrap"><code>copy</code>:</span>
            kopiert das $w$ auf das zweite Band
          </p>
        </li>
        <li>
          <p>
            <span class="nowrap"><code>rewind</code>:</span>
            bewegt den Kopf des ersten Bandes zurück zum
            Anfang
          </p>
        </li>
        <li>
          <p>
            <span class="nowrap"><code>compare</code>:</span>
            schaut, ob erstes und zweites Band den gleichen
            Inhalt haben.
          </p>
        </li>
      </ol>
      <p>
        Den "Quelltext" für
        <a href="https://turingmachinesimulator.com">turingmachinesimulator.com</a>
        finden Sie in
        <a href="./code/turing%20machines/palindrome-multiple-tapes.txt">palindrome-multiple-tapes.txt</a>.
      </p>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 8.3.1</b>
        Schreiben Sie eine Mehrband-Turingmaschine, die Binärzahlen
        addiert. Wenn also beispielsweise
        <code>1010+110</code>
        auf dem ersten Band
        (Eingabeband) steht, dann soll nach Abschluss der Berechnung das
        Ergebnis auf dem Ausgabeband stehen, also
        <span class="nowrap"><code>10000</code>.</span>
        <b>Tip.</b>
        Verwenden Sie drei Bänder. Sei der Bandinhalt
        <span class="nowrap">$x+y$.</span>
        In einer
        ersten Phase kopieren Sie $x$ auf das zweite Band. In der
        nächsten Phase gehen Sie ans Ende von
        <span class="nowrap">$y$.</span>
        Dann addieren Sie
        nach den Regeln der Binäraddition. Ob "1 gemerkt" gilt oder
        nicht, können Sie in Ihrem internen Zustand speichern. Eine Regel
        wäre also zum Beispiel:
      </p>
      <p>
<pre>
carry1, 0, 0, _
carry0, 0, 0, 1,&lt;,&lt;,&lt;
carry1, 0, 1, _
carry1, 0, 1, 0,&lt;,&lt;,&lt;
</pre>
      </p>
      <p>
        Ein lästiges Detail ist, dass $y$ kürzer sein könnte als $x$ und
        Sie daher in das
        <code>+</code>
        reinlaufen könnten; wenn $x$ kürzer ist als
        <span class="nowrap">$y$,</span>
        dann könnten Sie auf dem zweiten Band in ein $\square$
        reinlaufen. Wie ist dieser Fall zu behandeln?
      </p>
    </div>
    <p class="main-column">
      <b>Berechnete Sprache, berechnete Funktion.</b>
      Die Begriffe des
      Akzpetierens und Ablehnens definieren wir genau wie für die
      Einband-Turingmaschinen. Eine formale Definition der Konfiguration
      ersparen wir uns jedoch. Wenn unsere Mehrband-Turingmaschine nicht
      nur akzeptieren / ablehnen, sondern etwas
      <i>berechnen</i>
      soll, also
      eine Funktion
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      f :
      \Sigma_1 \rightarrow \Sigma_2 \ ,
      \end{align*}
      $$
    </div>
    <p class="main-column">
      dann bauen wir sie per Konvention so, dass sie ein designiertes
      Ausgabeband hat, auf dem nach Abschluss der Berechnung das
      Ausgabewort $f(x)$ steht.
    </p>
    <h2 class="main-column topic-announcement">
      Einband-Maschinen können Mehrband-Maschinen simulieren
    </h2>
    <p class="main-column">
      Es stellt sich heraus, dass mehrere Bänder zwar ein praktisches
      Feature sind, aber nicht wirklich mehr Ausdruckskraft verlangen;
      was eine Mehrband-Turingmaschine schafft, schafft eine
      Einband-Turingmaschine auch.
    </p>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>8.3.2</b>
        <span class="nowrap"><b>(Einband-Turingmaschine simuliert Mehrband-Turingmaschine)</b>.</span>
        Sei $M$ eine Turingmaschine mit $k$ Bändern, wovon eines ein
        designiertes Ausgabeband ist. Dann gibt es eine
        Einband-Turingmaschine $M'$ mit folgenden Eigenschaften:
      </p>
      <ol>
        <li>
          <p>
            $M'(x)$ akzeptiert/lehnt ab/terminiert nicht genau dann,
            wenn $M(x)$ akzeptiert/ablehnt/nicht terminiert.
          </p>
        </li>
        <li>
          <p>
            Wenn $M(x)$ akzeptiert und $y$ der Bandinhalt des
            Ausgabebandes ist, dann akzeptiert $M'(x)$ auch, und der
            Bandinhalt (des einzigen Bandes, es gibt ja nur eins) ist
            <span class="nowrap">$y$.</span>
          </p>
        </li>
      </ol>
      <p>
        In anderen Worten: $M'$ simuliert
        <span class="nowrap">$M$.</span>
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Beweis.</b>
        <b>8.3.3</b>
        Der erste Trick ist, dass wir die $k$ Bänder von $M$
        "zusammenkleben" in ein neues Band, in welcher jede Zelle $k$
        Symbole enthalten kann:
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height: 12em"
            src="img/turing-machines/example-3-multitape/multitape-to-onetape.svg"
          >
        </figure>
      </div>
      <p>
        Das Problem sind nun die Köpfe. Wenn wir diese Idee naiv
        umsetzen würden, hätte unsere Maschine $M'$ zwar ein Band, dafür
        drei Köpfe auf diesem:
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height: 15em"
            src="img/turing-machines/example-3-multitape/multitape-to-onetape-three-heads.svg"
          >
        </figure>
      </div>
      <p>
        Wir lösen dies, indem wir die Kopfpositionen in das Band selbst
        reinschreiben:
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height: 12em"
            src="img/turing-machines/example-3-multitape/multitape-to-onetape-one-head.svg"
          >
        </figure>
      </div>
      <p>
        Das neue Bandalphabet ist also nicht $\Gamma^k$ sondern
        <span class="nowrap">$(\Gamma \times \{\texttt{head}, \texttt{nohead}\} )^k$.</span>
        Wo
        steht nun aber denn der Kopf von
        <span class="nowrap">$M'$?</span>
        Jetzt kommt der
        schwierige Teil: um
        <i>einen</i>
        Schritt von $M$ zu simulieren, muss
        $M'$ von ganz links nach ganz rechts laufen und alle
        Informationen über die $k$
        <span class="nowrap">$M$-Köpfe</span>
        sammeln. Dann von rechts
        nach links gehen und die ausführen.
      </p>
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/01-01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/02-01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/02-02.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/02-03.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/02-04.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/02-05.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/02-06.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/02-07.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/02-08.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/03-01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/03-02.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/04-01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/04-02.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/04-03.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/04-04.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/05-01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/05-02.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/06-01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/07-01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:19em"
                src="img/turing-machines/one-simulates-multi/08-01.svg"
              >
            </div>
          </div>
        </div>
      </div>
      <p>
        Wir müssen also die Zustandsmenge deutlich erweitern; so muss
        sie speichern können, ob wir ein Symbol bereits gelesen haben; ob
        wir ein Symbol bereits geschrieben haben und ob wir den Kopf
        bereits entsprechend verschoben haben. Für eine
        Rechtsverschiebung müssen wir uns zusätzlich noch merken, dass
        wir sie gerade durchführen und für welches Band. All dies ist
        viel, aber immer noch endlich. Wir können alles in einer
        endlichen Zustandsmenge $Q'$ speichern. Wenn der $M$ -Zustand
        (der natürlich auch im
        <span class="nowrap">$M'$-Zustand</span>
        gespeichert
        <span class="nowrap">ist),<code>accept</code>erreicht</span>
        hat, dann macht $M'$ noch eine
        Aufräumphase, in welcher sie alle Symbole, die nicht zum
        Ausgabeband gehören, durch $\square$ ersetzt. Dann wechselt sie
        in ihren eigenen akzeptierenden Zustand
        <span class="nowrap"><code>accept'</code>.</span><span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <h2 class="main-column topic-announcement">
      Einfügen versus Überschreiben
    </h2>
    <p class="main-column">
      Folgende Aufgabe ist auf einer Einband-Turingmaschine sehr leicht:
      gegeben ein Eingabewort $w \in \{a,b\}^*$ , ersetze jedes $b$
      durch ein
      <span class="nowrap">$c$.</span>
      In der Syntax von
      <a href="https://turingmachinesimulator.com">turingmachinesimulator.com</a>:
    </p>
    <p class="main-column">
<pre class="listing">
<span class="listing-bol"></span>name: replace_b_by_c
<span class="listing-bol"></span>init: init
<span class="listing-bol"></span>accept: accept
<span class="listing-bol"></span>init, a
<span class="listing-bol"></span>init, a, &gt;
<span class="listing-bol"></span>init, b
<span class="listing-bol"></span>init, c, &gt;
<span class="listing-bol"></span>init, _
<span class="listing-bol"></span>accept, _, &gt;
</pre>
    </p>
    <p class="main-column">
      Ungleich schwieriger ist die Aufgabe, jedes $b$ durch ein $bc$ zu
      ersetzen, weil wir hier etwas
      <i>einfügen</i>
      wollen. Auf einer
      Einband-Turingmaschine müssen wir für jedes $b$ alles, was rechts
      davon kommt, um eine Zelle nach rechts verschieben. Meinen
      Quelltext finden sie in
      <a href="./code/turing%20machines/replace-b-by-bc.txt">replace-b-by-bc.txt</a>.
      Können wir unserer Turingmaschine die Funktionalität geben, eine
      Zelle
      <i>einzufügen</i>
      und alles von Kopf bis zum linken Ende um eins
      nach links zu verschieben bzw. das analoge, aber nach rechts? Wir
      sind freie Menschen, wir können definieren, was wir wollen, müssen
      uns aber zwei Fragen stellen:
    </p>
    <div class="main-column">
      <ol>
        <li>
          <p>
            Ist das immer noch ein plausibles Modell einer Rechenmaschine?
            Ist also unser neue Funktionalität physikalisch realisierbar?
          </p>
        </li>
        <li>
          <p>
            Verleiht es wirklich neue Funktionalität, oder ist es nur
            Syntaxzucker?
          </p>
        </li>
      </ol>
    </div>
    <p class="main-column">
      In diesem Fall ahnen Sie es wohl bereits: es ist nur Syntaxzucker.
      Die Funktionalität des
      <i>Einfügens/Verschiebens</i>
      können wir leicht
      mit zwei Bändern simulieren. Wir halten uns einfach an die
      Konvention, dass auf Band 1 der Kopf immer auf dem linkesten
      Zeichen steht und auf Band 2 der Kopf jenseits des rechtesten.
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \delta(q,x) = (r,y,\texttt{R})
      \end{align*}
      $$
    </div>
    <p class="main-column">
      wird dann
    </p>
    <div class="main-column">
<pre class="container">
q, x, _
r, _, x, &gt;, &gt; 
</pre>
    </div>
    <p class="main-column">
      Eine Linksbewegung ist etwas schwieriger zu implementieren. Aus
      $\delta(q,x) = (r,y,\texttt{L})$ wird
    </p>
    <p class="main-column">
<pre class="orange-comments">
q,  x, _
r', x, _, -, -
r', _, c
r,  c, _   <span class="actual-orange-comment">// für jedes Zeichen c</span>
</pre>
    </p>
    <p class="main-column">
      Nehmen Sie die Beispielmaschine
      <a href="./code/turing%20machines/go-left-go-right.txt">go-left-go-right.txt</a>,
      geben Sie sie auf
      <a href="https://turingmachinesimulator.com">turingmachinesimulator.com</a>
      ein und starten Sie sie mit dem Eingabewort
      <span class="nowrap">$xxx$.</span>
      Ein neues
      Zeichen links vom Kopf einfügen ist nun einfach: aus
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \delta(q,x) = \textnormal{Zustand $r$, schreibe $y$ und
      füge $z$ links vom Kopf ein}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      wird
    </p>
    <p class="main-column">
<pre class="orange-comments">
q,   x, _
r'', _, z, &gt;, &gt;
r'', c, _
r,   c, y, -, &gt;  <span class="actual-orange-comment">// für jedes Zeichen c</span>
</pre>
    </p>
    <p class="main-column">
      Sie können sich meine Implementierung in
      <a href="./code/turing%20machines/insert-z-before-y.txt">insert-z-before-y.txt</a>
      ansehen. Geben Sie beispielsweise
      <code>xxyxyyxx</code>
      als Eingabewort ein.
      Wir können von nun an also so tun, als hätten unsere
      Turingmaschinen die Möglichkeit, zusätzliche Zellen einzufügen. In
      einer konkreten Implementierung müssten wir dafür allerdings jedes
      Band durch zwei Bänder ersetzen. Alternativ können Sie sich eine
      Turingmaschine vorstellen, die statt $k$ Bändern einfach $2k$
      Stapel hat.
    </p>
    <h2 class="main-column topic-announcement">
      Die Dictionary-Maschine
    </h2>
    <p class="main-column">
      Ein fundamentale Datenstruktur beim Programmieren sind
      <span class="nowrap"><i>Dictionaries</i>,</span>
      die Key-Value-Paare speichern:
    </p>
    <p class="main-column">
<pre class="python-prompt">
<span class="terminal-prompt">user@home:~$</span><span class="terminal-prompt-content"> python -i</span>
<span class="python-prompt-carets">&gt;&gt;&gt;</span><span class="python-prompt-content"> dict = {"karl" : 42, "eva" : 35, "werner" : 20}</span>
<span class="python-prompt-carets">&gt;&gt;&gt;</span><span class="python-prompt-content"> dict["eva"]</span>
<span class="python-prompt-ok-response">35</span>
<span class="python-prompt-carets">&gt;&gt;&gt;</span><span class="python-prompt-content"></span>
</pre>
    </p>
    <p class="main-column">
      Im Zweifelsfall sind diese als Hashmaps oder Rot-Schwarz-Bäume
      oder B-Bäume implementiert. Hier interessiert uns nicht so sehr die
      Laufzeit, sondern einfach die Funktionalität. Können wir für
      Dictionaries eine Turingmaschine implementieren?
    </p>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 8.3.2</b>
        Schreiben Sie auf
        <a href="https://turingmachinesimulator.com">turingmachinesimulator.com</a>
        eine Mehrband-Turingmaschine, die Inputs der Form
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        k [ k_1 : v_1; k_2 : v_2; \dots ; k_n : v_n ]
        \end{align*}
        $$
      </div>
      <p>
        entgegennimmt, für
        <span class="nowrap">$k, k_1, \dots, k_n, v_1, \dots, v_n \in \{0,1\}^n$,</span>
        also
        $\Sigma = \{0,1, \texttt{:}, \texttt{;}, \texttt{[},
        \texttt{]}\}$
        und akzeptiert, wenn es ein $i$ gibt mit $k = k_i$ und in diesem
        Falle $v_i$ auf das Ausgabeband schreibt.
        <b>Tip:</b>
        Kopieren Sie
        erst einmal den gesuchten Schlüssel $k$ auf das zweite Band.
        Dann können Sie bequem den Schlüssel $k_i$ auf dem ersten Band
        mit dem auf dem zweiten Band vergleichen. Wenn Sie es sich
        einfach machen wollen, nehmen Sie einfach mal an, dass alle
        Schlüssel gleiche Länge haben. Das erspart Ihnen gefühlt 20
        Zeilen im Programmcode der Turingmaschine.
      </p>
    </div>
    <h2 class="main-column topic-announcement">
      Nichtdeterministische Turingmaschinen
    </h2>
    <p class="main-column">
      Bereits im Kapitel über reguläre Sprachen haben wir gesehen, dass
      Nichtdeterminismus hilfreich ist, wenn wir Dinge beschreiben
      wollen, auch wenn es kein realistisches Modell für Rechenmaschinen
      darstellt. Die Sprache aller Wörter über $\{a,b\}$ , die das
      Teilwort $aababaa$ enthalten, kann man beispielsweise leicht mit
      dem folgenden Automaten beschreiben:
    </p>
    <div class="pseudowell">
      <figure>
        <img
          style="height: 6em"
          src="img/turing-machines/nondeterminism/aababaa.svg"
        >
      </figure>
    </div>
    <p class="main-column">
      Es ist klar, was dieser Automat erlaubt. Einen deterministischen
      Automaten für die gleiche Sprache zu entwerfen (ohne systematisch
      über den nichtdeterministischen zu gehen) wird schnell chaotisch,
      und Sie werden sich in den vielen Fallunterscheidungen verlieren.
      Andererseits haben wir für endliche Automaten gezeigt, dass die
      deterministischen und nichtdeterministischen Varianten tatsächlich
      gleichmächtig sind (Potenzmengenkonstruktion). Für die
      Kellerautomaten, die für kontextfreie Sprachen relevant sind, galt
      das nicht (einen Beweis haben wir allerdings in der Vorlesung nicht
      durchgenommen). Wie sieht es nun für Turingmaschinen aus? Um
      nichtdeterministische Turingmaschinen zu definieren, müssen wir die
      Zustandsübergangsfunktion $\delta$ zu einer
      Zustandsübergangsrelation machen. Statt
      $\delta: Q \times \Gamma \rightarrow Q \times \Gamma \times
      \lsr$
      also nun
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \delta \subseteq (Q \times \Gamma) \times (Q \times \Gamma \times
      \lsr) \ .
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Und statt $\delta(q,x) = (r,y,\texttt{D})$ schreiben wir nun
      <span class="nowrap">$(q,x) \step{\delta} (r,y,\texttt{D})$.</span>
      Wir beschränken uns
      zunächst auf Einband-Turingmaschinen. Für Konfigurationen
      $C \in \Gamma^* \times Q \times\Gamma^*$ haben wir keine
      erweiterte Zustandsübergangsfunktion
      <span class="nowrap">$\delta(C) = C'$,</span>
      wo $C'$ die
      Folgekonfiguration ist, sondern eine erweiterte
      Zustandsübergangsrelation:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      C \Step{} C'
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Wobei nun dank Nichtdeterminismus mehrere Folgekonfigurationen $C'$
      geben kann (oder eben mal auch gar keine). Wir schreiben
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      C \Step{}^* C'
      \end{align*}
      $$
    </div>
    <p class="main-column">
      wenn wir von $C$ in einer Folge von Schritten nach $C'$ kommen
      können, also
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      C =
      C_0 \Step{} C_1 \Step{} C_2 \Step{} \dots \Step{} C'
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Wir sagen auch:
      <span class="nowrap"><i>Die Konfiguration $C'$ ist von $C$ aus
          erreichbar</i>.</span>
      Für ein Eingabewort $x$ sie $C_x := \texttt{start} x$
      die Startkonfiguration. Eine nichtdeterministische Turingmaschine
      <i>akzeptiert</i>
      <span class="nowrap">$x$,</span>
      wenn es eine akzeptierende Endkonfiguration
      $C_{\rm accept}$ gibt mit
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      C_x \Step{}^* C_{\rm
      accept}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      wenn es also (mindestens) eine akzeptierende Konfiguration gibt,
      die von $C_x$ aus erreichbar ist. Dabei kann es
      <i>mehrere</i>
      erreichbare akzeptierende Konfigurationen geben, Es kann sogar eine
      ablehnende Konfiguration $C_x \Step{}^* C_{\rm reject}$ geben.
      Spielt keine Rolle: solange es einen Weg
      $C_x \Step{}^* C_{\rm accept}$ gibt, sagen wir, dass $M$ das
      Eingabewort akzeptiert.
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>8.3.4</b>
        <b>(Akzeptieren und Entscheiden bei nichtdeterministischen
          Turingmaschinen).</b>
        Eine nichtdeterministische Turingmaschine $M$
        akzeptiert die Sprache $L$ wenn
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        x \in L \Longleftrightarrow M \textnormal {
        akzeptiert } x
        \end{align*}
        $$
      </div>
      <p>
        Für jedes $x \not \in L$ gibt es also keine akzeptierende
        Konfiguration $C$ mit
        <span class="nowrap">$C_x \Rightarrow C$.</span>
        Die Turingmaschine $M$
        <i>entscheidet</i>
        die Sprache
        <span class="nowrap">$L$,</span>
        wenn sie sie akzeptiert und es
        keine unendlich langen Ketten
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        C_x \Step{} C_1 \Step{} C_2 \Step{} \dots
        \end{align*}
        $$
      </div>
      <p>
        gibt.
      </p>
    </div>
    <div class="well alert-warning out main-column">
      <p>
        ⚠⚠ Oft wird händeringend versucht, zu erklären, was denn eine
        nichtdeterministische Turingmaschine
        <span class="nowrap"><i>tut</i>.</span>
        Da lesen Sie dann
        beispielsweise, dass die
        <i>alle Möglichkeiten gleichzeitig
          ausprobiert</i>
        oder den richtigen Pfad von einem
        <i>Engel</i>
        gesagt
        bekommt oder
        <span class="nowrap"><i>errät</i>.</span>
        Ich stelle mir lieber vor, dass eine
        nichtdeterministische Turingmaschine gar nichts "tut" sondern
        <i>Spielregeln</i>
        definiert, wie man "ziehen" kann. Man gewinnt, wenn
        man in einer akzeptierenden Konfiguration landet. ⚠⚠
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Beispiel</b>
        <b>8.3.5</b>
        Beim Teilsummenproblem haben wir eine Liste von Waren (alles
        Unikate) mit Preisen $p_1, p_2, \dots, p_n$ und ein Guthaben $g$
        gegeben und wollen wissen, ob wir unser Guthaben exakt ausgeben
        können. Ob es also eine Teilmenge $I \subseteq [n]$ von Waren
        gibt, die genau $g$ kostet:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \textnormal{gibt es ein } I \subseteq [n]
        \textnormal{ mit } \sum_{i \in I} p_i = g \textnormal{?}
        \end{align*}
        $$
      </div>
      <p>
        Um das als formale Sprachen bzw. Entscheidungsproblem zu
        formalisieren, müssen wir uns eine Codierung überlegen. Preise
        sind ganze Zahlen (in Cent, wenn Sie so wollen), in
        Dezimalschreibweise dargstellt. Waren sind mit einem $\#$
        separiert. Nach den Waren kommt ein $:$ und dann das Guthaben.
        Wenn also beispielsweise die Waren die Preise 65, 8, 22, 19, 7,
        58, 30, 1, 13, 38 haben und unser Guthaben 194 ist, dann würden
        wir das als Wort
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \#65\#8\#22\#19\#7\#58\#30\#1\#13\#38:194
        \end{align*}
        $$
      </div>
      <p>
        über dem Alphabet $\Sigma = \{0,1,2,3,4,5,6,7,8,9,\#,:\}$
        codieren. Das Wort ist in unserer Sprache $L$ enthalten, wenn es
        nun eben eine Teilmenge gibt, die sich genau zu 194 aufsummiert.
        Entwerfen wir nun eine nichtdeterministische Turingmaschine $M$
        für diese Sprache. $M$ geht von links nach rechts alle Waren
        durch. Jedes Mal, wenn ein Preis beginnt, haben wir die
        Möglichkeit, diesen Preis auf das zweite Band zu kopieren (die
        Ware zu kaufen) oder eben nicht: also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        (\texttt{choose}, \#, \square)
        &amp;\rightarrow (\texttt{buy}, \#, +, \texttt{R}, \texttt{R})\\
        (\texttt{choose}, \#, \square)&amp;\rightarrow (\texttt{skip}, \#,
        \texttt{R}, \texttt{S}) \\ \\ (\texttt{buy}, c, \square)&amp;
        \rightarrow (\texttt{buy}, c, c, \texttt{R}, \texttt{R}) \tag{für
        jedes \(c \in \{0,\dots,9\}\)}\\ (\texttt{buy}, \#, \square)&amp;
        \rightarrow (\texttt{choose}, \#, \square, \texttt{S}, \texttt{S})
        (\texttt{skip}, c, \square)&amp;\rightarrow (\texttt{skip}, c,
        \square, \texttt{R}, \texttt{S}) \tag{für jedes \(c \in
        \{0,\dots,9\}\)}\\ (\texttt{skip}, \#, \square)&amp;\rightarrow
        (\texttt{choose}, \#, \square, \texttt{S}, \texttt{S}) \\ \\
        (\texttt{buy}, :, \square)&amp;\rightarrow (\texttt{add}, :, \square,
        \texttt{S}, \texttt{S}) \\ (\texttt{skip}, :, \square)&amp;\rightarrow
        (\texttt{add}, :, \square, \texttt{S}, \texttt{S}) \\
        \end{align*}
        $$
      </div>
      <p>
        Dies erlaubt uns zum Beispiel, bei Eingabe
        $\#65\#8\#22\#19\#7\#58\#30\#1\#13\#38:194$ eine Konfiguration
        zu erreichen, wo auf dem ersten Band der Kopf auf dem : steht und
        auf dem zweiten Band
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        + 6 + 19 + 58 + 1 + 13
        \end{align*}
        $$
      </div>
      <p>
        aber eben auch jede beliebige andere Summe. Im Zustand
        $\texttt{add}$ aufgerufen, muss nun die Turingmaschine alle
        diese Zahlen auf dem zweiten Band addieren (lästig, geht aber
        irgendwie) und dann in einer dritten Phase mit der Zahl rechts
        vom : vergleichen. Stimmen sie überein, akzeptiert die
        Turingmaschine, stimmt sie nicht über ein, lehnt sie ab. Da
        <span class="nowrap">$6 + 19 + 58 + 1 + 13 = 97$,</span>
        haben wir eine ablehnende
        Konfiguration erreicht. Es sind aber viele Endkonfigurationen
        erreichbar. Wir können zum Beispiel in Phase 1 auch
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        + 65 + 22 + 19+ 7+ 30+ 13+38
        \end{align*}
        $$
      </div>
      <p>
        auf das untere Band kopieren. Da dies tatsächlich 194 ergibt,
        akzeptiert die Turingmaschine. Wir sehen also:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        M(\#65\#8\#22\#19\#7\#58\#30\#1\#13\#38:194) =
        \texttt{accept} \ ,
        \end{align*}
        $$
      </div>
      <p>
        weil es eben eine vom Start aus erreichbare akzeptierende
        Konfiguration gibt.
      </p>
    </div>
    <h2 class="main-column topic-announcement">
      Deterministische Turingmaschinen simulieren
      nichtdeterministische
    </h2>
    <p class="main-column">
      Sind nun nichtdeterministische Turingmaschinen inhärent mächtiger?
      Können Sie das Teilsummenproblem auch mit einer deterministischen
      lösen? Klar! Hier ist mein Code in Elm, einer funktionalen
      Programmiersprache: er probiert alle Möglichkeiten durch.
    </p>
    <div class="main-column">
<pre class="listing">
<span class="listing-bol"></span>module SubsetSum exposing (..)
<span class="listing-bol"></span>subsetSum : List Int -&gt;; Int -&gt;; Bool
<span class="listing-bol"></span>subsetSum prices amount =
<span class="listing-bol"></span>    case ( prices, amount ) of
<span class="listing-bol"></span>    ( [], 0 ) -&gt;;
<span class="listing-bol"></span>        True
<span class="listing-bol"></span>    ( x :: rest, _ ) -&gt;;
<span class="listing-bol"></span>        subsetSum rest amount || subsetSum rest (amount - x)
<span class="listing-bol"></span>    ( [], _ ) -&gt;;
<span class="listing-bol"></span>        False
</pre>
    </div>
    <p class="main-column">
      Auf einer deterministischen Turingmaschine wäre das deutlich
      anstrengender, aber irgendwie auch möglich. Können wir jede
      nichtdeterministische Turingmaschine deterministisch simulieren,
      indem wir "alles ausprobieren"? Ja, in der Tat!
    </p>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>8.3.6</b>
        <b>(Nichtdeterministische Turingmaschinen
          deterministischsimulieren)</b>
        Sei $M$ eine nichtdeterministische
        Turingmaschine. Dann gibt es eine deterministische Maschine $M'$
        mit
        <span class="nowrap">$L(M) = L(M')$,</span>
        d.h. $M'$ akzeptiert $x$ genau dann, wenn $M$
        es akzeptiert. Zusätzlich gilt: wenn $M$ die Sprache nicht nur
        akzpetiert, sondern entscheidet, dann entscheidet auch $M'$ die
        Sprache (terminiert also auf jedem Eingabewort).
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Als erstes führen wir eine kosmetische Änderung unserer
        nichtdeterministischen Maschine durch: wir wollen, dass es für
        jedes $(q,c)$ genau zwei Möglichkeiten gibt, also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        (q,c)&amp;
        \rightarrow (q_1, c_1, D_1) \\ (q,c)&amp;\rightarrow (q_2, c_2, D_2) \ ,
        \end{align*}
        $$
      </div>
      <p>
        außer wenn
        <span class="nowrap">$q \in \{\texttt{reject},\texttt{accept}\}$;</span>
        dann
        gibt es gar keine Möglichkeit. Dies ist einfach: sollte es mehr
        als zwei Möglichkeiten geben, so führen wir Zwischenzustände ein:
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height: 10em"
            src="img/turing-machines/nondeterminism/three-to-two.svg"
          >
        </figure>
      </div>
      <p>
        Auf der Menge der Konfigurationen schaut das dann noch
        intuitiver aus:
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height: 10em"
            src="img/turing-machines/nondeterminism/three-to-two-2.svg"
          >
        </figure>
      </div>
      <p>
        Sollte ein Paar $(q,c)$ weniger als zwei Folgemöglichkeiten
        geben, so erfinden wir einfach neue, die jedoch direkt
        <span class="nowrap">nach<code>reject</code></span>
        führen. Es sollte klar sein, dass diese Änderungen
        rein kosmetisch sind und nichts an der Funktionsweise von $M$
        ändern. Nun bauen wir $M$ um und geben ihr ein zweites Band. Auf
        diesem Band soll ein Wort in $\{0,1\}^*$ stehen. Wir machen $M$
        deterministisch mit der folgenden Regel: wenn Du im Zustand $q$
        bist und auf dem ersten Band ein $c$ hast und auf dem zweiten
        Band eine $0$ liest, nimm den oberen Pfeil, der von $q,c$
        ausgeht; wenn Du eine $1$ liest, nimm den unteren Pfeil.
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height: 10em"
            src="img/turing-machines/nondeterminism/two-to-det.svg"
          >
        </figure>
      </div>
      <p>
        Falls wir auf dem zweiten Band einem anderen Zeichen begegnen (
        $\square$ oder sonst etwas, das weder 0 noch 1 ist), dann lehnen
        wir sofort ab. Wir haben nun eine deterministische Turingmaschine
        <span class="nowrap">$M''$,</span>
        die jedoch nicht das gleiche tut wie $M$ . Aber: wenn
        <span class="nowrap">$x \in L(M)$,</span>
        dann gibt es ein Wort
        <span class="nowrap">$z \in \{0,1\}^*$,</span>
        das wir
        auf das zweite Band schreiben
        <span class="nowrap"><i>könnten</i>,</span>
        so dass $M''$ das
        Eingabewort $x$ akzeptiert. Im Gegenzug: wenn
        <span class="nowrap">$x \not \in L(M)$,</span>
        dann können wir auf das zweite Band schreiben, was wir wollen,
        $M''$ wird immer ablehnen.
      </p>
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/02.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/03.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/04.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/05.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/06.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/07.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/08.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/09.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/10.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/11.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/12.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/13.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:23rm"
                src="img/turing-machines/det-simulates-nondet/14.svg"
              >
            </div>
          </div>
        </div>
      </div>
      <p>
        Nun bauen wir schlussendlich eine Maschine
        <span class="nowrap">$M'$,</span>
        die in einer
        Endlosschleife alle möglichen $z \in \{0,1\}^*$ aufzählt, auf
        das zweite Band schreibt, und $M''$ neustartet. Geht das? Wir
        können zum Beispiel $i = 1,2,3,4,\dots$ hochzählen, binär
        schreiben und die führende 1 löschen. Überzeugen Sie sich, dass
        in dieser Reihe wirklich alle $z \in \{0,1\}^*$ vorkommen.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <div id="end-of-page-elt">
    </div>
    <div id="bottom-menu">
      <div class="bottom-menu-left">
        <a href="./8-2.html">&lt;&lt; Kapitel 8.2<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >
            <p>
              Beispiele
            </p>
          </span></a>
      </div>
      <div class="bottom-menu-right">
        <a href="./8-4.html">Kapitel 8.4 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >
            <p>
              Turing-Maschinen codieren
            </p>
          </span></a>
      </div>
    </div>
  </div>
</body>
</html>
