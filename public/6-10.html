<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 6.10 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 6, Section 10</title>
</head>
<body class="page-sub chapter-6 sub-10">
  <div class="menu menu-biplane">
    <div class="menu-biplane-left">
      <a href="./index.html">Inhaltsverzeichnis</a><a
        href="./6-9.html"
        id="prev-page"
      >&lt;&lt; Kapitel 6.9</a>
    </div>
    <div class="menu-biplane-right">
      <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
        href="./6-11.html"
        id="next-page"
      >Kapitel 6.11 &gt;&gt;</a>
    </div>
  </div>
  <div class="menu menu-horizontal">
    <a href="./6-9.html">&lt;&lt; Kapitel 6.9</a><a href="./index.html">Inhaltsverzeichnis</a><a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a href="./6-11.html">Kapitel 6.11 &gt;&gt;</a>
  </div>
  <div class="main-column page-title">
    <p>
      6.10 
      Allgemeines Parsing
    </p>
  </div>
  <p class="main-column">
    Wir haben drei Methoden kennengelernt, kontextfreie Sprachen zu
    parsen: rekursiver Abstieg (mit Demoseite
    <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/demos/drawManualGrammar.html">drawManualGrammar.html</a>),
    die LL-Parser (die die Mengen $\First_k(X)$ berechnen, wie auf
    <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/demos/drawFirstComputation.html">drawFirstComputation.html</a>
    demonstriert), und die LR-Parser (die die Teilbäume auf den Stack
    legen und nach Blüten suchen, hier die Demoseite
    <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/demos/drawLR0ParserPrefixArithmetic.html">drawLR0ParserPrefixArithmetic</a>
    für arithmetische Ausdrücke). Rekursiver Abstieg kann, wenn man
    nicht vorsichtig ist, in Endlosschleifen landen und kann im
    Allgemeinen selbst bei einfachen Grammatiken exponentielle Laufzeit
    aufweisen. LL-Parser und LR-Parser funktionieren schlicht nicht für
    allgemeine kontextfreie Grammatiken. Standardbeispiel ist die
    Palindromsprache ohne Kennzeichnung der Mitte:
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    S&amp;\rightarrow aSa \\
    S&amp;\rightarrow bSb \\
    S&amp;\rightarrow a \ | \ b \ | \ \epsilon
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Weder LL-Parser noch LR-Parser können bei langen Wörtern wie
    $aaaaaaaaaaaaaabbaaaaaaaaaaaaaa$ erkennen, wo die Mitte ist. Das
    muss man aber wissen, denn sonst landet man in einer Sackgasse. Es
    gilt sogar: jeder Kellerautomat für diese Sprache muss
    nichtdeterministisch sein (was wir an dieser Stelle weder formal
    definieren noch beweisen). Noch schlimmer steht es mit Grammatiken
    wie
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    S&amp;\rightarrow AY \ \ | XC \\
    A&amp;\rightarrow aA \ | \ \epsilon \\
    C&amp;\rightarrow cC \ | \ \epsilon \\
    X&amp;\rightarrow aXb \ | \epsilon \\
    Y&amp;\rightarrow bYc \ | \epsilon
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Diese erzeugt die Sprache
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    L = \{ a^i b^j c^k \ | \ i = j \textnormal{ oder } j = k \}
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Die Grammatik ist
    <span class="nowrap"><i>mehrdeutig</i>,</span>
    insbesondere kann jedes Wort der
    Form $a^i b^i c^i$ auf zwei Weisen abgeleitet werden: via $AY$ und
    via
    <span class="nowrap">$XC$.</span>
    Man kann sogar zeigen, dass
    <i>jede</i>
    äquivalente Grammatik
    <span class="nowrap">$G'$,</span>
    die also die gleiche Sprache $L$ erzeugt, mehrdeutig sein
    muss; man sagt, die Sprache $L$ ist
    <span class="nowrap"><i>inhärent mehrdeutig</i>.</span>
    Für
    nichtdeterministische oder gar mehrdeutige Grammatiken / Sprachen
    sind LL- und LR-Parser unbrauchbar. Gibt es eine allgemeine
    Methode, die für alle Grammatiken funktioniert? Ja, den sogenannten
    CYK-Algorithmus. Nur leider ist die nicht besonders schnell. Sie
    hat kubische Laufzeit
    <span class="nowrap">$O(n^3)$,</span>
    was zwar in der theoretischen
    Informatik als
    <i>effizient</i>
    durchgeht, in der Praxis leider meist
    unbrauchbar ist.
  </p>
  <h2 class="main-column topic-announcement">
    Chomsky-Normalform
  </h2>
  <p class="main-column">
    Eine kontextfreie Grammatik ist in
    <span class="nowrap"><i>Chomsky-Normalform</i>,</span>
    wenn jede
    Produktion eine der folgenden Formen hat:
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    X&amp;\rightarrow YZ \\
    X&amp;\rightarrow a
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Eine solche Sprache kann offensichtlich nicht das Wort $\epsilon$
    ableiten. Daher lassen wir als Sonderregel die Produktion
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    S&amp;\rightarrow \epsilon
    \end{align*}
    $$
  </div>
  <p class="main-column">
    zu, verbieten dann aber, dass das Startsymbol $S$ auf der rechten
    Seite einer Produktion vorkommen kann.
  </p>
  <div class="well statement out">
    <p>
      <b>Theorem</b>
      <b>6.10.1</b>
      Zu jeder kontextfreien Grammatik gibt es eine äquivalente
      Grammatik in Chomsky-Normalform.
    </p>
  </div>
  <p class="main-column">
    Anstatt hier einen formalen Beweis anzugeben (den Sie sich, wenn
    Sie wollen, im Lehrbuch oder auf Wikipedia anschauen können), lasse
    ich Sie lieber anhand einer Übungsaufgabe die Konstruktion von
    selbst verstehen:
  </p>
  <div class="well exercise out">
    <p>
      <b>Übungsaufgabe 6.10.1</b>
      Finden Sie zu der folgenden kontextfreien Grammatik
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      S&amp;\rightarrow A \ | \ Bb \ | \ C \\
      A&amp;\rightarrow xyB \ | \ B \ | \ BC \\
      B&amp;\rightarrow yzC \ | \ AC \\
      C&amp;\rightarrow xzA \ | \ AB \ | \ \epsilon
      \end{align*}
      $$
    </div>
    <p>
      eine äquivalente in Chomsky-Normalform. Fragen, die Sie sich
      dabei stellen sollten:
    </p>
    <ol>
      <li>
        <p>
          Für welche Nichtterminale gibt es
          <span class="nowrap">$U \Step{}^* V$?</span>
          Zeichnen
          Sie ein Bildchen mit all diesen $\Step{}^*$ -Pfeilen.
        </p>
      </li>
      <li>
        <p>
          Von welchen Nichtterminalen können Sie überhaupt Wörter
          ableiten, also
          <span class="nowrap">$U \Step{}^* w \in \Sigma^*$?</span>
          Wie finden Sie
          das im Allgemeinen heraus?
        </p>
      </li>
      <li>
        <p>
          Welche Nichtterminale können $\epsilon$ ableiten, also
          <span class="nowrap">$U \Step{}^* \epsilon$?</span>
          Wie finden Sie das im Allgemeinen
          heraus?
        </p>
      </li>
    </ol>
  </div>
  <p class="main-column">
    Wenn nun $G$ in Chomsky-Normalform vorliegt und wir für ein
    gegebenes Eingabewort $w$ eine Ableitung $G: S \Step{}^* w$ finden
    wollen (oder feststellen, dass es keine gibt), so ist die erste
    Beobachtung, dass eine Linksableitung die Form
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    S&amp;\Step{}^* AB \Step{}^* uB \Step{}^* uv
    \end{align*}
    $$
  </div>
  <p class="main-column">
    haben muss, für
    <span class="nowrap">$w = uv$.</span>
    Wenn wir die Unterteilung von $w$ in $u$
    und $v$ kennen würden, so könnten wir rekursiv fragen, wie man
    denn $A \Step{}^* u$ und $B \Step{}^* v$ ableitet. Da wir sie aber
    <i>nicht</i>
    kennen, also konkret nicht wissen, wie lange $u$ und $v$
    sind, können wir alle Möglichkeiten durchprobieren. Da $G$ in
    Chomsky-Normalform vorliegt, wissen wir, dass $|u| \geq 1$ und
    <span class="nowrap">$|v| \geq 1$,</span>
    also
    <span class="nowrap">$1 \leq |u| \leq |w|-1$.</span>
    Wir probieren also
    alle $n-1$ möglichen Zerlegungen von $w$ durch. Wenn wir das
    rekursiv täten, dann würden das eine enorme Laufzeit verursachen.
    Der Trick besteht darin, Zwischenergebnisse systematisch zu
    berechnen, um somit Laufzeit zu sparen.
  </p>
  <h2 class="main-column topic-announcement">
    Der CYK-Algorithmus
  </h2>
  <p class="main-column">
    Die oben skizzierte Idee ist im CYK-Algorithmus konkretisiert
    (benannt nach John Cocke, Daniel Younger und Tadao Kasami). Für die
    praktische Anwendung ist dieser weniger relevant. Dafür ist er ein
    wunderbares Beispiel für einen Algorithmus, der auf dem Prinzip des
    <i>Dynamic Programing</i>
    fußt, welches Sie in der Vorlesung
    <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/AuK/index.html">Algorithmen und
      Komplexität</a>
    im dritten Semester ausführlicher kennenlernen wollen. Wir
    beschränken uns bei dem folgenden Algorithmus zunächst darauf, die
    Frage zu beantworten, ob den überhaupt $S \Step{}^* w$ gilt, und
    interessieren uns erst einmal nicht dafür eine solche Ableitung
    auch zu finden (in der Algorithmik versteht man das als
    <span class="nowrap"><i>Entscheidungsproblem</i>,</span>
    im Gegensatz zu dem allgemeinerin
    <span class="nowrap"><i>Suchproblem</i>).</span>
    Der Entwurf eines Dynamic-Programming-Algorithmus
    beginnt oft mit der folgenden Frage:
    <i>Was sind sinnvolle
      Zwischenergebnisse?</i>
    In unserem Falle sind Ableitungen der Form
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    X&amp;\Step{}^* u
    \end{align*}
    $$
  </div>
  <p class="main-column">
    sinnvolle Zwischenergebnisse, wenn $u$ ein Teilwort von $w$ ist,
    also
    <span class="nowrap">$w = v_1 u v_2$.</span>
    Konkret schreiben wir
    $w = w_0 w_1 \dots w_{n-1}$ und definieren
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    w[i:j] := w_i w_{i+1} \dots w_{j-1}
    \end{align*}
    $$
  </div>
  <p class="main-column">
    und
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    N_{i,j} := \{X \in N \ | \ X \Step{}^* w[i:j]\} \ .
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Das ist also die Menge der Nichtterminale, die das Teilwort
    $w[i:j]$ ableiten können. Die "Hauptfrage" ist dann: enthält
    $N_{0,|w|}$ das Startsymbol
    <span class="nowrap">$S$?</span>
    Der CYK-Algorithmus berechnet nun
    die Mengen $N_{i, i+d}$ systematisch für
    <span class="nowrap">$d = 1, \dots, n$,</span>
    versucht also, alle Unterwörter der Länge $d$ abzuleiten,
    beginnend mit
    <span class="nowrap">$d = 1$,</span>
    also
    <span class="nowrap">$N_{i,i+1}$.</span>
    Diese Mengen sind leicht
    zu bestimmen:
  </p>
  <div class="math-block main-column">
    $$
    \begin{align}
    N_{i,i+1} := \{X \in N \ | \ X \step{} w_i \textnormal{ ist eine Produktion in $G$}\} \ .
    \label{Nii}
    \end{align}
    $$
  </div>
  <p class="main-column">
    Das gilt nur, weil $G$ in Chomsky-Normalform vorliegt und somit
    Ableitungen mit mehr als einem Schritt notwendigerweise Wörter mit
    mehr als einem Zeichen produzieren würden. Nun müssen wir uns
    Gedanken machen, wie wir $N_{i,k}$ berechnen, also das Unterwort
    <span class="nowrap">$w[i:k]$,</span>
    das Länge $k-i$ hat, ableiten, wenn wir bereits wissen,
    wie wir kürzere Unterwörter herleiten. Die Kernbeobachtung ist:
    <span class="nowrap">$X \in N_{i,k}$,</span>
    also $X \Step{}^* w[i:k]$ gilt genau dann, wenn
    es eine Produktion $X \rightarrow YZ$ gibt, so dass dann
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    Y&amp;\Step{}^* w[i:j] \\
    Z&amp;\Step{}^* w[j:k]
    \end{align*}
    $$
  </div>
  <p class="main-column">
    gilt. Das Problem ist, wie bereits oben skizziert, dass wir die
    "Grenze" $j$ nicht kennen. Wir probieren also alle Grenzen aus,
    und somit
  </p>
  <div class="math-block main-column">
    $$
    \begin{align}
    N_{i,k} = \bigcup_{j=i+1}^{k-1} \{X \in N \ | \ \textnormal{ es gibt $X \rightarrow YZ$ mit $Y
    \in N_{i,j}$ und $Z \in N_{j,k}$}\} \ .
    \label{equation-Nij}
    \end{align}
    $$
  </div>
  <p class="main-column">
    Dies können wir mit einer Schleife über $j = i+1 \dots k-1$ und
    einer Schleife über alle Produktionen $X \rightarrow YZ$
    berechnen, da wir die Mengen $N_{i,j}$ und $N_{j-k}$ ja bereits
    kennen, da
    <span class="nowrap">$k-j, j-i \lt k-i$,</span>
    diese Bereiche also kleinere
    Unterwörter darstellen.
  </p>
  <div class="main-column">
    <ul>
      <li>
        <p>
          Initialisiere für alle $0 \leq i \lt n$ die Mengen
          \(N_{i,i+1} := \{X \in N \ | \ X \step{} w_i \textnormal{
          ist eine Produktion in $G$}\}\)
        </p>
      </li>
      <li>
        <p>
          <code>for l = 2 .. n</code>
        </p>
        <ol type="I">
          <li>
            <p>
              <code>for i = 0 .. n-l</code>
            </p>
            <ol type="i">
              <li>
                <p>
                  <code>k := i+l</code>
                  <span class="comment"># wir betrachten das Interval w[i:k] der Länge l</span>
                </p>
              </li>
              <li>
                <p>
                  Berechne $N_{i,k}$ wie in
                  <span class="nowrap">$(\ref{equation-Nij})$.</span>
                  Konkret heißt das:
                </p>
              </li>
              <li>
                <p>
                  Initialisiere $N_{i,k} := \emptyset$
                </p>
              </li>
              <li>
                <p>
                  <code>for j = i+1 .. k-1:</code>
                </p>
                <ol type="1">
                  <li>
                    <p>
                      <code>for all productions</code>
                      <span class="nowrap">$X \rightarrow YZ$:</span>
                    </p>
                    <ol type="a">
                      <li>
                        <p>
                          füge $X$ zu $N_{i,k}$ hinzu, falls
                          $Y \in N_{i,j}$ und $Z \in N_{j,k}$ gilt.
                        </p>
                      </li>
                    </ol>
                  </li>
                  <li>
                    <p>
                      <code>end for all productions</code>
                    </p>
                  </li>
                </ol>
              </li>
              <li>
                <p>
                  <code>end for j</code>
                </p>
              </li>
            </ol>
          </li>
          <li>
            <p>
              <code>end for k</code>
            </p>
          </li>
        </ol>
      </li>
      <li>
        <p>
          <code>end for i</code>
        </p>
      </li>
      <li>
        <p>
          <code>return True if</code>
          $S \in N_{0,n}$
          <code>else return False</code>
        </p>
      </li>
    </ul>
  </div>
  <p class="main-column">
    Was ist die Laufzeit des Algorithmus? Sei $g$ die Anzahl der
    Produktionen in $G$ der Form
    <span class="nowrap">$X \rightarrow YZ$.</span>
    Die innerste
    Schleife, also Punkt a, wird jedes Mal $g$ mal durchlaufen, und
    somit wird Zeile a insgesamt
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \sum_{i=0}^{n-1}\sum_{k=i+2}^{n-1} \sum_{j = i+1}^{k-1} g
    \end{align*}
    $$
  </div>
  <p class="main-column">
    ausgeführt. Können Sie eine geschlossene Form für die drei Summen
    angeben? Leichter geht es, wenn wir erkennen, dass für alle $i,j,k$
    die Ungleichung $0 \leq i \lt j \lt k \leq n-1$ gilt, und jedes
    solche Tripel auch drankommt. Wie viele solche Tripel gibt es?
    Genau ${n \choose 3}$ viele. Also: die Zeile a wird
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    g \cdot {n \choose 3} = g \cdot \frac{n (n-1) (n-2)}{6}
    \end{align*}
    $$
  </div>
  <p class="main-column">
    mal durchlaufen. Also "ungefähr" $g n^3 / 6$ und "noch ungefährer"
    <span class="nowrap">$g n^3$.</span>
    Also:
  </p>
  <div class="well statement out">
    <p>
      <b>Beobachtung</b>
      <b>6.10.2</b>
      Sei $n = |w|$ die Länge des Eingabewortes und $g$ die Anzahl der
      Produktionen der Form
      <span class="nowrap">$X \rightarrow YZ$.</span>
      Dann ist die Laufzeit
      des CYK-Algorithmus proportional zu
      <span class="nowrap">$g \cdot n^3$.</span>
    </p>
  </div>
  <p class="main-column">
    <b>Achtung:</b>
    wir haben die Kosten für die allererste Zeile
    vernachlässigt. Überlegen Sie sich, wie viel Laufzeit diese
    verursachen kann und überzeugen Sie sich, dass dies in den meisten
    Fällen gegenüber dem Term $g \cdot n^3$ wohl nicht ins Gewicht
    fallen wird.
  </p>
  <div class="well statement out">
    <p>
      <b>Demo</b>
      <b>6.10.3</b>
      Betrachten wir die Grammatik
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      S&amp;\rightarrow AB \ | \ BC \ | \ AC \\
      A&amp;\rightarrow AC \ | \ x \ | \ z \\
      B&amp;\rightarrow AB \ | \ y \\
      C&amp;\rightarrow BC \ | \ AS \ | \ z
      \end{align*}
      $$
    </div>
    <p>
      und das Eingabewort
      <span class="nowrap">$xyxxz$.</span>
    </p>
    <div class="carousel__container">
      <div class="carousel">
        <div class="carousel__items">
          <div class="carousel__item">
            <img
              src="./img/context-free/CYK/01-01.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/01-02.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/01-03.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-01.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-02.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-03.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-04.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-05.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-06.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-07.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-08.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-09.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-10.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-11.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-12.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-13.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-14.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-15.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-16.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-17.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-18.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-19.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-20.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-21.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-22.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-23.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-24.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-25.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-26.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-27.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-28.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-29.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-30.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-31.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-32.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-33.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-34.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
          <div class="carousel__item">
            <img
              src="img/context-free/CYK/02-35.svg"
              class="constrained transition-all"
              onClick="onImgClick(event)"
            >
          </div>
        </div>
      </div>
    </div>
    <p>
      Wenn wir uns zusätzlich zu jedem $X \in N_{i,k}$ noch merken,
      durch welche Regeln $X \rightarrow YZ$ es aufgenommen wurde und
      für welches $j$ man $Y \in N_{i,j}, Z \in N_{j,k}$ hat, dann
      können wir den Ableitungsbaum leicht rekonstruieren.
    </p>
  </div>
</body>
</html>
