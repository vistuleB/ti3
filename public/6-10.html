<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 6.10 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 6, Section 10</title>
</head>
<body>
  <div class="body-wrapper">
    <div id="top-menu">
      <div class="top-menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./6-9.html"
        >&lt;&lt; Kapitel 6.9<span
            style="visibility:hidden"
            id="prev-page-tooltip"
          >Der DK-Automat</span></a>
      </div>
      <div class="top-menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./6-11.html"
        >Kapitel 6.11 &gt;&gt;<span
            style="visibility:hidden"
            id="next-page-tooltip"
          >Die Grenzen kontextfreier Sprachen</span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        6.10&ensp;Allgemeines Parsing
      </p>
    </div>
    <p class="main-column">
      Wir haben drei Methoden kennengelernt, kontextfreie Sprachen zu
      parsen: rekursiver Abstieg (mit Demoseite
      <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/demos/drawManualGrammar.html">drawManualGrammar.html</a>),
      die LL-Parser (die die Mengen $\First_k(X)$ berechnen, wie auf
      <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/demos/drawFirstComputation.html">drawFirstComputation.html</a>
      demonstriert), und die LR-Parser (die die Teilbäume auf den Stack
      legen und nach Blüten suchen, hier die Demoseite
      <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/demos/drawLR0ParserPrefixArithmetic.html">drawLR0ParserPrefixArithmetic</a>
      für arithmetische Ausdrücke). Rekursiver Abstieg kann, wenn man
      nicht vorsichtig ist, in Endlosschleifen landen und kann im
      Allgemeinen selbst bei einfachen Grammatiken exponentielle Laufzeit
      aufweisen. LL-Parser und LR-Parser funktionieren schlicht nicht für
      allgemeine kontextfreie Grammatiken. Standardbeispiel ist die
      Palindromsprache ohne Kennzeichnung der Mitte:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      S&amp;\rightarrow aSa \\
      S&amp;\rightarrow bSb \\
      S&amp;\rightarrow a \ | \ b \ | \ \epsilon
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Weder LL-Parser noch LR-Parser können bei langen Wörtern wie
      $aaaaaaaaaaaaaabbaaaaaaaaaaaaaa$ erkennen, wo die Mitte ist. Das
      muss man aber wissen, denn sonst landet man in einer Sackgasse. Es
      gilt sogar: jeder Kellerautomat für diese Sprache muss
      nichtdeterministisch sein (was wir an dieser Stelle weder formal
      definieren noch beweisen). Noch schlimmer steht es mit Grammatiken
      wie
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      S&amp;\rightarrow AY \ \ | XC \\
      A&amp;\rightarrow aA \ | \ \epsilon \\
      C&amp;\rightarrow cC \ | \ \epsilon \\
      X&amp;\rightarrow aXb \ | \epsilon \\
      Y&amp;\rightarrow bYc \ | \epsilon
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Diese erzeugt die Sprache
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      L = \{ a^i b^j c^k \ | \ i = j \textnormal{ oder } j = k \}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Die Grammatik ist
      <span class="nowrap"><i>mehrdeutig</i>,</span>
      insbesondere kann jedes Wort der
      Form $a^i b^i c^i$ auf zwei Weisen abgeleitet werden: via $AY$ und
      via
      <span class="nowrap">$XC$.</span>
      Man kann sogar zeigen, dass
      <i>jede</i>
      äquivalente Grammatik
      <span class="nowrap">$G'$,</span>
      die also die gleiche Sprache $L$ erzeugt, mehrdeutig sein
      muss; man sagt, die Sprache $L$ ist
      <span class="nowrap"><i>inhärent mehrdeutig</i>.</span>
      Für
      nichtdeterministische oder gar mehrdeutige Grammatiken / Sprachen
      sind LL- und LR-Parser unbrauchbar. Gibt es eine allgemeine
      Methode, die für alle Grammatiken funktioniert? Ja, den sogenannten
      CYK-Algorithmus. Nur leider ist die nicht besonders schnell. Sie
      hat kubische Laufzeit
      <span class="nowrap">$O(n^3)$,</span>
      was zwar in der theoretischen
      Informatik als
      <i>effizient</i>
      durchgeht, in der Praxis leider meist
      unbrauchbar ist.
    </p>
    <h2 class="main-column topic-announcement">
      Chomsky-Normalform
    </h2>
    <p class="main-column">
      Eine kontextfreie Grammatik ist in
      <span class="nowrap"><i>Chomsky-Normalform</i>,</span>
      wenn jede
      Produktion eine der folgenden Formen hat:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      X&amp;\rightarrow YZ \\
      X&amp;\rightarrow a
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Eine solche Sprache kann offensichtlich nicht das Wort $\epsilon$
      ableiten. Daher lassen wir als Sonderregel die Produktion
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      S&amp;\rightarrow \epsilon
      \end{align*}
      $$
    </div>
    <p class="main-column">
      zu, verbieten dann aber, dass das Startsymbol $S$ auf der rechten
      Seite einer Produktion vorkommen kann.
    </p>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>6.10.1</b>
        Zu jeder kontextfreien Grammatik gibt es eine äquivalente
        Grammatik in Chomsky-Normalform.
      </p>
    </div>
    <p class="main-column">
      Anstatt hier einen formalen Beweis anzugeben (den Sie sich, wenn
      Sie wollen, im Lehrbuch oder auf Wikipedia anschauen können), lasse
      ich Sie lieber anhand einer Übungsaufgabe die Konstruktion von
      selbst verstehen:
    </p>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 6.10.1</b>
        Finden Sie zu der folgenden kontextfreien Grammatik
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\rightarrow A \ | \ Bb \ | \ C \\
        A&amp;\rightarrow xyB \ | \ B \ | \ BC \\
        B&amp;\rightarrow yzC \ | \ AC \\
        C&amp;\rightarrow xzA \ | \ AB \ | \ \epsilon
        \end{align*}
        $$
      </div>
      <p>
        eine äquivalente in Chomsky-Normalform. Fragen, die Sie sich
        dabei stellen sollten:
      </p>
      <ol>
        <li>
          <p>
            Für welche Nichtterminale gibt es
            <span class="nowrap">$U \Step{}^* V$?</span>
            Zeichnen
            Sie ein Bildchen mit all diesen $\Step{}^*$ -Pfeilen.
          </p>
        </li>
        <li>
          <p>
            Von welchen Nichtterminalen können Sie überhaupt Wörter
            ableiten, also
            <span class="nowrap">$U \Step{}^* w \in \Sigma^*$?</span>
            Wie finden Sie
            das im Allgemeinen heraus?
          </p>
        </li>
        <li>
          <p>
            Welche Nichtterminale können $\epsilon$ ableiten, also
            <span class="nowrap">$U \Step{}^* \epsilon$?</span>
            Wie finden Sie das im Allgemeinen
            heraus?
          </p>
        </li>
      </ol>
    </div>
    <p class="main-column">
      Wenn nun $G$ in Chomsky-Normalform vorliegt und wir für ein
      gegebenes Eingabewort $w$ eine Ableitung $G: S \Step{}^* w$ finden
      wollen (oder feststellen, dass es keine gibt), so ist die erste
      Beobachtung, dass eine Linksableitung die Form
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      S&amp;\Step{}^* AB \Step{}^* uB \Step{}^* uv
      \end{align*}
      $$
    </div>
    <p class="main-column">
      haben muss, für
      <span class="nowrap">$w = uv$.</span>
      Wenn wir die Unterteilung von $w$ in $u$
      und $v$ kennen würden, so könnten wir rekursiv fragen, wie man
      denn $A \Step{}^* u$ und $B \Step{}^* v$ ableitet. Da wir sie aber
      <i>nicht</i>
      kennen, also konkret nicht wissen, wie lange $u$ und $v$
      sind, können wir alle Möglichkeiten durchprobieren. Da $G$ in
      Chomsky-Normalform vorliegt, wissen wir, dass $|u| \geq 1$ und
      <span class="nowrap">$|v| \geq 1$,</span>
      also
      <span class="nowrap">$1 \leq |u| \leq |w|-1$.</span>
      Wir probieren also
      alle $n-1$ möglichen Zerlegungen von $w$ durch. Wenn wir das
      rekursiv täten, dann würden das eine enorme Laufzeit verursachen.
      Der Trick besteht darin, Zwischenergebnisse systematisch zu
      berechnen, um somit Laufzeit zu sparen.
    </p>
    <h2 class="main-column topic-announcement">
      Der CYK-Algorithmus
    </h2>
    <p class="main-column">
      Die oben skizzierte Idee ist im CYK-Algorithmus konkretisiert
      (benannt nach John Cocke, Daniel Younger und Tadao Kasami). Für die
      praktische Anwendung ist dieser weniger relevant. Dafür ist er ein
      wunderbares Beispiel für einen Algorithmus, der auf dem Prinzip des
      <i>Dynamic Programing</i>
      fußt, welches Sie in der Vorlesung
      <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/AuK/index.html">Algorithmen und
        Komplexität</a>
      im dritten Semester ausführlicher kennenlernen wollen. Wir
      beschränken uns bei dem folgenden Algorithmus zunächst darauf, die
      Frage zu beantworten, ob den überhaupt $S \Step{}^* w$ gilt, und
      interessieren uns erst einmal nicht dafür eine solche Ableitung
      auch zu finden (in der Algorithmik versteht man das als
      <span class="nowrap"><i>Entscheidungsproblem</i>,</span>
      im Gegensatz zu dem allgemeinerin
      <span class="nowrap"><i>Suchproblem</i>).</span>
      Der Entwurf eines Dynamic-Programming-Algorithmus
      beginnt oft mit der folgenden Frage:
      <i>Was sind sinnvolle
        Zwischenergebnisse?</i>
      In unserem Falle sind Ableitungen der Form
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      X&amp;\Step{}^* u
      \end{align*}
      $$
    </div>
    <p class="main-column">
      sinnvolle Zwischenergebnisse, wenn $u$ ein Teilwort von $w$ ist,
      also
      <span class="nowrap">$w = v_1 u v_2$.</span>
      Konkret schreiben wir
      $w = w_0 w_1 \dots w_{n-1}$ und definieren
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      w[i:j] := w_i w_{i+1} \dots w_{j-1}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      und
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      N_{i,j} := \{X \in N \ | \ X \Step{}^* w[i:j]\} \ .
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Das ist also die Menge der Nichtterminale, die das Teilwort
      $w[i:j]$ ableiten können. Die "Hauptfrage" ist dann: enthält
      $N_{0,|w|}$ das Startsymbol
      <span class="nowrap">$S$?</span>
      Der CYK-Algorithmus berechnet nun
      die Mengen $N_{i, i+d}$ systematisch für
      <span class="nowrap">$d = 1, \dots, n$,</span>
      versucht also, alle Unterwörter der Länge $d$ abzuleiten,
      beginnend mit
      <span class="nowrap">$d = 1$,</span>
      also
      <span class="nowrap">$N_{i,i+1}$.</span>
      Diese Mengen sind leicht
      zu bestimmen:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align}
      N_{i,i+1} := \{X \in N \ | \ X \step{} w_i \textnormal{ ist eine Produktion in $G$}\} \ .
      \label{Nii}
      \end{align}
      $$
    </div>
    <p class="main-column">
      Das gilt nur, weil $G$ in Chomsky-Normalform vorliegt und somit
      Ableitungen mit mehr als einem Schritt notwendigerweise Wörter mit
      mehr als einem Zeichen produzieren würden. Nun müssen wir uns
      Gedanken machen, wie wir $N_{i,k}$ berechnen, also das Unterwort
      <span class="nowrap">$w[i:k]$,</span>
      das Länge $k-i$ hat, ableiten, wenn wir bereits wissen,
      wie wir kürzere Unterwörter herleiten. Die Kernbeobachtung ist:
      <span class="nowrap">$X \in N_{i,k}$,</span>
      also $X \Step{}^* w[i:k]$ gilt genau dann, wenn
      es eine Produktion $X \rightarrow YZ$ gibt, so dass dann
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      Y&amp;\Step{}^* w[i:j] \\
      Z&amp;\Step{}^* w[j:k]
      \end{align*}
      $$
    </div>
    <p class="main-column">
      gilt. Das Problem ist, wie bereits oben skizziert, dass wir die
      "Grenze" $j$ nicht kennen. Wir probieren also alle Grenzen aus,
      und somit
    </p>
    <div class="math-block main-column">
      $$
      \begin{align}
      N_{i,k} = \bigcup_{j=i+1}^{k-1} \{X \in N \ | \ \textnormal{ es gibt $X \rightarrow YZ$ mit $Y
      \in N_{i,j}$ und $Z \in N_{j,k}$}\} \ .
      \label{equation-Nij}
      \end{align}
      $$
    </div>
    <p class="main-column">
      Dies können wir mit einer Schleife über $j = i+1 \dots k-1$ und
      einer Schleife über alle Produktionen $X \rightarrow YZ$
      berechnen, da wir die Mengen $N_{i,j}$ und $N_{j-k}$ ja bereits
      kennen, da
      <span class="nowrap">$k-j, j-i \lt k-i$,</span>
      diese Bereiche also kleinere
      Unterwörter darstellen.
    </p>
    <div class="main-column">
      <ul>
        <li>
          <p>
            Initialisiere für alle $0 \leq i \lt n$ die Mengen
            \(N_{i,i+1} := \{X \in N \ | \ X \step{} w_i \textnormal{
            ist eine Produktion in $G$}\}\)
          </p>
        </li>
        <li>
          <p>
            <code>for l = 2 .. n</code>
          </p>
          <ol type="I">
            <li>
              <p>
                <code>for i = 0 .. n-l</code>
              </p>
              <ol type="i">
                <li>
                  <p>
                    <code>k := i+l</code>
                    <span class="comment"># wir betrachten das Interval w[i:k] der Länge l</span>
                  </p>
                </li>
                <li>
                  <p>
                    Berechne $N_{i,k}$ wie in
                    <span class="nowrap">$(\ref{equation-Nij})$.</span>
                    Konkret heißt das:
                  </p>
                </li>
                <li>
                  <p>
                    Initialisiere $N_{i,k} := \emptyset$
                  </p>
                </li>
                <li>
                  <p>
                    <code>for j = i+1 .. k-1:</code>
                  </p>
                  <ol type="1">
                    <li>
                      <p>
                        <code>for all productions</code>
                        <span class="nowrap">$X \rightarrow YZ$:</span>
                      </p>
                      <ol type="a">
                        <li>
                          <p>
                            füge $X$ zu $N_{i,k}$ hinzu, falls
                            $Y \in N_{i,j}$ und $Z \in N_{j,k}$ gilt.
                          </p>
                        </li>
                      </ol>
                    </li>
                    <li>
                      <p>
                        <code>end for all productions</code>
                      </p>
                    </li>
                  </ol>
                </li>
                <li>
                  <p>
                    <code>end for j</code>
                  </p>
                </li>
              </ol>
            </li>
            <li>
              <p>
                <code>end for k</code>
              </p>
            </li>
          </ol>
        </li>
        <li>
          <p>
            <code>end for i</code>
          </p>
        </li>
        <li>
          <p>
            <code>return True if</code>
            $S \in N_{0,n}$
            <code>else return False</code>
          </p>
        </li>
      </ul>
    </div>
    <p class="main-column">
      Was ist die Laufzeit des Algorithmus? Sei $g$ die Anzahl der
      Produktionen in $G$ der Form
      <span class="nowrap">$X \rightarrow YZ$.</span>
      Die innerste
      Schleife, also Punkt a, wird jedes Mal $g$ mal durchlaufen, und
      somit wird Zeile a insgesamt
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \sum_{i=0}^{n-1}\sum_{k=i+2}^{n-1} \sum_{j = i+1}^{k-1} g
      \end{align*}
      $$
    </div>
    <p class="main-column">
      ausgeführt. Können Sie eine geschlossene Form für die drei Summen
      angeben? Leichter geht es, wenn wir erkennen, dass für alle $i,j,k$
      die Ungleichung $0 \leq i \lt j \lt k \leq n-1$ gilt, und jedes
      solche Tripel auch drankommt. Wie viele solche Tripel gibt es?
      Genau ${n \choose 3}$ viele. Also: die Zeile a wird
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      g \cdot {n \choose 3} = g \cdot \frac{n (n-1) (n-2)}{6}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      mal durchlaufen. Also "ungefähr" $g n^3 / 6$ und "noch ungefährer"
      <span class="nowrap">$g n^3$.</span>
      Also:
    </p>
    <div class="well statement out">
      <p>
        <b>Beobachtung</b>
        <b>6.10.2</b>
        Sei $n = |w|$ die Länge des Eingabewortes und $g$ die Anzahl der
        Produktionen der Form
        <span class="nowrap">$X \rightarrow YZ$.</span>
        Dann ist die Laufzeit
        des CYK-Algorithmus proportional zu
        <span class="nowrap">$g \cdot n^3$.</span>
      </p>
    </div>
    <p class="main-column">
      <b>Achtung:</b>
      wir haben die Kosten für die allererste Zeile
      vernachlässigt. Überlegen Sie sich, wie viel Laufzeit diese
      verursachen kann und überzeugen Sie sich, dass dies in den meisten
      Fällen gegenüber dem Term $g \cdot n^3$ wohl nicht ins Gewicht
      fallen wird.
    </p>
    <div class="well statement out">
      <p>
        <b>Demo</b>
        <b>6.10.3</b>
        Betrachten wir die Grammatik
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\rightarrow AB \ | \ BC \ | \ AC \\
        A&amp;\rightarrow AC \ | \ x \ | \ z \\
        B&amp;\rightarrow AB \ | \ y \\
        C&amp;\rightarrow BC \ | \ AS \ | \ z
        \end{align*}
        $$
      </div>
      <p>
        und das Eingabewort
        <span class="nowrap">$xyxxz$.</span>
      </p>
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img src="./img/context-free/CYK/01-01.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/01-02.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/01-03.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-01.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-02.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-03.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-04.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-05.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-06.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-07.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-08.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-09.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-10.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-11.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-12.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-13.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-14.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-15.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-16.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-17.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-18.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-19.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-20.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-21.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-22.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-23.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-24.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-25.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-26.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-27.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-28.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-29.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-30.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-31.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-32.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-33.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-34.svg">
            </div>
            <div class="carousel__item">
              <img src="img/context-free/CYK/02-35.svg">
            </div>
          </div>
        </div>
      </div>
      <p>
        Wenn wir uns zusätzlich zu jedem $X \in N_{i,k}$ noch merken,
        durch welche Regeln $X \rightarrow YZ$ es aufgenommen wurde und
        für welches $j$ man $Y \in N_{i,j}, Z \in N_{j,k}$ hat, dann
        können wir den Ableitungsbaum leicht rekonstruieren.
      </p>
    </div>
    <div id="end-of-page-elt">
    </div>
    <div id="bottom-menu">
      <div class="bottom-menu-left">
        <a href="./6-9.html">&lt;&lt; Kapitel 6.9<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >Der DK-Automat</span></a>
      </div>
      <div class="bottom-menu-right">
        <a href="./6-11.html">Kapitel 6.11 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >Die Grenzen kontextfreier Sprachen</span></a>
      </div>
    </div>
  </div>
</body>
</html>
