<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 2.4 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="ti3.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./ti3.js"></script>
  <title>TI3 - Chapter 2, Section 4</title>
</head>
<body class="page-sub chapter-2 sub-4">
  <div
    id="_3_hgi_"
    path="./2-4.html"
    class="subchapter"
  >
    <div class="menu">
      <div class="menu-left">
        <a href="./index.html">Inhaltsverzeichnis</a><a
          href="./2-3.html"
          id="prev-page"
        >&lt;&lt; Kapitel 2.3</a>
      </div>
      <div class="menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          href="./2-5.html"
          id="next-page"
        >Kapitel 2.5  &gt;&gt;</a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        2.4 
        Monotone Funktionen und monotone Schaltkreise
      </p>
    </div>
    <p class="main-column">
      Für zwei Tupel
      $\mathbf{x}, \mathbf{y} \in \{0,1\}^n$ schreiben wir
      <span class="nowrap">$\mathbf{x} \leq \mathbf{y}$,</span>
      falls
      <span class="nowrap">$x_1 \leq y_1, \dots, x_n \leq y_n$,</span>
      also
      $\mathbf{x}$
      <i>in jeder Koordinate</i>
      kleiner gleich
      $\mathbf{y}$ ist. Beispielsweise gilt
      <span class="nowrap">$(0,0,1) \leq (1,0,1)$.</span>
      Allerdings gilt weder
      $(0,1,0) \leq (1,0,1)$ noch umgekehrt; die beiden
      Tupel sind
      <i>unvergleichbar</i>; es handelt sich bei
      $\leq$ also um eine
      <i>Partialordnung</i>. Am Besten stellen
      Sie sich eine solche Partialordnung als gerichteten
      Graphen vor:
    </p>
    <figure class="main-column">
      <img
        src="img/circuits/hasse-diagram.svg"
        style="height:10em"
        class="constrained transition-all"
        onClick="onImgClick(event)"
      >
    </figure>
    <p class="main-column">
      Diese Darstellung einer Partialordnung als gerichteter
      Graph bezeichnet man auch als
      <i>Hasse-Diagramm</i>
      (ich
      verzichte hier auf eine formale Definition). Es gilt
      nun
      <span class="nowrap">$\mathbf{x} \leq \mathbf{y}$,</span>
      wenn Sie im Hasse-Diagramm
      einen Pfad von $\mathbf{x}$ nach $\mathbf{y}$ finden.
      <b>Vorsicht.</b>
      Im obigen Bild steht zwar $001$ unterhalb
      von
      <span class="nowrap">$110$,</span>
      allerdings werden Sie keinen Pfad von
      $001$ nach $110$ finden; es gilt also
      <span class="nowrap">$001 \not \leq 110$;</span>
      die beiden Elemente sind
      <i>unvergleichbar</i>.
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>2.4.1</b>
        Eine Boolesche Funktion
        $f: \{0,1\}^n \rightarrow \{0,1\}$ heißt
        <i>monoton</i>,
        wenn
      </p>
      <div class="math-block">
        $$
        \forall \mathbf{x} \leq \mathbf{y} \in \{0,1\}^n \ : \
        f(\mathbf{x}) \leq f(\mathbf{y}) \ .
        $$
      </div>
      <p>
        In anderen Worten: wenn wir ein Input-Bit von 0 auf
        1 ändern, kann das Output-Bit nicht von 1 auf 0 umkippen.
      </p>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 2.4.1</b>
        Welche der Booleschen Funktionen
        $\wedge, \vee, \neg, \oplus, \maj$ sind monoton?
      </p>
    </div>
    <p class="main-column">
      Funktionen auf wenigen Variablen können wir graphisch
      darstellen und somit erkennen, ob sie monoton sind
      oder nicht. Für eine Funktion
      $f: \{0,1\}^2 \rightarrow \{0,1\}$ markieren wir im
      Hasse-Diagramm von $\{0,1\}^2$ diejenigen Elemente
      blau, auf denen $f(x,y) = 1$ ist, und die anderen
      rot.
    </p>
    <figure class="main-column">
      <img
        src="img/circuits/hasse-clouds.svg"
        style="height:10em"
        class="constrained transition-all"
        onClick="onImgClick(event)"
      >
    </figure>
    <p class="main-column">
      Wir sehen nun, dass es im Bild von $\wedge$ keinen
      roten Punkt gibt, der oberhalb eines blauen Punktes
      liegt, im Bild von $\oplus$ allerdings schon. Der
      Grund: $\wedge$ ist monoton, $\xor$ ist es nicht.
      Formaler argumentiert: in der Partialordnung gilt
      $01 \leq 11$ aber
      <span class="nowrap">$\xor (0,1) \gt \xor (1,0)$,</span>
      was
      der Definition einer monotonen Funktion widerspricht.
      (Ich habe hier absichtlich die Präfixschreibweise
      $\xor(0,1)$ verwendet, um hervorzuheben, dass es sich
      hierbei um eine Funktion in zwei Variablen handelt.)
      Beachten Sie, dass ich die Worte
      <i>"oberhalb"</i>
      im Sinne
      der Partialordnung meine, nicht wirklich im geometrischen
      Sinne in der Abbildung. Von den Basis-Gates
      $\wedge, \vee, \neg$ sind  $\wedge$ und $\vee$ monoton,
      $\neg$ ist es nicht. Es sollte also klar sein, dass
      ein Schaltkreis ohne Negation immer eine monotone Funktion
      berechnet. Allerdings stimmt der Umkehrschluss nicht.
      Der Schaltkreis
    </p>
    <figure class="main-column">
      <img
        src="img/circuits/monotone-or-not.svg"
        style="height:10em"
        class="constrained transition-all"
        onClick="onImgClick(event)"
      >
    </figure>
    <p class="main-column">
      ist nicht monoton (beachten Sie hinter der
      <span class="nowrap">$\bar{y}$-Schreibweise</span>
      versteckte NOT-Gate), ist aber
      äquivalent zu der offensichtlich monotonen Funktion
      <span class="nowrap">$x$.</span>
      Allerdings können wir folgendes beweisen:
    </p>
    <div
      id="_2_hgi_"
      class="well statement out"
    >
      <p>
        <b>Theorem</b>
        <b>2.4.2</b>
        Zu jeder monotonen Funktion
        $f: \{0,1\}^n \rightarrow \{0,1\}$ gibt es einen monotonen
        Schaltkreis (also ohne NOT-Gates), der $f$ berechnet.
      </p>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 2.4.2</b>
        Beweisen Sie das Theorem.
        <b>Tip.</b>
        Gehen Sie meine oben
        skizzierten drei Konstruktionen durch (Rekursiv, DNF,
        CNF) und versuchen Sie, sie so zu modifizieren, dass
        Sie alle NOT-Gates loswerden.
      </p>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 2.4.3</b>
        Finden Sie alle monotonen Funktionen in zwei Variablen.
        Wie sieht es mit allen monotonen Funktionen in
        <i>drei</i>
        Variablen aus? Am Besten betrachten Sie das
        <i>Hasse-Diagramm</i>
        der Partialordnungen auf Mengen $\{0,1\}^2$ bzw.
        <span class="nowrap">$\{0,1\}^3$:</span>
      </p>
      <figure>
        <img
          src="img/circuits/hasse-diagram.svg"
          style="height:10em"
          class="constrained transition-all"
          onClick="onImgClick(event)"
        >
      </figure>
      <p>
        und überlegen sich, wie Sie die vier bzw. acht Knoten
        auf monotone Weise in einen 1-Bereich und einen 0-Bereich
        aufteilen können.
      </p>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 2.4.4</b>
        <b>(Challenge).</b>
        Bauen Sie einen Schaltkreis mit drei
        Input-Variablen
        <span class="nowrap">$x,y,z$,</span>
        der drei Output-Gates hat,
        die $\bar{x}, \bar{y}, \bar{z}$ berechnen. Ihr Schaltkreis
        darf
        <i>höchstens zwei NOT-Gates</i>
        einhalten, aber beliebig
        viele AND- und OR-Gates.
      </p>
      <figure>
        <img
          src="img/circuits/triple-negator.svg"
          style="height:10em"
          class="constrained transition-all"
          onClick="onImgClick(event)"
        >
      </figure>
    </div>
    <h1 class="main-column">
      Lösungen zu den Übungsaufgaben
    </h1>
    <p class="main-column">
      Ich lege Ihnen sehr ans Herz, die obigen Übungsaufgaben
      selbständig zu bearbeiten. Falls Sie dennoch die Geduld
      verlieren, so habe ich hier Lösungen ausgearbeitet.
      Auch mit dem Zweck, an dieser Stelle auf Beweismethoden
      wie
      <i>Induktion</i>
      und verschiedene Beweisstrategien einzugehen.
    </p>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>2.4.3</b>
        Zu jeder monotonen Funktion
        $f: \{0,1\}^n \rightarrow \{0,1\}$ gibt es einen monotonen
        Schaltkreis (also ohne NOT-Gates), der $f$ berechnet.
      </p>
    </div>
    <p class="main-column">
      Ich werde zweieinhalb Beweise für dieses Theorem vorstellen.
      Dies dient auch dazu, gängige
      <i>Beweistechniken</i>
      und
      <i>Beweismethoden</i>
      zu illustrieren. Unter Beweismethoden
      verstehe ich hier formale Methoden wie
    </p>
    <div class="main-column">
      <ul>
        <li>
          <p>
            Beweis durch Induktion,
          </p>
        </li>
        <li>
          <p>
            Beweis durch Widerspruch,
          </p>
        </li>
        <li>
          <p>
            Beweis durch vollständige Fallunterscheidung,
          </p>
        </li>
        <li>
          <p>
            ...
          </p>
        </li>
      </ul>
    </div>
    <p class="main-column">
      wie sie zum Beispiel auf
      <a href="https://de.wikipedia.org/wiki/Beweis_(Mathematik)#Beweismethoden">Wikipedia</a>
      aufgeführt sind. Diesen zur Seite stehen die nicht
      wirklich formalisierbaren Beweistechniken oder Beweisstrategien,
      die sich oft aus persönlicher Erfahrung speisen, wie
      zum Beispiel
    </p>
    <div class="main-column">
      <ul>
        <li>
          <p>
            kleine Beispiele untersuchen und dann verallgemeinern,
          </p>
        </li>
        <li>
          <p>
            bereits Bekanntes abwandeln und hoffen, dass es funktioniert,
          </p>
        </li>
        <li>
          <p>
            local change: ein Objekt schrittweise in die gewünschte
            Richtung verändern;
          </p>
        </li>
      </ul>
    </div>
    <p class="main-column">
      da bei den Beweistechniken Erfahrung, Intuition und
      Kreativität mit ins Spiel kommen, ist es unmöglich,
      eine vollständige Liste anzugeben; ich habe die drei
      obigen Punkte gewählt, weil sie in der Tat das repräsentieren,
      was wir in den Beweisen jetzt verwenden werden.
    </p>
    <div class="well highlight out">
      <p>
        <b>Erster Beweis. Top-Down mit
          <code>if-then-else</code>.</b>
        In diesem
        Beweis verwende ich die zweite oben erwähnte Technik:
        bereits bekanntes abwandeln. Was kennen wir denn bereits?
        Wir kennen die
        <a href="index.html#truth-table-top-down">Top-Down-Methode</a>,
        wie wir aus einer Wahrheitstabelle einen Schaltkreis
        bauen:
      </p>
      <div class="well statement">
        <p>
          <b>Theorem</b>
          <b>2.4.4</b>
          Zu jeder Booleschen Funktion
          $f: \{0,1\}^n \rightarrow \{0,1\}$ gibt es einen Schaltkreis
          <span class="nowrap">$C$,</span>
          der $f$ berechnet.
        </p>
      </div>
      <p>
        Wir haben diese Konstruktion in der Vorlesung an einem
        Beispiel durchexerziert und auch Größe und Tiefe des
        resultierenden Schaltkreises analysiert, allerdings
        haben wir den Beweis nicht formal aufgeschrieben. Nutzen
        wir hier die Gelegennheit und üben an diesem Beispiel
        das Finden und Führen mathematischer Beweise. Beachten
        Sie, dass wir nun vorerst über allgemeine, nicht notwendigerweise
        monotone Boolesche Funktionen reden. Falls Sie sich
        noch gut an unseren Beweis von Theorem 2 in der Vorlesung
        erinnern können und eher an Theorem 1 als an allgemeinen
        Beweismethoden interessiert sind, dürfen Sie gerne
        <a href="#after-sub-proof">runterspringen</a>.
      </p>
      <div class="well highlight">
        <p>
          <b>Beweis.</b>
          Als
          <i>Beweismethode</i>
          verwenden wir Induktion über
          <span class="nowrap">$n$,</span>
          die Anzahl der Variablen.
        </p>
        <div class="well alert-info">
          <p>
            Zur Erinnerung: bei einem Beweis per Induktion wollen
            wir eine Aussage der Form _Für alle natürlichen Zahlen
            $n \in \N$ gilt
            <span class="nowrap">$P(n)$_</span>
            beweisen, wobei $P(n)$ wiederum
            eine Aussage ist, in der die Zahl $n$ irgendwo vorkommt.
            Bei einem Beweis durch Induktion zeigen wir nun,
          </p>
          <ol>
            <li>
              <p>
                dass $P(0)$ gilt (<b>Induktionsbasis</b>),
              </p>
            </li>
            <li>
              <p>
                dass, wenn $P(n)$ für eine Zahl $n \in \N$ gilt, dann
                sicherlich auch $P(n+1)$ gilt (<b>Induktionsschritt</b>).
              </p>
            </li>
          </ol>
          <p>
            Wenn wir beide Teile gezeigt haben, können wir uns
            nun "hochhangeln": $P(0)$ gilt, weil wir in Punkt
            1 gezeigt haben; mit Hilfe von Punkt 2 können wir nun
            argumentieren, dass aus $P(0)$ die Aussage $P(1)$
            folgt; dass aus $P(1)$ die Aussage $P(2)$ folgt; und
            so weiter. Da wir auf diese Weise jede natürliche Zahl
            irgendwann erreichen, können wir schlussfolgern, dass
            $P(n)$ für jede Zahl $n \in \Z$ gilt.
          </p>
        </div>
        <p>
          Als erstes müssen wir nun unsere Aussage, die wir
          beweisen wollen (also die im Theorem) so formulieren,
          dass sie die Form
          <span class="nowrap">_$P(n)$</span>
          für alle
          <span class="nowrap">$n \in \N$_</span>
          annimmt.
          Dies ist einfach, da die Zahl $n$ bereits im Theorem
          vorkommt. Wir formulieren sie also nun so um:
        </p>
        <div class="well statement">
          <p>
            <b>(Theorem 1.4.4, alternative Formulierung)</b>
            <b>2.4.5</b>
            Für jede natürliche Zahl $n$ gilt: zu jeder Booleschen
            Funktion $f: \{0,1\}^n \rightarrow \{0,1\}$ gibt es
            einen Schaltkreis
            <span class="nowrap">$C$,</span>
            der $f$ berechnet.
          </p>
        </div>
        <p>
          Wir haben also im Prinzip Theorem 1.4.4 umständlicher
          formuliert, um die Abhängigkeit von $n$ zu verdeutlichen.
          Wir müssen nun Induktionsbasis und Induktionsschritt
          durchführen.
        </p>
        <p>
          <b>Induktionsbasis.</b>
          Wenn $n=0$ ist, dann gibt es nur
          zwei mögliche Boolesche Funktionen, nämlich die konstanten
          Funktionen $0$ und
          <span class="nowrap">$1$.</span>
          Für beide Funktionen gibt
          es einen Schaltkreis, nämlich bestehend aus einem Input-Gate
          (mit der Konstant 0 bzw. 1 beschriftet), das gleichzeitig
          auch Output-Gate ist.
        </p>
        <div class="well alert-warning">
          <p>
            Vielleicht fühlen Sie sich unwohl bei der Idee, es
            mit Funktionen mit null Variablen tun zu haben. Allerdings:
            warum? In Java hätten Sie bestimmt kein Problem mit
          </p>
<pre class="listing">
<span class="listing-bol"></span>public boolean constantFalse() {
<span class="listing-bol"></span>    return false;
<span class="listing-bol"></span>}
<span class="listing-bol"></span>public boolean constantTrue() {
<span class="listing-bol"></span>    return true;
<span class="listing-bol"></span>}
</pre>
          <p>
            und dies sind ja offensichtlich Boolesche Funktionen
            mit null Input-Variablen. Ich nehme Ihre Ängste aber
            ernst, und in der Tat gibt es Fälle, wo es sich nicht
            richtig anfühlt, den Induktionsbeweis bei $0$ anzufangen.
            In diesem Fall dürfen Sie die Induktionsbasis gerne
            bei $n=1$ ansetzen oder wo auch immer Sie sich "wohlfühlen";
            sie müssen dann aber im Hinterkopf behalten, dass Sie
            Ihre Aussage für $n=0$ nicht bewiesen haben; machnmal
            ist das unvermeidbar, weil manche Aussagen einfach
            z.B. erst ab $n \geq 2$ gelten. Wenn wir die Induktionsbasis
            bei $n=1$ ansetzen wollen, dann sehen wir, dass es
            <i>vier</i>
            Funktionen gibt:
            <span class="nowrap">$0, 1, x, \neg x$;</span>
            all diese
            haben natürlich einen (sehr einfachen) Schaltkreis.
            Nur bei $\neg x$ braucht unser Schaltkreis überhaupt
            ein Gate. An diesem Punkt protestieren Sie vielleicht
            und sagen, dass $0$ keine Funktion in
            <i>einer</i>
            Variable
            ist, sondern in
            <i>zwei</i>
            Variablen. Und auch hier appelliere
            ich an Ihre Programmiererfahrung: weder Sie noch der
            Java-Compiler werden Probleme mit der Funktion
          </p>
<pre class="listing">
<span class="listing-bol"></span>public boolean constantFalse(boolean x) {
<span class="listing-bol"></span>    return false;
<span class="listing-bol"></span>}
</pre>
          <p>
            haben. Ja in der Tat, Java toleriert es, dass Sie
            <code>constantFalse</code>
            zweimal deklariert haben, einmal als
            Funktion mit 0 Input-Variablen, einmal als Funktion
            mit einer Input-Variablen. Um hundertprozentig korrekt
            zu sein, müssten wir Funktionen
            $\textnormal{zero}_n$ definieren als
          </p>
          <div class="math-block">
            $$
            \begin{align*}
            \textnormal{zero}_n&amp;: \{0,1\}^n \rightarrow \{0,1\} \\
            (x_1,\dots,x_n)&amp;\mapsto 0 \ .
            \end{align*}
            $$
          </div>
          <p>
            In der Praxis gehen wir in der Mathematik deutlich
            laxer mit Notation um und hoffen, dass der Leser aus
            dem Kontext die richtige Interpretation herausliest:
            ob $0$ nun eine Konstante ist, eine Funktion mit einer
            Input-Variablen, mit zwei Input-Variablen etc. In mathematischen
            Papern lesen Sie in diesem Kontext manchmal
            <a href="https://en.wikipedia.org/wiki/Abuse_of_notation"><i>with
                abuse of notation</i></a>,
            womit die Autoren andeuten, dass sie ihre Notation
            nicht ganz korrekt anwenden, aber davon ausgehen, dass
            Leser oder Leserin (die ja Menschen sind und keine
            Compiler), verstehen, was gemeint ist.
          </p>
        </div>
        <p>
          Wir haben nun also die Induktionsbasis erfolgreich
          gezeigt. Als nächstes kommt nun der Schritt. In diesem
          nehmen wir an, dass die Aussage $P(n)$ bereits gilt,
          und wollen davon ausgehend zeigen, dass auch
          $P(n+1)$ gilt. Alternativ können wir annehmen, dass
          $P(n-1)$ gilt und wollen $P(n)$ zeigen (wobei wir
          nun $n \geq 1$ annehmen müssen). Ob Sie
          $P(n) \Rightarrow P(n+1)$ oder
          $P(n-1) \Rightarrow P(n)$ zeigen, kommt aufs Gleiche
          raus und unterscheidet sich nur in der Notation; in
          diesem Falle ist es mir angenehmer,
          $P(n-1) \Rightarrow P(n)$ zu zeigen. Wir dürfen also
          die
          <i>Induktionshypothese</i>
          $P(n-1)$ als gegeben annehmen:
        </p>
        <div class="well remark">
          <p>
            <b>Induktionshypothese.</b>
            Zu jeder Booleschen Funktion in $n-1$ Variablen gibt
            es einen äquivalenten Schaltkreis.
          </p>
        </div>
        <p>
          und wollen den Induktionsschritt vollziehen, also
          $P(n)$ zeigen:
        </p>
        <div class="well remark">
          <p>
            <b>Ziel des Induktionsschritts.</b>
            Zu jeder Booleschen Funktion in $n$ Variablen gibt
            es einen äquivalenten Schaltkreis.
          </p>
        </div>
        <p>
          <b>Beweistechnik/-strategie</b>. Um den Induktionsschritt
          vollziehen zu können, müssen wir irgendwie die
          <span class="nowrap">$n$-stellige</span>
          Funktion $f$ auf sinnvolle Weise in
          <span class="nowrap">$n-1$-stellige</span>
          Funktionen "zerlegen". Hier ist im Allgemeinen Kreativität
          gefragt. Im vorliegenden Falle ist es aber recht klar,
          welche Zerlegung in Frage kommt. Wir definieren zwei
          neue, "kleinere" Funktionen
          $f_0, f_1: \{0,1\}^{n-1} \rightarrow \{0,1\}$ per
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          f_0 (x_2, \dots, x_n)&amp;:= f(0, x_2, \dots, x_n) \\
          f_1 (x_2, \dots, x_n)&amp;:= f(1, x_2, \dots, x_n) \ .
          \end{align*}
          $$
        </div>
        <p>
          In anderen Worten, wir fixieren das erste Input-Bit
          auf einen konstanten Wert und erhalten so eine Funktion
          in $n-1$ Variablen. Die Funktion $f_0$ ist im Prinzip
          die obere Hälfte der Wahrheitstabelle, und $f_1$ ist
          die untere Hälfte. Da $f_0$ und $f_1$ jeweils nur
          $n-1$ Input-Variablen haben, können wir die Induktionshypothese
          anwenden und folgern, dass es Boolesche Schaltkreise
          für sie gibt. Nach
          <i>Zerlegen in
            <span class="nowrap">$f_0, f_1$_</span>
            und</i>Anwenden
          der Induktionshypothese_ müssen wir nun die Teilergebnisse
          wieder
          <i>sinnvoll zusammenfügen</i>. Dies tun wir in diesem
          Falle mit einem
          <code>if-then-else</code>-Gate:
        </p>
        <figure>
          <img
            src="img/circuits/top-down-if-then-else.svg"
            style="height:15em"
            class="constrained transition-all"
            onClick="onImgClick(event)"
          >
        </figure>
        <p>
          Ich behaupte, dass obiger Schaltkreis tatsächlich
          $f$ berechnet. Falls dies noch nicht klar sein sollte,
          können wir auch dies formal beweisen, und zwar durch
          die Methode
          <i>vollständige Fallunterscheidung.</i>
          Sei
          nun also ein konkreter Input $x_1,\dots,x_n$ gegeben.
        </p>
        <ul>
          <li>
            <p>
              Der Fall
              <span class="nowrap">$x_1 = 1$.</span>
              Dann gibt der obige Schaltkreis
              den Wert $f_1(x_2,\dots,x_n$ aus, was per Definition
              von $f_1$ gleich
              $f(1, x_2,\dots,x_n) = f(x_1,\dots,x_n)$ ist. Er gibt
              also den korrekten Wert aus.
            </p>
          </li>
          <li>
            <p>
              Der Fall
              <span class="nowrap">$x_1 = 0$.</span>
              Dann gibt der obige Schaltkreis
              den Wert $f_0(x_2,\dots,x_n$ aus, was per Definition
              von $f_0$ gleich
              $f(0, x_2,\dots,x_n) = f(x_1,\dots,x_n)$ ist. Er gibt
              also auch hier den korrekten Wert aus.
            </p>
          </li>
        </ul>
        <p>
          Wir haben also erfolgreich einen Schaltkreis für
          $f: \{0,1\}^n \rightarrow \{0,1\}$ konstruiert. Unser
          Induktionsbeweis von Theorem 2 ist nun abgeschlossen.
          <span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
        </p>
      </div>
    </div>
    <p class="main-column">
      <span id="after-sub-proof"></span>Diesen "hellblauen" Beweis haben wir ja bereits in
      der Vorlesung geführt. Ich habe ihn hier wiederholt
      und in größerem Detail besprochen, um auf verschiedene
      formale Aspekte der Beweisführung einzugehen. Wenden
      wir uns jetzt dem Beweis von
      <a
        href="./2-4.html#_2_hgi_"
        class=""
      >Theorem 2.4.2</a>
      zu.
    </p>
    <div class="well highlight out">
      <p>
        <b>
          <a
            href="./2-4.html#_2_hgi_"
            class=""
          >Theorem 2.4.2</a>, nochmals.</b>
        Zu jeder monotonen Funktion
        $f: \{0,1\}^n \rightarrow \{0,1\}$ gibt es einen monotonen
        Schaltkreis (also ohne NOT-Gates), der $f$ berechnet.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Erster Beweis. Top-Down mit
          <code>if-then-else</code>.</b>
        Wir
        verfolgen die Beweistechnik "Bekanntes abwandeln und
        hoffen". Das Bekannte ist die Konstruktion im Beweis
        von Theorem 1, also die top-down-Konstruktion. Wir
        gehen wieder induktiv vor (allerdings bin ich jetzt
        weniger formal und weise Sie nicht mehr ständig auf
        die Bestandteile eines Induktionsbeweises hin) und
        zerlegen $f: \{0,1\}^n \rightarrow \{0,1\}$ in zwei
        neue, "kleinere" Funktionen
        $f_0, f_1: \{0,1\}^{n-1} \rightarrow \{0,1\}$ per
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        f_0 (x_2, \dots, x_n)&amp;:= f(0, x_2, \dots, x_n) \\
        f_1 (x_2, \dots, x_n)&amp;:= f(1, x_2, \dots, x_n) \ .
        \end{align*}
        $$
      </div>
      <p>
        Diese Funktionen sind selbst wiederum monoton (versuchen
        Sie, dies formal zu zeigen, wenn Sie Lust haben; oder
        versuchen Sie, es sich intuitiv klar zu machen). Per
        Induktionshypothese gibt es also monotone Schaltkreise
        für $f_0$ und
        <span class="nowrap">$f_1$.</span>
        Wir kombinieren diese mit einem
        <code>if-then-else</code>-Gate und erhalten:
      </p>
      <figure>
        <img
          src="img/circuits/top-down-if-then-else-2.svg"
          style="height:15em"
          class="constrained transition-all"
          onClick="onImgClick(event)"
        >
      </figure>
      <p>
        Die "durchgetrichenen" Kabel bedeuten, dass hier mehrere
        Kabel parallel laufen (also hier $n-1$ viele). Erkennen
        Sie das Problem mit der Konstruktion? Klar: das
        <code>if-then-else</code>-Gate
        ist nicht monoton. Unser Schaltkreis schaut also in
        Wirklichkeit so aus:
      </p>
      <figure>
        <img
          src="img/circuits/top-down-if-then-else-3.svg"
          style="height:18em"
          class="constrained transition-all"
          onClick="onImgClick(event)"
        >
      </figure>
      <p>
        und enthält ein NOT-Gate. Aber klar: wir können natürlich
        nicht die Konstruktion aus dem vorherigen Beweis wiederholen
        und hoffen, dass alles klappt. Die Beweistechnik heißt
        ja auch
        <i>Bekanntes abwandeln</i>, nicht
        <i>Bekanntes kritiklos
          wiederholen</i>. Wie können wir den obigen Schaltkreis
        abwandeln, dass er monoton wird, also das eine NOT-Gate
        entfernen? Spontan fallen mir zwei Wege ein: wir können
        das NOT-Gate einfach durch ein gate-loses Kabel ersetzen
        oder das Kabel einfach ganz weglassen, also:
      </p>
      <figure>
        <img
          src="img/circuits/top-down-if-then-else-4.svg"
          style="height:18em"
          class="constrained transition-all"
          onClick="onImgClick(event)"
        >
      </figure>
      <p>
        Der linke Schaltkreis gibt uns, als Formel geschrieben,
      </p>
      <div class="math-block">
        $$
        (x \wedge f_1) \vee (x \wedge f_0) \equiv x \wedge (f_1 \vee f_0) \ .
        $$
      </div>
      <p>
        Ich erlaube mir hier, aus Bequemlichkeit einfach
        $f_1$ statt $f_1(x_2,\dots,x_n)$ zu schreiben. Auch
        ein
        <i>abuse of notation</i>. In der obigen Formel habe
        ich rechts das $x$ ausgeklammert; die Formel beginnt
        nun mit
        <span class="nowrap">$x \wedge ...$;</span>
        falls $x=0$ ist, gibt sie
        also auf jeden Fall $0$ aus; das kann im Allgemeinen
        nicht korrekt (also äquivalent zu $f$ sein; warum
        sollte $f$ automatisch $0$ sein, nur weil $x_1=0$
        ist? Wir schließen also: das NOT-Gate durch ein gate-loses
        Kabel zu ersetzen ist im Allgemeinen nicht korrekt.
        Schauen wir uns also den Schaltkreis im zweiten Bild
        an. Das rechte
        <span class="nowrap">$\wedge$-Gate</span>
        hat nur einen Input,
        kann also weggelassen werden (d.h. durch ein Kabel
        ersetzt werden); wir erhalten den monotonen Schaltkreis
      </p>
      <figure>
        <img
          src="img/circuits/top-down-if-then-else-monotone.svg"
          style="height:18em"
          class="constrained transition-all"
          onClick="onImgClick(event)"
        >
      </figure>
      <p>
        bzw. als Formel:
      </p>
      <div class="math-block">
        $$
        (x_1 \wedge f_1) \vee f_0 \ .
        $$
      </div>
      <p>
        Wir müssen nun zeigen, dass dies wirklich $f$ berechnet,
        also
      </p>
      <div class="well statement">
        <p>
          <b>Behauptung</b>
          <b>2.4.6</b>
          Für alle $x_1,\dots,x_n$ gilt
          $f(x_1,\dots,x_n) = (x_1 \wedge f_1(x_2,\dots,x_n))
          \vee f_0(x_2,\dots,x_n) \ .$
        </p>
      </div>
      <div class="well remark">
        <p>
          <b>Beweis.</b>
          Wir machen eine Fallunterscheidung nach dem Wert von
          <span class="nowrap">$x_1$.</span>
        </p>
        <ul>
          <li>
            <p>
              Der Fall
              <span class="nowrap">$x_1 = 0$.</span>
              Dann gilt
            </p>
            <div class="math-block">
              $$
              \begin{align*}
              f(x_1,x_2,\dots,x_n)&amp;= f(0,x_2,\dots,x_n) \tag{da $x_1=0$} \\
              &amp;= f_0 (x_2, \dots,x_n) \tag{Definition von $f_2$} \\
              &amp;= (0 \wedge f_1) \vee f_0 \tag{die 0 tötet den ersten Term eh}\\
              &amp;= (x_1 \wedge f_1) \vee f_0 \tag{weil $x_1 = 0$} \ ,
              \end{align*}
              $$
            </div>
            <p>
              und die behauptete Gleichung gilt.
            </p>
          </li>
          <li>
            <p>
              Der Fall
              <span class="nowrap">$x_1 = 1$.</span>
              Dann gilt
            </p>
            <div class="math-block">
              $$
              \begin{align*}
              f(x_1,\dots,x_n)&amp;= f_1(x_2,\dots,x_n) \ .
              \end{align*}
              $$
            </div>
            <p>
              Was ist aber mit der rechten Seite der behaupteten
              Gleichung?
            </p>
            <div class="math-block">
              $$
              \begin{align*}
              (x_1 \wedge f_1) \vee f_0&amp;= f_1 \vee f_0 \tag{da $x_1=1$ ist und somit im $\wedge$
              wegfällt}
              \end{align*}
              $$
            </div>
            <p>
              Die linke Seite ist also
              <span class="nowrap">$f_1$,</span>
              die rechte ist
              <span class="nowrap">$f_1 \vee f_0$.</span>
              Schaut leider nicht gleich aus. Jetzt
              sollten bei Ihnen die Glocken klingeln: wir haben bisher
              an keiner Stelle im Beweis verwendet, dass $f$ eine
              monotone Funktion ist! Und wenn wir das nicht verwendet
              haben, kann der Beweis ja gar nicht funktionieren.
              Also: verwenden wir Monotonität:
            </p>
            <div class="math-block">
              $$
              \begin{align*}
              (0, x_2, \dots,x_n)&amp;\leq (1, x_2, \dots,x_n) \tag{Definition unser Partialordnung,
              } \\
              f(0, x_2, \dots,x_n)&amp;\leq f(1, x_2, \dots,x_n) \tag{weil $f$ monoton ist.} \\
              f_0&amp;\leq f_1 \ .
              \end{align*}
              $$
            </div>
            <p>
              Wir überprüfen nun also: wenn
              $f_0(x_2, \dots, x_n) = 0$ ist, dann gilt
              <span class="nowrap">$f_0 \vee f_1 = 0 \vee f_1 = f_1$.</span>
              Wenn $f_0 = 1$
              ist, dann ist $f_1 = 1$ wegen Monotonität (größer
              als 1 geht ja nicht), und daher
              <span class="nowrap">$f_0 \vee f_1 = 1 \vee 1 = 1 = f_1$.</span>
              In jedem Fall
              gilt also:
            </p>
            <div class="math-block">
              $$
              (f_0 \vee f_1) = f_1 \ .
              $$
            </div>
            <p>
              Und somit sind linke und rechte Seite gleich, wie
              behauptet.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
            </p>
          </li>
        </ul>
      </div>
      <p>
        Wir haben nun also gezeigt, dass für jeden Input
        $x_1,\dots,x_n$ gilt:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        f = (x_1 \wedge f_1) \vee f_0 \ ,
        \end{align*}
        $$
      </div>
      <p>
        (wobei wir aus Gründen der Lesbarkeit statt
        $f(x_1,\dots,x_n)$ einfach $f$ schreiben); per Induktion
        können wir für $f_1, f_0$ monotone Schaltkreise finden,
        und somit ist
      </p>
      <figure>
        <img
          src="img/circuits/top-down-if-then-else-monotone-finished.svg"
          style="height:18em"
          class="constrained transition-all"
          onClick="onImgClick(event)"
        >
      </figure>
      <p>
        ein monotoner Schaltkreis für
        <span class="nowrap">$f$.</span><span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Zweiter Beweis. Bottom-Up, Konstruktion einer DNF-Formel.</b>
        Als Beweisstrategie verwende ich wieder
        <i>Bekanntes
          abwandeln.</i>
      </p>
      <p>
        <b>Das Bekannte.</b>
        Erinnern Sie sich an die Konstruktion
        einer DNF-Formel auf Basis der gegebenen Wahrheitstabelle.
        Für jedes
        <span class="nowrap">$n$-Tupel</span>
        <span class="nowrap">$\mathbf{a} := a_1,\dots,a_n) \in \{0,1\}^n$,</span>
        für
        welches $f$ den Wert 1 ausgibt, konstruieren wir einen
        DNF-Term
        <span class="nowrap">$T_{\mathbf{a}}$,</span>
        der auf $\mathbf{a}$ eine
        1 ausgibt und sonst überall eine 0. Um den Term genau
        zu beschreiben, definieren wir
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        I_{\mathbf{a}}&amp;:= \{ i \in \{1,\dots, n\} \ | \ a_i = 1 \} \\
        O_{\mathbf{a}}&amp;:= \{ i \in \{1,\dots, n\} \ | \ a_i = 0 \} \ .
        \end{align*}
        $$
      </div>
      <p>
        Als Beispiel: wenn $n=5$ und
        <span class="nowrap">$\mathbf{a} = (10010)$,</span>
        dann ist
        $I_{\mathbf{a}} = \{1,4\}$ und
        <span class="nowrap">$I_{\mathbf{a}} = \{2,3,5\}$.</span>
        Wir definieren
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        T_{\mathbf{a}}&amp;:= \bigwedge_{i \in I_{\mathbf{a}}} x_i \wedge
        \bigwedge_{i \in O_{\mathbf{a}}} \bar{x}_i \ .
        \end{align*}
        $$
      </div>
      <p>
        Für $\mathbf{a} = (10010)$ gibt das also
        <span class="nowrap">$x_1 \wedge x_4 \wedge \bar{x}_2 \wedge \bar{x}_3
          \wedge \bar{x}_5$.</span>
        Noch kompakter kann man es hinschreiben, wenn man für
        eine Variable $x$ und einen Wert $b \in \{0,1\}$ folgendes
        definiert:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        x^{b}&amp;:= \begin{cases}
        x&amp;\textnormal{ if $b=1$,}\\
        \bar{x}&amp;\textnormal{ if $b=0$.}
        \end{cases}
        \end{align*}
        $$
      </div>
      <p>
        Dann können wir $T_{\mathbf{a}}$ einfach als
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        T_{\mathbf{a}} = \bigwedge_{i=1}^n x_i^{a_i}
        \end{align*}
        $$
      </div>
      <p>
        definieren, für $\mathbf{a} = (10010)$ also
        <span class="nowrap">$x_1^1 \wedge x_2^0 \wedge x_3^0 \wedge x_4^1 \wedge
          x_5^0 = x_1 \wedge \bar{x}_2 \wedge \bar{x}_3 \wedge
          x_4 \wedge \bar{x}_5$.</span>
        Das gibt den gleichen Term wie zuvor, nur mit den Literalen
        in anderer Reihenfolge aufgelistet (was keine Rolle
        spielt, da $\wedge$ kommutativ ist). Gegen eine Boolesche
        Funktion
        <span class="nowrap">$f: \{0,1\}^n \rightarrow \{0,1\}$,</span>
        definieren
        wir
      </p>
      <div class="math-block">
        $$
        \sat(f) := \{\mathbf{a} \in \{0,1\}^n \ | \ f(\mathbf{a}) = 1 \} \ .
        $$
      </div>
      <p>
        Die Abkürzung $\sat$ steht für
        <i>satisfying assignments</i>,
        also diejenigen Belegungen der Variablen, die $f$
        "erfüllen", also 1 werden lassen. Wir bauen uns einen
        Schaltkreis
        <span class="nowrap">$F$:</span>
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        F := \bigvee_{\mathbf{a} \in \sat(f)} T_{\mathbf{a}}
        \end{align*}
        $$
      </div>
      <p>
        Dies ist eine DNF-Formel, also insbesondere ein Schaltkreis
        der Tiefe 2; wir sehen, dass $F \equiv f$ ist, dieser
        Schaltkreis (diese Formel) also die Funktion $f$ berechnet.
        Dies ist genau die Konstruktion einer DNF, die wir
        in der Vorlesung bereits besprochen haben.
        <b>Das Bekannte
          abwandeln.</b>
        Der Ausdruck
        $\bigvee_{\mathbf{a} \in \sat(f)} T_{\mathbf{a}}$
        ist ja bereits ein Schaltkreis (der Tiefe 2), allerdings
        im Allgemeinen kein monotoner, da die Terme
        $T_{\mathbf{a}}$ negative Literale (und somit NOT-Gates)
        enthalten können. Wie werden wir diese los? Sie erinnern
        sich, was wir im letzten Beweis getan haben: die NOT-Gates
        einfach weglassen und die ausgehenden Kabel ersatzlos
        streichen. Hier hieße das nun, aus dem Term
        $x_1 \wedge \bar{x}_2 \wedge \bar{x}_3 \wedge x_4
        \wedge \bar{x}_5$
        den Term $x_1 \wedge x_4$ zu machen. Wir definieren
        also:
      </p>
      <div class="math-block">
        $$
        T'_{\mathbf{a}} := \bigwedge_{i \in I_{\mathbf{a}}} x_i \ .
        $$
      </div>
      <p>
        Der Term $T'_{\mathbf{a}}$ ist "kürzer" als
        <span class="nowrap">$T_{\mathbf{a}}$,</span>
        stellt also weniger "Bedingungen".
        Formal gesprochen:
      </p>
      <div class="well statement">
        <p>
          <b>Behauptung</b>
          <b>2.4.7</b>
          Für alle $x_1,\dots,x_n$ gilt
          <span class="nowrap">$T_{\mathbf{a}} \leq T'_{\mathbf{a}}$.</span>
        </p>
      </div>
      <div class="well remark">
        <p>
          <b>Beweis.</b>
          Definieren wir zusätzlich noch
          <span class="nowrap">$T''_{\mathbf{a}} := \bigwedge_{i \in O_{\mathbf{a}}}
            \bar{x}_i$,</span>
          dann können wir
          $T_{\mathbf{a}} = T'_{\mathbf{a}} \wedge T''_{\mathbf{a}}$
          schreiben. Und jetzt ist
          $T'_{\mathbf{a}} \wedge T''_{\mathbf{a}} \leq T'_{\mathbf{a}}$
          offensichtlich, weil $g \wedge h \leq g$ ganz allgemein
          gilt (überzeugen Sie sich davon).<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
        </p>
      </div>
      <p>
        Wir definieren nun analog zu $F$ eine DNF-Formel
      </p>
      <div class="math-block">
        $$
        F' := \bigvee_{\mathbf{a} \in \sat(f)} T'_{\mathbf{a}} \ .
        $$
      </div>
      <p>
        Sie können sich vorstellen, dass wir $F$ nehmen und
        alle negativen Literale ersatzlos streichen. Wir behaupten
        nun, dass $F'$ und $F$ dieselbe Funktion darstellen:
      </p>
      <div class="well statement">
        <p>
          <b>Behauptung</b>
          <b>2.4.8</b>
          <span class="nowrap">$F \equiv F'$,</span>
          d.h. sie berechnen beide dieselbe Funktion,
          nämlich
          <span class="nowrap">$f$.</span>
        </p>
      </div>
      <div class="well remark">
        <p>
          <b>Beweis.</b>
          Um zu zeigen, dass beide dieselbe Funktion berechnen,
          müssen wir zeigen, dass
        </p>
        <div class="math-block">
          $$
          F(\mathbf{x}) = F'(\mathbf{x}) \textnormal{ für alle $\mathbf{x} \in \{0,1\}^n$. }
          $$
        </div>
        <p>
          Eine Möglichkeit, eine Gleichheit $=$ zu zeigen, ist,
          beide Ungleichungen $\leq$ und $\geq$ zu zeigen, also:
        </p>
        <ol>
          <li>
            <p>
              $F(\mathbf{x}) \leq F'(\mathbf{x})$ und
            </p>
          </li>
          <li>
            <p>
              <span class="nowrap">$F(\mathbf{x}) \geq F'(\mathbf{x})$.</span>
            </p>
          </li>
        </ol>
        <p>
          Punkt 1 ist einfach: wir haben bereits gesehen, dass
          $T_{\mathbf{a}} \leq T'_{\mathbf{a}}$ gilt, und somit
          auch
        </p>
        <div class="math-block">
          $$
          \bigvee_{\mathbf{a} \in \sat(f)} T_{\mathbf{a}} \leq \bigvee_{\mathbf{a} \in \sat(f)}
          T'_{\mathbf{a}}
          $$
        </div>
        <p>
          Hier haben wir angewendet, dass $\bigvee$ eine monotone
          Funktion ist und wir somit vom $\leq$ ihrer Inputs
          auf das $\leq$ ihres Outputs schließen können. Punkt
          2 ist schwieriger. Um
          $F'(\mathbf{x}) \leq F(\mathbf{x})$ zu zeigen, machen
          wir eine Fallunterscheidung. Falls
          $F'(\mathbf{x}) = 0$ ist, so gilt die Ungleichung
          offensichtlich, denn kleiner als $0$ kann der Output
          ja nicht werden. Falls nun $F'(\mathbf{x}) = 1$ ist,
          dann müssen wir zeigen, dass auch
          $F(\mathbf{x}) = 1$ gilt. Und das muss mindestens
          ein bisschen nicht-triviale Arbeit erfordern, weil
          wir ja irgendwo verwenden müssen, dass $f$ nicht monoton
          ist. Nehmen wir also an, dass $F'(\mathbf{x}) = 1$
          ist.
          <b>Strategie: was haben wir?</b>
          Es ist immer gut,
          Dinge konkret "in der Hand zu haben". In diesem Falle?
          Wir wissen ja, dass
          $F' = \bigvee_{\mathbf{a} \in \sat(f)} T'_{\mathbf{a}}$
          ist. Wenn nun also die linke Seite,
          <span class="nowrap">$F'$,</span>
          den Wert
          1 annimmt, dann muss es auf der rechten Seite (mindestens)
          einen Term geben, der auch 1 annimmt:
        </p>
        <div class="math-block">
          $$
          T'_{\mathbf{a}^*}(x_1,\dots,x_n) = 1 \ ,
          $$
        </div>
        <p>
          für ein festes, bestimmtes
          <span class="nowrap">$\mathbf{a}^*$,</span>
          also
        </p>
        <div class="math-block">
          $$
          \bigwedge_{i \in I_{\mathbf{a}^*}} x_i = 1 \ .
          $$
        </div>
        <p>
          Wir wollen zeigen, dass $F(x_1,\dots,x_n) = 1$ gilt.
          Da
          $F = \bigvee_{\mathbf{a} \in \sat(f)} T_{\mathbf{a}}$
          gilt, liegt der Verdacht nahe, dass der entsprechende
          Term $T_{\mathbf{a}^*}$ auch 1 ausgibt. Das Problem
          ist leider, dass
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          T_{\mathbf{a}^*}(\mathbf{x})&amp;= T'_{\mathbf{a}^*}(\mathbf{x}) \wedge
          T''_{\mathbf{a}^*}(\mathbf{x}) \\
          &amp;= 1 \wedge \bigwedge_{i \in O(\mathbf{a}^*)} \bar{x}_i \ .
          \end{align*}
          $$
        </div>
        <p>
          Wir wissen also, dass $x_i=1$ für alle
          $i \in I(\mathbf{a}^*)$ gilt; über die
          $i \in O(\mathbf{a}^*)$ wissen wir leider nichts.
          Was hätten wir denn gerne? Wir hätten gerne, dass für
          die alle $x_i = 0$ gilt, weil dann
          $\bigwedge_{i \in O(\mathbf{a}^*)} \bar{x}_i = 1$
          wäre; wir können das aber nicht garantieren. Wie schaut
          denn ein Input $\mathbf{y}$ aus, auf dem
          $T_{\mathbf{a}^*}$ 1 ausgibt? So ein $\mathbf{y}$
          müsste $y_i=1$ für alle $i \in I(\mathbf{a}^*)$ und
          $y_i=0$ für alle $i \in O(\mathbf{a}^*)$ haben; also
          1 sein, wo $\mathbf{a}^*$ auch 1 ist, und 0 sein,
          wo $\mathbf{a}^*$ auch 0 ist. Aha! Es müsste
          $\mathbf{a}^*$ selbst sein! Na klar, wir erinnern
          uns: wir haben den Term $T_{\mathbf{a}}$ so definiert,
          dass er auf $\mathbf{a}$ und nur dort 1 wird. Wir
          wissen also:
        </p>
        <div class="math-block">
          $$
          T_{\mathbf{a}^*} (\mathbf{a}^*) = 1 \ .
          $$
        </div>
        <p>
          Wenn wir Glück haben, gilt
          <span class="nowrap">$\mathbf{a}^* = \mathbf{x}$.</span>
          Ansonsten gilt immerhin,
          dass $x_i=1$ für alle
          <span class="nowrap">$i \in I(\mathbf{a}^*)$,</span>
          also
          $x_1 = 1$ wenn
          <span class="nowrap">$a^*_i = 1$.</span>
          In anderen Worten, es
          gilt
          <span class="nowrap">$\mathbf{x} \geq \mathbf{a}^*$!</span>
          Wunderbar! Jetzt
          können wir Monotonie anwenden! Denn selbst wenn
          $T_{\mathbf{a}^*}$ nicht monoton ist, so wissen wir,
          dass $F$ eine monotone Funktion berechnet, und somit
        </p>
        <div class="math-block">
          $$
          F(\mathbf{x}) \geq F(\mathbf{a}^*) = 1 \ .
          $$
        </div>
        <p>
          Wir können zwar nicht genau mit dem Finger auf einen
          Term von $F$ zeigen, der 1 wird, wissen aber
          <i>per
            Monotonie</i>, dass es so einen geben muss.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
        </p>
      </div>
      <p>
        Wir haben nun gezeigt, dass die DNF-Formeln $F$ und
        $F'$ dieselbe Boolesche Funktion berechnen, nämlich
        <span class="nowrap">$f$.</span>
        Die Formel $F'$ enthält keine negativen Literale
        und ist somit ein monotoner Schaltkreis von Tiefe 2.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p class="main-column">
      Ich habe Ihnen zweieinhalb Beweise versprochen. Der
      zweieinhalbte Beweis geht nun genau so wie der zweite,
      nur dass er eine CNF-Formel $G$ statt einer DNF-Formel
      $F$ konstruiert und aus dieser dann alle negativen
      Literale entfernt, womit wir eine monotone CNF-Formel
      $G'$ erhalten. Der Beweis, dass $G'$ und $G$ dieselbe
      Funktion berechnen, geht analog zu dem obigen Beweis.
    </p>
  </div>
</body>
</html>
