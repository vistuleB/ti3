<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 8.4 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 8, Section 4</title>
</head>
<body>
  <div class="body-wrapper">
    <div id="top-menu">
      <div class="top-menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./8-3.html"
        >&lt;&lt; Kapitel 8.3<span
            style="visibility:hidden"
            id="prev-page-tooltip"
          >Variationen: Mehrband-Maschinen, nichtdeterministische Maschinen</span></a>
      </div>
      <div class="top-menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./8-5.html"
        >Kapitel 8.5 &gt;&gt;<span
            style="visibility:hidden"
            id="next-page-tooltip"
          >Turing-Maschinen simulieren Turing-Maschinen: die universelle Turing-Maschine</span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        8.4&ensp;Turing-Maschinen codieren
      </p>
    </div>
    <p class="main-column">
      Wir haben mit der Turingmaschine ein einfaches aber doch sehr
      mächtiges Modell einer Rechenmaschine kennengelernt. Sie haben
      vielleicht mittlerweile - auch durch Ihre Programmiererfahrung -
      das Gefühl, das man im Prinzip alles, was man überhaupt
      programmieren kann, auch auf einer Turingmaschine hinkriegt.
      Versetzen Sie sich nun in die Lage der Menschen vor ungefähr 100
      Jahren. Damals gab es durchaus Rechenmaschinen. Maschinen zum
      Addieren und sogar zum Multiplizieren gibt es schon seit dem 17.
      Jahrhunder (<a href="https://en.wikipedia.org/wiki/Mechanical_calculator">Wikipedia: Mechanical
        calculator</a>).
      Leider musste man für jede Aufgabe eine neue Maschine erfinden und
      auch bauen. Zahlen addieren? Maschine bauen. Multiplizieren? Neue
      Maschine bauen. Verschlüsselung brechen? Neue Maschine bauen. Und
      so weiter. Die Idee einer
      <a href="https://en.wikipedia.org/wiki/Mechanical_calculator#Programmable_mechanical_calculators">programmierbaren
        Maschine</a>,
      die erstmals circa 1834 mit Charles Babbage aufkam, ist, dass man
      neben den Eingabedaten (z.B. die zu multiplizierenden Zahlen) auch
      die Rechenvorschrift (das Programm) als Eingabe übergibt. Hätte man
      so eine Maschine, dann müsste man nicht für jede neue Aufgabe eine
      neue Maschine entwerfen; man könnte
      <i>eine</i>
      Maschine bauen und sie
      für die jeweilige Aufgabe
      <span class="nowrap"><i>programmieren</i>,</span>
      indem ihr auf einem
      separaten Eingabeband die Rechenvorschrift überreicht. Von heute
      aus gesehen ist diese Idee nicht mehr allzu überraschend, weil
      diese Maschinen überall anzutreffen sind. Damals aber war es
      revolutionär. Um dies, zumindest auf dem Papier, in die Realität zu
      übersetzen, müssen wir zwei Fragen beantworten.
    </p>
    <div class="main-column">
      <ol>
        <li>
          <p>
            Wie können wir eine Rechenvorschrift (d.h. ein Programm) so
            codifizieren, dass wir es im Prinzip als eine Zeichenkette
            aufschreiben und einer Maschine übergeben können?
          </p>
        </li>
        <li>
          <p>
            Welche Maschine könnte so eine Rechenvorschrift lesen und sie
            an gegebenen Eingabedaten dann auch ausführen?
          </p>
        </li>
      </ol>
    </div>
    <p class="main-column">
      Es stellt sich heraus, dass wir beide Antworten (beinahe) schon
      kennen. Eine beliebige Rechenvorschrift können wir, da sind wir uns
      mittlerweile recht sicher, als Turingmaschine $M$ implementieren.
      Diese können wir über einem Alphabet codieren und erhalten ein Wort
      <span class="nowrap">$\enc(M)$.</span>
      Wie tun wir das? Nun ja, auf
      <a href="ttps://turingmachinesimulator.com">turingmachinesimulator.com</a>
      haben wir das bereits getan: eine Turingmaschine mit Alphabet
      $\Sigma$ können wir dort als String über dem Alphabet
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \Sigma \cup \{a,\dots,z,A\dots,Z,0,\dots,9\} \cup \{\texttt{&lt;}, \texttt{-}, \texttt{&gt;},
      \texttt{,}, \texttt{_}, \texttt{\n}, \dots\}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      codieren. Codierung ist im Prinzip kein Problem, wir werden aber
      ein paar Subtilitäten ansprechen. Punkt 2 ist schwieriger. Können
      wir eine Maschine bauen, die als eingabe (1) die Codierung
      $\enc(M)$ einer Turingmaschine und (2) ein Eingabewort
      $w \in \Sigma^*$ entgegennimmt und dann die Berechnung $M(x)$
      simuliert bzw. zu dem Ergebnis gelangt, zu dem auch $M(x)$
      gelangen würde? Die Programmierer von
      <a href="https://turingmachinesimulator.com">turingmachinesimulator.com</a>
      haben dies offensichtlich geschafft: sie haben eine Maschine
      "gebaut" (also wohl einen Server gemietet und eine Webseite mit
      viel Javascript programmiert), der eine Turingmaschine in einer
      spezifischen Codierung und ein Eingabewort einliest und dann diese
      simuliert. In diesem Teilkapitel werden wir sehen, wie wir eine
      Turingmaschine $M$ über einem fixen, nicht von $M$ abhängigen
      Alphabet codieren können. Im nächsten Teilkapitel werden wir uns
      überlegen, wie man einen Turingmaschinen-Simulator selbst als
      Turingmaschine implementieren kann. Also eine Turingmaschine
      <span class="nowrap">$U$,</span>
      die als Input Wörter der Form
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      c\#x
      \end{align*}
      $$
    </div>
    <p class="main-column">
      entgegennimmt und dann
    </p>
    <div class="main-column">
      <ol>
        <li>
          <p>
            <span class="nowrap"><b>ablehnt</b>,</span>
            falls $c$ keine gültige Codierung einer
            Turingmaschine $M$ ist,
          </p>
        </li>
        <li>
          <p>
            ansonsten, falls also
            <span class="nowrap">$c = \enc(M)$,</span>
            dann
          </p>
          <ol>
            <li>
              <p>
                <b>akzeptiert</b>
                falls $M(x)$ akzeptiert;
              </p>
            </li>
            <li>
              <p>
                <span class="nowrap"><b>ablehnt</b>,</span>
                falls $M(x)$ ablehnt
              </p>
            </li>
            <li>
              <p>
                <span class="nowrap"><b>nicht terminiert</b>,</span>
                falls $M(x)$ nicht terminiert.
              </p>
            </li>
          </ol>
        </li>
      </ol>
    </div>
    <p class="main-column">
      Falls wir bei $M$ nicht nur an Akzeptieren / Ablehnen interessiert
      sind, sondern am Ergebnis der Berechnung, dann hätten wir gerne,
      dass $U (\enc(M)\#x)$ am Ende den gleichen Bandinhalt hat wie
      $M(x)$ am Ende; hierbei gibt es allerdings eine Schwierigkeit mit
      den Details der Codierung, die wir gleich ansprechen werden.
    </p>
    <h3 class="main-column subtopic-announcement">
      Die Codierung
    </h3>
    <p class="main-column">
      Zuerst müssen wir uns auf ein Eingabealphabet $\Sigma$ einigen. Im
      Ernstfall genügt immer $\Sigma = \{0,1\}$ , allerdings gibt es
      keinen Grund, für die Definitionen nicht allgemeine endliche
      Alphabete $\Sigma$ zuzulassen. Wir wollen nun ein
      Codierungsalphabet $\Lambda$ und eine Codierungsfunktion
      <span class="nowrap">$\enc$,</span>
      so dass
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \enc(M) \in \Lambda^*
      \end{align*}
      $$
    </div>
    <p class="main-column">
      für jede Turingmaschine $M$ mit Eingabealphabet $\Sigma$ gilt.
      <b>Erster, zum scheitern verurteilter Versuch.</b>
      Sei $M$ eine
      Turingmaschine mit Eingabealphabet
      <span class="nowrap">$\Sigma$,</span>
      Arbeitsalphabet
      <span class="nowrap">$\Gamma$,</span>
      Zustandsmenge
      <span class="nowrap">$Q$,</span>
      Startzustand
      <span class="nowrap">$\qstart$,</span>
      akzeptierendem Zustand $\qaccept$ und Übergangsfunktion
      <span class="nowrap">$\delta$.</span>
      Wir codieren $M$ wie folgt: wenn
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \delta(q,x) = (r,y,\texttt{R}) \\
      \delta(q,y) = (s,z,\texttt{L}) \\
      \dots
      \end{align*}
      $$
    </div>
    <p class="main-column">
      dann schreiben wir in der Codierung
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \qstart \# \qaccept \# qxryR \# qyszL \# \dots
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Unser Codierungsalphabet ist also
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \Lambda := Q \cup \Gamma \cup \{\#, \texttt{L}, \texttt{S}, \texttt{R}\} \ .
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Sehen Sie das Problem? Das Codierungsalphabet ist nicht uniform:
      wir brauchen, abhängig von der Zustandsmenge $Q$ und dem
      Bandalphabet $\Gamma$ jeweils neue Alphabete. Wir wollen aber ein
      $\Lambda$ , da für
      <i>alle</i>
      Turingmaschinen mit Eingabealphabet
      $\Sigma$ funktioniert.
      <b>Zweiter, erfolgreicher Versuch.</b>
      Wir
      müssen also die Zustandsmenge $Q$ und die Zeichen
      $\Gamma \setminus \Sigma$ erst einmal selbst codieren,
      beispielsweise über dem Alphabet
      <span class="nowrap">$\{0,1\}$.</span>
      Die
      <span class="nowrap">$\delta$-Tabelle</span>
      der Turingmaschine für $\{a^nb^nc^n\}$
    </p>
    <div class="pseudowell">
      <figure>
        <img
          style="height:10em"
          src="img/turing-machines/exampe-2-aabbcc/delta-table.svg"
        >
      </figure>
    </div>
    <p class="main-column">
      würde dann zu folgender Tabelle:
    </p>
    <div class="pseudowell">
      <figure>
        <img
          style="height:10em"
          src="img/turing-machines/exampe-2-aabbcc/delta-table-encoded.svg"
        >
      </figure>
    </div>
    <p class="main-column">
      Wenn wir dies nun als
      <i>ein</i>
      Wort in obigen Schema schreiben,
      können wir für eine Tabellenzelle $\delta(q,x) = (r,y,R)$ nicht
      einfach $qxryR$ schreiben, auch nicht einfach die Codierungen
      zusammenschreiben: in diesem Falle würde nämlich
      $\delta(00,0) = (11,0,\texttt{R})$ zu $000110\texttt{R}$ und wir
      würden nicht mehr erkennen, wo welches Zeichen beginnt und aufhört.
      Wir brauchen ein Separatorzeichen, beispielsweise ein Komma. Aus
      Gründen, die später klar werden werden, schließen wir die Codierung
      der Turingmaschine mit einem $\texttt{;}$ ab. Die Codierung der
      obigen Maschine ist dann also
    </p>
    <div class="main-column">
<pre class="container">
00#100#00,a,01,1,S#00,b,L#00,c,L#00,1,L#00,0,11,0,R#01,a,R#01,b,10,1,S#01,1,R#10,b,R#10,c,00,1,S#10,1,R#11,1,R#11,0,100#;
</pre>
    </div>
    <p class="main-column">
      In dieser Codierung behalten wir zwei Konventionen bei: wenn eine
      Regel "fehlt", also beispielsweise für $\delta(10,a)$ die Zelle
      leer ist, dann soll das in den Zustand $\qreject$ führen; wenn in
      der Zelle nur ein Richtungszeichen, also beispielsweise
      <code>01,1,R</code>
      steht, dann ist das eine Abkürzung für
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \delta(01,1) = (01,1,\texttt{R}),
      \end{align*}
      $$
    </div>
    <p class="main-column">
      also
      <code>#01,1,01,1,R#</code>
      Wir können nun
      <i>jede</i>
      Turingmaschine über dem
      Alphabet $\Sigma$ codieren als Wort über dem Alphabet
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \Lambda := \writelambda
      \end{align*}
      $$
    </div>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>8.4.1</b>
        Zu einem Eingabealphabet $\Sigma$ definieren wir das
        <i>Codierungsalphabet</i>
        $\Lambda := \writelambda$ , wobei wir
        annehmen, dass
        <span class="nowrap">$\texttt{#}, \texttt{,}, \texttt{L}, \texttt{S}, \texttt{R},
          \texttt{;} \not \in \Sigma$.</span>
        Wir können nun jede Turingmaschine $M$ mit Eingabealphabet
        $\Sigma$ als String $\enc(M) \in \Lambda^*$ codieren. Per
        Konvention kommt
        <code>;</code>
        in $\enc(M)$ genau einmal vor, nämlich am
        Schluss.
      </p>
    </div>
    <div class="well alert-info out main-column">
      <p>
        <b>Anmerkungen:</b>
        das Wort
        <i>Codierung</i>
        suggeriert, dass wir,
        gegeben den String $c = \enc(M)$ die ursprüngliche
        Turingmaschine $M$ rekonstruieren können. Das gilt natürlich nur
        beschränkt: eventuell decodieren wir $c$ zu einer Maschine
        <span class="nowrap">$M'$,</span>
        die sich von $M$ in denen Namen der Zustände und der
        Bandalphabetsymbole unterscheidet. Allerdings stimmen die
        Funktionen
        $f_M: \Sigma^* \rightarrow \{\texttt{accept}, \texttt{reject},
        \texttt{undefined}\}$
        und
        $f_{M'}: \Sigma^* \rightarrow \{\texttt{accept},
        \texttt{reject}, \texttt{undefined}\}$
        überein.
      </p>
    </div>
    <div id="end-of-page-elt">
    </div>
    <div id="bottom-menu">
      <div class="bottom-menu-left">
        <a href="./8-3.html">&lt;&lt; Kapitel 8.3<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >Variationen: Mehrband-Maschinen, nichtdeterministische Maschinen</span></a>
      </div>
      <div class="bottom-menu-right">
        <a href="./8-5.html">Kapitel 8.5 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >Turing-Maschinen simulieren Turing-Maschinen: die universelle Turing-Maschine</span></a>
      </div>
    </div>
  </div>
</body>
</html>
