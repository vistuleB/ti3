<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 8.4 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 8, Section 4</title>
</head>
<body class="page-sub chapter-8 sub-4">
  <div id="menu">
    <div class="menu-left">
      <a href="./index.html">Inhaltsverzeichnis</a>
      <div>
        <a
          id="prev-page"
          href="./8-3.html"
        >&lt;&lt; Kapitel 8.3<span
            style="visibility:hidden"
            id="prev-page-tooltip"
          >Variationen: Mehrband-Maschinen, nichtdeterministische Maschinen</span></a>
      </div>
    </div>
    <div class="menu-right">
      <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a>
      <div>
        <a
          id="next-page"
          href="./8-5.html"
        >Kapitel 8.5 &gt;&gt;<span
            style="visibility:hidden"
            id="next-page-tooltip"
          >Turing-Maschinen simulieren Turing-Maschinen: die universelle Turing-Maschine</span></a>
      </div>
    </div>
  </div>
  <div class="main-column page-title">
    <p>
      8.4&ensp;Turing-Maschinen codieren
    </p>
  </div>
  <p class="main-column">
    Wir haben mit der Turingmaschine ein einfaches aber doch sehr
    mächtiges Modell einer Rechenmaschine kennengelernt. Sie haben
    vielleicht mittlerweile - auch durch Ihre Programmiererfahrung -
    das Gefühl, das man im Prinzip alles, was man überhaupt
    programmieren kann, auch auf einer Turingmaschine hinkriegt.
    Versetzen Sie sich nun in die Lage der Menschen vor ungefähr 100
    Jahren. Damals gab es durchaus Rechenmaschinen. Maschinen zum
    Addieren und sogar zum Multiplizieren gibt es schon seit dem 17.
    Jahrhunder (<a href="https://en.wikipedia.org/wiki/Mechanical_calculator">Wikipedia: Mechanical
      calculator</a>).
    Leider musste man für jede Aufgabe eine neue Maschine erfinden und
    auch bauen. Zahlen addieren? Maschine bauen. Multiplizieren? Neue
    Maschine bauen. Verschlüsselung brechen? Neue Maschine bauen. Und
    so weiter. Die Idee einer
    <a href="https://en.wikipedia.org/wiki/Mechanical_calculator#Programmable_mechanical_calculators">programmierbaren
      Maschine</a>,
    die erstmals circa 1834 mit Charles Babbage aufkam, ist, dass man
    neben den Eingabedaten (z.B. die zu multiplizierenden Zahlen) auch
    die Rechenvorschrift (das Programm) als Eingabe übergibt. Hätte man
    so eine Maschine, dann müsste man nicht für jede neue Aufgabe eine
    neue Maschine entwerfen; man könnte
    <i>eine</i>
    Maschine bauen und sie
    für die jeweilige Aufgabe
    <span class="nowrap"><i>programmieren</i>,</span>
    indem ihr auf einem
    separaten Eingabeband die Rechenvorschrift überreicht. Von heute
    aus gesehen ist diese Idee nicht mehr allzu überraschend, weil
    diese Maschinen überall anzutreffen sind. Damals aber war es
    revolutionär. Um dies, zumindest auf dem Papier, in die Realität zu
    übersetzen, müssen wir zwei Fragen beantworten.
  </p>
  <div class="main-column">
    <ol>
      <li>
        <p>
          Wie können wir eine Rechenvorschrift (d.h. ein Programm) so
          codifizieren, dass wir es im Prinzip als eine Zeichenkette
          aufschreiben und einer Maschine übergeben können?
        </p>
      </li>
      <li>
        <p>
          Welche Maschine könnte so eine Rechenvorschrift lesen und sie
          an gegebenen Eingabedaten dann auch ausführen?
        </p>
      </li>
    </ol>
  </div>
  <p class="main-column">
    Es stellt sich heraus, dass wir beide Antworten (beinahe) schon
    kennen. Eine beliebige Rechenvorschrift können wir, da sind wir uns
    mittlerweile recht sicher, als Turingmaschine $M$ implementieren.
    Diese können wir über einem Alphabet codieren und erhalten ein Wort
    <span class="nowrap">$\enc(M)$.</span>
    Wie tun wir das? Nun ja, auf
    <a href="ttps://turingmachinesimulator.com">turingmachinesimulator.com</a>
    haben wir das bereits getan: eine Turingmaschine mit Alphabet
    $\Sigma$ können wir dort als String über dem Alphabet
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \Sigma \cup \{a,\dots,z,A\dots,Z,0,\dots,9\} \cup \{\texttt{&lt;}, \texttt{-}, \texttt{&gt;},
    \texttt{,}, \texttt{_}, \texttt{\n}, \dots\}
    \end{align*}
    $$
  </div>
  <p class="main-column">
    codieren. Codierung ist im Prinzip kein Problem, wir werden aber
    ein paar Subtilitäten ansprechen. Punkt 2 ist schwieriger. Können
    wir eine Maschine bauen, die als eingabe (1) die Codierung
    $\enc(M)$ einer Turingmaschine und (2) ein Eingabewort
    $w \in \Sigma^*$ entgegennimmt und dann die Berechnung $M(x)$
    simuliert bzw. zu dem Ergebnis gelangt, zu dem auch $M(x)$
    gelangen würde? Die Programmierer von
    <a href="https://turingmachinesimulator.com">turingmachinesimulator.com</a>
    haben dies offensichtlich geschafft: sie haben eine Maschine
    "gebaut" (also wohl einen Server gemietet und eine Webseite mit
    viel Javascript programmiert), der eine Turingmaschine in einer
    spezifischen Codierung und ein Eingabewort einliest und dann diese
    simuliert. In diesem Teilkapitel werden wir sehen, wie wir eine
    Turingmaschine $M$ über einem fixen, nicht von $M$ abhängigen
    Alphabet codieren können. Im nächsten Teilkapitel werden wir uns
    überlegen, wie man einen Turingmaschinen-Simulator selbst als
    Turingmaschine implementieren kann. Also eine Turingmaschine
    <span class="nowrap">$U$,</span>
    die als Input Wörter der Form
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    c\#x
    \end{align*}
    $$
  </div>
  <p class="main-column">
    entgegennimmt und dann
  </p>
  <div class="main-column">
    <ol>
      <li>
        <p>
          <span class="nowrap"><b>ablehnt</b>,</span>
          falls $c$ keine gültige Codierung einer
          Turingmaschine $M$ ist,
        </p>
      </li>
      <li>
        <p>
          ansonsten, falls also
          <span class="nowrap">$c = \enc(M)$,</span>
          dann
        </p>
        <ol>
          <li>
            <p>
              <b>akzeptiert</b>
              falls $M(x)$ akzeptiert;
            </p>
          </li>
          <li>
            <p>
              <span class="nowrap"><b>ablehnt</b>,</span>
              falls $M(x)$ ablehnt
            </p>
          </li>
          <li>
            <p>
              <span class="nowrap"><b>nicht terminiert</b>,</span>
              falls $M(x)$ nicht terminiert.
            </p>
          </li>
        </ol>
      </li>
    </ol>
  </div>
  <p class="main-column">
    Falls wir bei $M$ nicht nur an Akzeptieren / Ablehnen interessiert
    sind, sondern am Ergebnis der Berechnung, dann hätten wir gerne,
    dass $U (\enc(M)\#x)$ am Ende den gleichen Bandinhalt hat wie
    $M(x)$ am Ende; hierbei gibt es allerdings eine Schwierigkeit mit
    den Details der Codierung, die wir gleich ansprechen werden.
  </p>
  <h3 class="main-column subtopic-announcement">
    Die Codierung
  </h3>
  <p class="main-column">
    Zuerst müssen wir uns auf ein Eingabealphabet $\Sigma$ einigen. Im
    Ernstfall genügt immer $\Sigma = \{0,1\}$ , allerdings gibt es
    keinen Grund, für die Definitionen nicht allgemeine endliche
    Alphabete $\Sigma$ zuzulassen. Wir wollen nun ein
    Codierungsalphabet $\Lambda$ und eine Codierungsfunktion
    <span class="nowrap">$\enc$,</span>
    so dass
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \enc(M) \in \Lambda^*
    \end{align*}
    $$
  </div>
  <p class="main-column">
    für jede Turingmaschine $M$ mit Eingabealphabet $\Sigma$ gilt.
    <b>Erster, zum scheitern verurteilter Versuch.</b>
    Sei $M$ eine
    Turingmaschine mit Eingabealphabet
    <span class="nowrap">$\Sigma$,</span>
    Arbeitsalphabet
    <span class="nowrap">$\Gamma$,</span>
    Zustandsmenge
    <span class="nowrap">$Q$,</span>
    Startzustand
    <span class="nowrap">$\qstart$,</span>
    akzeptierendem Zustand $\qaccept$ und Übergangsfunktion
    <span class="nowrap">$\delta$.</span>
    Wir codieren $M$ wie folgt: wenn
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \delta(q,x) = (r,y,\texttt{R}) \\
    \delta(q,y) = (s,z,\texttt{L}) \\
    \dots
    \end{align*}
    $$
  </div>
  <p class="main-column">
    dann schreiben wir in der Codierung
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \qstart \# \qaccept \# qxryR \# qyszL \# \dots
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Unser Codierungsalphabet ist also
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \Lambda := Q \cup \Gamma \cup \{\#, \texttt{L}, \texttt{S}, \texttt{R}\} \ .
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Sehen Sie das Problem? Das Codierungsalphabet ist nicht uniform:
    wir brauchen, abhängig von der Zustandsmenge $Q$ und dem
    Bandalphabet $\Gamma$ jeweils neue Alphabete. Wir wollen aber ein
    $\Lambda$ , da für
    <i>alle</i>
    Turingmaschinen mit Eingabealphabet
    $\Sigma$ funktioniert.
    <b>Zweiter, erfolgreicher Versuch.</b>
    Wir
    müssen also die Zustandsmenge $Q$ und die Zeichen
    $\Gamma \setminus \Sigma$ erst einmal selbst codieren,
    beispielsweise über dem Alphabet
    <span class="nowrap">$\{0,1\}$.</span>
    Die
    <span class="nowrap">$\delta$-Tabelle</span>
    der Turingmaschine für $\{a^nb^nc^n\}$
  </p>
  <div class="pseudowell">
    <figure>
      <img
        style="height:10em"
        src="img/turing-machines/exampe-2-aabbcc/delta-table.svg"
      >
    </figure>
  </div>
  <p class="main-column">
    würde dann zu folgender Tabelle:
  </p>
  <div class="pseudowell">
    <figure>
      <img
        style="height:10em"
        src="img/turing-machines/exampe-2-aabbcc/delta-table-encoded.svg"
      >
    </figure>
  </div>
  <p class="main-column">
    Wenn wir dies nun als
    <i>ein</i>
    Wort in obigen Schema schreiben,
    können wir für eine Tabellenzelle $\delta(q,x) = (r,y,R)$ nicht
    einfach $qxryR$ schreiben, auch nicht einfach die Codierungen
    zusammenschreiben: in diesem Falle würde nämlich
    $\delta(00,0) = (11,0,\texttt{R})$ zu $000110\texttt{R}$ und wir
    würden nicht mehr erkennen, wo welches Zeichen beginnt und aufhört.
    Wir brauchen ein Separatorzeichen, beispielsweise ein Komma. Aus
    Gründen, die später klar werden werden, schließen wir die Codierung
    der Turingmaschine mit einem $\texttt{;}$ ab. Die Codierung der
    obigen Maschine ist dann also
  </p>
  <div class="main-column">
<pre class="container">
00#100#00,a,01,1,S#00,b,L#00,c,L#00,1,L#00,0,11,0,R#01,a,R#01,b,10,1,S#01,1,R#10,b,R#10,c,00,1,S#10,1,R#11,1,R#11,0,100#;
</pre>
  </div>
  <p class="main-column">
    In dieser Codierung behalten wir zwei Konventionen bei: wenn eine
    Regel "fehlt", also beispielsweise für $\delta(10,a)$ die Zelle
    leer ist, dann soll das in den Zustand $\qreject$ führen; wenn in
    der Zelle nur ein Richtungszeichen, also beispielsweise
    <code>01,1,R</code>
    steht, dann ist das eine Abkürzung für
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \delta(01,1) = (01,1,\texttt{R}),
    \end{align*}
    $$
  </div>
  <p class="main-column">
    also
    <code>#01,1,01,1,R#</code>
    Wir können nun
    <i>jede</i>
    Turingmaschine über dem
    Alphabet $\Sigma$ codieren als Wort über dem Alphabet
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \Lambda := \writelambda
    \end{align*}
    $$
  </div>
  <div class="well statement out">
    <p>
      <b>Definition</b>
      <b>8.4.1</b>
      Zu einem Eingabealphabet $\Sigma$ definieren wir das
      <i>Codierungsalphabet</i>
      $\Lambda := \writelambda$ , wobei wir
      annehmen, dass
      <span class="nowrap">$\texttt{#}, \texttt{,}, \texttt{L}, \texttt{S}, \texttt{R},
        \texttt{;} \not \in \Sigma$.</span>
      Wir können nun jede Turingmaschine $M$ mit Eingabealphabet
      $\Sigma$ als String $\enc(M) \in \Lambda^*$ codieren. Per
      Konvention kommt
      <code>;</code>
      in $\enc(M)$ genau einmal vor, nämlich am
      Schluss.
    </p>
  </div>
  <div class="well alert-info out main-column">
    <p>
      <b>Anmerkungen:</b>
      das Wort
      <i>Codierung</i>
      suggeriert, dass wir,
      gegeben den String $c = \enc(M)$ die ursprüngliche
      Turingmaschine $M$ rekonstruieren können. Das gilt natürlich nur
      beschränkt: eventuell decodieren wir $c$ zu einer Maschine
      <span class="nowrap">$M'$,</span>
      die sich von $M$ in denen Namen der Zustände und der
      Bandalphabetsymbole unterscheidet. Allerdings stimmen die
      Funktionen
      $f_M: \Sigma^* \rightarrow \{\texttt{accept}, \texttt{reject},
      \texttt{undefined}\}$
      und
      $f_{M'}: \Sigma^* \rightarrow \{\texttt{accept},
      \texttt{reject}, \texttt{undefined}\}$
      überein.
    </p>
  </div>
</body>
</html>
