<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Chapter 5 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 5</title>
</head>
<body class="page-chapter chapter-5">
  <div id="menu">
    <div class="menu-left">
      <a href="./index.html">Inhaltsverzeichnis</a>
      <div>
        <a
          id="prev-page"
          href="./4-4.html"
        >&lt;&lt; Kapitel 4.4<span
            style="visibility:hidden"
            id="prev-page-tooltip"
          >Ein Schritt weiter:  while-Schleifen und
            <span class="nowrap">$\mu$-Rekursion</span></span></a>
      </div>
    </div>
    <div class="menu-right">
      <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a>
      <div>
        <a
          id="next-page"
          href="./5-1.html"
        >Kapitel 5.1 &gt;&gt;<span
            style="visibility:hidden"
            id="next-page-tooltip"
          >Reguläre Grammatiken</span></a>
      </div>
    </div>
  </div>
  <div class="main-column page-title">
    <p>
      5.&ensp;Reguläre Sprachen
    </p>
  </div>
  <p class="main-column">
    Hier sehen Sie einige Beispiele für gültige und ungültige
    Email-Adressen. Mit
    <i>gültig</i>
    meine ich, dass sie syntaktisch
    korrekt sind, ungeachtet, ob ein Konto mit dieser Email-Adresse
    besteht.
  </p>
  <div class="main-column">
<pre class="orange-comments">
thomas.schmitz@hszg.de                              <span class="actual-orange-comment">Gültig</span>
dominik@cs.sjtu.edu.cn                              <span class="actual-orange-comment">Gültig</span>
raffaela@mayer@gmail.com                            <span class="actual-orange-comment">Ungültig: @ kommt zweimal vor</span>
lorenz.klein@greatest/company/in/the/world.com      <span class="actual-orange-comment">Ungültig: Domain-Name darf kein / enthalten</span>
.schlaumeier@gmail.com                              <span class="actual-orange-comment">Ungültig: Google will kein . an erster Stelle</span>
</pre>
  </div>
  <p class="main-column">
    Hier sehen Sie den Teil eines HTML-Dokuments. Beachten Sie die
    typische hierarchisch-geschachtelte Struktur (sie müssen es nicht
    im Detail lesen):
  </p>
  <div class="main-column">
<pre class="listing html">
<span class="listing-bol"></span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"carousel-inner"</span> <span class="xml-2">style</span><span class="xml-3">=</span><span class="xml-4">"display:inline-block"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"item active"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">p</span><span class="xml-0">&gt;</span>$110 x + 794$<span class="xml-0">&lt;/</span><span class="xml-1">p</span><span class="xml-0">&gt;</span><span class="xml-0">&lt;</span><span class="xml-1">img</span> <span class="xml-2">loading</span><span class="xml-3">=</span><span class="xml-4">"lazy"</span> <span class="xml-2">src</span><span class="xml-3">=</span><span class="xml-4">"img/hash/hashfunction_110_794.svg"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">div</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"item"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">p</span><span class="xml-0">&gt;</span>$502 x + 121$<span class="xml-0">&lt;/</span><span class="xml-1">p</span><span class="xml-0">&gt;</span><span class="xml-0">&lt;</span><span class="xml-1">img</span> <span class="xml-2">loading</span><span class="xml-3">=</span><span class="xml-4">"lazy"</span> <span class="xml-2">src</span><span class="xml-3">=</span><span class="xml-4">"img/hash/hashfunction_502_121.svg"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">div</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"item"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">p</span><span class="xml-0">&gt;</span>$617 x + 5$<span class="xml-0">&lt;/</span><span class="xml-1">p</span><span class="xml-0">&gt;</span><span class="xml-0">&lt;</span><span class="xml-1">img</span> <span class="xml-2">loading</span><span class="xml-3">=</span><span class="xml-4">"lazy"</span> <span class="xml-2">src</span><span class="xml-3">=</span><span class="xml-4">"img/hash/hashfunction_617_5.svg"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">div</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"item"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">p</span><span class="xml-0">&gt;</span>$815 x + 562$<span class="xml-0">&lt;/</span><span class="xml-1">p</span><span class="xml-0">&gt;</span><span class="xml-0">&lt;</span><span class="xml-1">img</span> <span class="xml-2">loading</span><span class="xml-3">=</span><span class="xml-4">"lazy"</span> <span class="xml-2">src</span><span class="xml-3">=</span><span class="xml-4">"img/hash/hashfunction_851_562.svg"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">div</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"item"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">p</span><span class="xml-0">&gt;</span>$868 x + 858$<span class="xml-0">&lt;/</span><span class="xml-1">p</span><span class="xml-0">&gt;</span><span class="xml-0">&lt;</span><span class="xml-1">img</span> <span class="xml-2">loading</span><span class="xml-3">=</span><span class="xml-4">"lazy"</span> <span class="xml-2">src</span><span class="xml-3">=</span><span class="xml-4">"img/hash/hashfunction_868_858.svg"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">div</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"item"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">p</span><span class="xml-0">&gt;</span>$915 x + 320$<span class="xml-0">&lt;/</span><span class="xml-1">p</span><span class="xml-0">&gt;</span><span class="xml-0">&lt;</span><span class="xml-1">img</span> <span class="xml-2">loading</span><span class="xml-3">=</span><span class="xml-4">"lazy"</span> <span class="xml-2">src</span><span class="xml-3">=</span><span class="xml-4">"img/hash/hashfunction_915_320.svg"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">div</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-0">&lt;/</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"carousel-inner"</span><span class="xml-0">&gt;</span>
</pre>
  </div>
  <p class="main-column">
    Hier sehen Sie einen Ausschnitt aus einem Elm-Programm (auch
    diesen müssen Sie nicht im Detail lesen):
  </p>
  <div class="main-column">
<pre class="listing">
<span class="listing-bol"></span><span class="elm-1">find</span> <span class="elm-0">:</span> <span class="elm-2">Bst</span> <span class="elm-6">-&gt;</span> <span class="elm-2">String</span> <span class="elm-6">-&gt;</span> <span class="elm-2">Maybe</span> <span class="elm-2">String</span>
<span class="listing-bol"></span><span class="elm-1">find</span> <span class="elm-3">tree</span> <span class="elm-3">key</span> <span class="elm-0">=</span>
<span class="listing-bol"></span>    <span class="elm-4">case</span> <span class="elm-3">tree</span> <span class="elm-4">of</span>
<span class="listing-bol"></span>        <span class="elm-5">Empty</span> <span class="elm-4">_</span> <span class="elm-6">-&gt;</span>
<span class="listing-bol"></span>            <span class="elm-5">Nothing</span>
<span class="listing-bol"></span>        <span class="elm-5">Node</span> <span class="elm-7">(</span> <span class="elm-3">keyHere</span>, <span class="elm-3">valueHere</span> <span class="elm-7">)</span> <span class="elm-3">leftChild</span> <span class="elm-3">rightChild</span> <span class="elm-6">-&gt;</span>
<span class="listing-bol"></span>            <span class="elm-4">if</span> <span class="elm-3">key</span> <span class="elm-6">==</span> <span class="elm-3">keyHere</span> <span class="elm-4">then</span>
<span class="listing-bol"></span>                <span class="elm-5">Just</span> <span class="elm-3">valueHere</span>
<span class="listing-bol"></span>            <span class="elm-4">else</span> <span class="elm-4">if</span> <span class="elm-3">key</span> <span class="elm-6">&lt;</span> <span class="elm-3">keyHere</span> <span class="elm-4">then</span>
<span class="listing-bol"></span>                <span class="elm-5">find</span> <span class="elm-3">leftChild</span> <span class="elm-3">key</span>
<span class="listing-bol"></span>            <span class="elm-4">else</span>
<span class="listing-bol"></span>                <span class="elm-5">find</span> <span class="elm-3">rightChild</span> <span class="elm-3">key</span>
</pre>
  </div>
  <p class="main-column">
    Als letztes Beispiel sehen Sie hier eine svg-Datei. Dies ist ein
    Dateiformat für Vektorgrafiken. In diesem Falle ein Kreis mit einer
    Geraden:
  </p>
  <div class="pseudowell">
    <figure>
      <img
        class="checkered"
        style="padding:0;margin-bottom:0.5rem;"
        src="./img/svg-example.svg"
      >
    </figure>
  </div>
  <div class="main-column">
<pre class="listing html">
<span class="listing-bol"></span><span class="xml-0">&lt;?</span><span class="xml-1">xml</span> <span class="xml-2">version</span><span class="xml-3">=</span><span class="xml-4">"1.0"</span> <span class="xml-2">encoding</span><span class="xml-3">=</span><span class="xml-4">"UTF-8"</span><span class="xml-0">?&gt;</span>
<span class="listing-bol"></span><span class="xml-0">&lt;</span><span class="xml-1">svg</span>
<span class="listing-bol"></span>    <span class="xml-2">xmlns</span><span class="xml-3">=</span><span class="xml-4">"http://www.w3.org/2000/svg"</span>
<span class="listing-bol"></span>    <span class="xml-2">xmlns:xlink</span><span class="xml-3">=</span><span class="xml-4">"http://www.w3.org/1999/xlink"</span>
<span class="listing-bol"></span>    <span class="xml-2">width</span><span class="xml-3">=</span><span class="xml-4">"204px"</span> <span class="xml-2">height</span><span class="xml-3">=</span><span class="xml-4">"204px"</span>
<span class="listing-bol"></span>    <span class="xml-2">viewBox</span><span class="xml-3">=</span><span class="xml-4">"0 0 102 102"</span>
<span class="listing-bol"></span>    <span class="xml-2">version</span><span class="xml-3">=</span><span class="xml-4">"1.1"</span>
<span class="listing-bol"></span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">g</span> <span class="xml-2">id</span><span class="xml-3">=</span><span class="xml-4">"layer 1"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">circle</span>
<span class="listing-bol"></span>            <span class="xml-2">style</span><span class="xml-3">=</span><span class="xml-4">"fill:none;stroke:rgba(255,0,0,255);stroke-width:0.7;"</span>
<span class="listing-bol"></span>            <span class="xml-2">cx</span><span class="xml-3">=</span><span class="xml-4">"51"</span>
<span class="listing-bol"></span>            <span class="xml-2">cy</span><span class="xml-3">=</span><span class="xml-4">"51"</span>
<span class="listing-bol"></span>            <span class="xml-2">r</span><span class="xml-3">=</span><span class="xml-4">"40"</span>
<span class="listing-bol"></span>        <span class="xml-0">/&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">path</span>
<span class="listing-bol"></span>            <span class="xml-2">style</span><span class="xml-3">=</span><span class="xml-4">"fill:none;stroke:rgba(255,0,0,255);stroke-width:0.7;"</span>
<span class="listing-bol"></span>            <span class="xml-2">d</span><span class="xml-3">=</span><span class="xml-4">"M 51 51 l 33.5 -22.5"</span>
<span class="listing-bol"></span>        <span class="xml-0">/&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">g</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-0">&lt;/</span><span class="xml-1">svg</span><span class="xml-0">&gt;</span>
</pre>
  </div>
  <p class="main-column">
    Was haben diese vier Beispiele gemeinsam? Es handelt sich in allen
    Fällen um
    <span class="nowrap"><i>Daten</i>,</span>
    die in einem bestimmten festgelegten
    <i>Format</i>
    dargelegt werden. Soll ein Rechner etwas sinnvolles damit anfangen
    (zum Beispiel das Elm-Programm starten oder die HTML-Seite oder die
    Svg-Datei auf dem Bildschirm darstellen), muss er dieses Format
    erst einmal "verstehen", also den bloßen String aus ASCII-Zeichen
    umwandeln in eine logisch sinnvolle Struktur. Und genau darum geht
    es in den Formalen Sprachen: wir wollen Begriffe, Regeln, Methoden,
    Algorithmen entwickeln, um Daten, die in einem bestimmten Format
    vorliegen, zu verarbeiten; ja auch erst einmal überhaupt Begriffe
    festlegen, wie man solche Formate definiert.
  </p>
  <h2 class="main-column topic-announcement">
    Korrekte Email-Adressen
  </h2>
  <p class="main-column">
    Kommen wir auf unser erstes, einfachstes Beispiel zurück: die
    Email-Adressen. Können Sie möglichst präzise und möglichst formal
    beschreiben, wie eine korrekte Email-Adresse auszusehen hat? Hier
    versuche ich es einmal:
  </p>
  <div class="well highlight out">
    <p>
      Eine Emailadresse besteht aus einem
      <i>Benutzernamen</i>
      und einem
      <span class="nowrap"><i>Domainnamen</i>,</span>
      die mit einem
      <code>@</code>
      verbunden sind. Der Benutzername
      ist ein nichtleerer String bestehend aus Groß- und
      Kleinbuchstaben, Zahlen, und Punkten
      <span class="nowrap">(<code>.</code>).</span>
      Erster und letzter
      Buchstaben dürfen keine Punkte sein, außerdem dürfen keine zwei
      Punkte nebeneinander stehen. Der Domainname ist eine Folge von
      mindestenes zwei
      <span class="nowrap"><i>Labels</i>,</span>
      die jeweils mit einem
      <code>.</code>
      separiert
      sind. Ein Label ist ein nichtleerer String aus Groß- und
      Kleinbuchstaben, Zahlen und dem Bindestrich
      <span class="nowrap">(<code>-</code>).</span>
    </p>
  </div>
  <p class="main-column">
    Die genauen Regeln mögen von Anbieter zu Anbieter variieren; ich
    habe mich mal an das gehalten, was ich experimentell bei
    <code>gmail.com</code>
    herausgefunden habe. Die obige Beschreibung ist
    (hoffentlich) verständlich und präzise und unzweideutig. Allerdings
    ist sie in natürlicher Sprache verfasst; es ist beispielsweise
    nicht klar, wie ein Rechner aus der obigen Beschreibung einen
    Algorithmus konstruieren kann, der Korrektheit einer Email-Adresse
    überprüft. Außerdem schleichen sich bei natürlicher Sprache schnell
    Zweideutigkeiten ein, die a priori nicht immer zu erkennen sind.
    Wir wollen daher ein formales Regelwerk erstellen, wie wir Formate
    dieser Art vollständig und eindeutig beschreiben können. Ich werde
    dies nun Schritt für Schritt entwickeln, erst informell anhand des
    Email-Adressen-Beispiels und dann, im nächsten Kapitel, formal und
    abstrakt. Eine Emailadresse ist von der Form
    <i>Benutzername</i><code>@</code><span class="nowrap"><i>Domainnname</i>.</span>
    Dies können wir als
    <i>Ableitungsregel</i>
    darstellen:
  </p>
  <div class="main-column">
<pre>
&lt;EmailAdress&gt; -&gt; &lt;User&gt; @ &lt;Domain&gt;
</pre>
  </div>
  <p class="main-column">
    Wie können wir nun beispielsweise eine ähnliche Ableitungsregeln
    für
    <code>&lt;Domain&gt;</code>
    erstellen? Eine
    <code>&lt;Domain&gt;</code>
    soll eine Folge aus
    mindestens zwei
    <code>&lt;Label&gt;</code>
    sein, jeweils durch einen
    <code>.</code>
    separiert.
    Wir erreichen dies, indem wir einen an Rekursion erinnernden Trick
    anwenden: entweder gibt es genau zwei Labels oder die Domain
    beginnt mit einem Label, gefolgt von einem Punkt und wiederum einer
    <span class="nowrap"><i>Folge von mindestens zwei durch
        <code>.</code>
        separierten Labels</i>,</span>
    also
    wiederum etwas, das wie ein Domainname aussieht. Daher:
  </p>
  <div class="main-column">
<pre>
&lt;Domain&gt; -&gt; &lt;Label&gt; . &lt;Label&gt;
&lt;Domain&gt; -&gt; &lt;Label&gt; . &lt;Domain&gt;
</pre>
  </div>
  <p class="main-column">
    Wir geben also
    <i>zwei</i>
    Möglichkeiten an, wie mit einem
    <code>&lt;Domain&gt;</code>
    zu verfahren ist. Was ist nun
    <span class="nowrap"><code>&lt;Label&gt;</code>?</span>
    Dies ist eine nichtleere
    Folge von in Domainnamen erlaubten Zeichen. Diese sind
    alphanumerisch (Buchstaben und Zahlen) und der Strich
    <code>-</code>
    (in der
    Praxis sind eventuell noch weitere Zeichen erlaubt; im Ernstfall
    hängt dies davon ab, was die Domain Name Server des jeweiligen
    Landes / der jeweiligen Top-Level-Domain erlauben, siehe zum
    <a
      href="https://en.wikipedia.org/wiki/Internationalized_domain_name"
      class=""
    >Beispiel Wikipedia: Internationalized Domain
      Name</a>.
    Wie formulieren wir
    <i>nichtleere Folge von ...</i>
    mit unserer
    <span class="nowrap"><code>--&gt;;</code>-Notation?</span>
    Wieder mit dem Rekursionstrick:
  </p>
  <div class="main-column">
<pre>
&lt;Label&gt; -&gt; &lt;AlphaNumOrDash&gt;
&lt;Label&gt; -&gt; &lt;AlphaNumOrDash&gt; &lt;Label&gt;
&lt;AlphaNumOrDash&gt; -&gt; &lt;AlphaNum&gt;
&lt;AlphaNumOrDash&gt; -&gt; -
</pre>
  </div>
  <p class="main-column">
    Nun müssen wir noch Regeln für
    <code>&lt;AlphaNum&gt;</code>
    angeben. Hier führen
    wir eine weitere Konvention ein: nämlich, dass wir verschiedene
    Alternativen mit einem senkrechten Strich | separieren:
  </p>
  <div class="main-column">
<pre>
&lt;AlphaNum&gt; -&gt; a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z
&lt;AlphaNum&gt; -&gt; A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
&lt;AlphaNum&gt; -&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</pre>
  </div>
  <p class="main-column">
    Beachten Sie: ich habe hier absichtlich nicht
    <code>&lt;AlphaNum&gt; *-&gt;* a
      *|* ... *|* z</code>
    geschrieben, weil ich in diesem Beispiel wirklich
    alles ausschreiben wollte und mit der ...-Notation schon wieder
    etwas menschen- aber nicht maschinenlesbares eingeführt hätte. Wir
    brauchen noch Regeln für
    <span class="nowrap"><code>&lt;User&gt;</code>.</span>
    Dies ist ein nichtleerer String
    aus alphanumerischen Zeichen und dem Punkt
    <span class="nowrap"><code>.</code>,</span>
    wobei der Punkt
    nicht am Anfang und nicht am Ende stehen darf. Also: eine
    nichtleere Folge von
    <span class="nowrap"><i>Namensblöcken</i>,</span>
    die jeweils durch
    <code>.</code>
    separiert sind, wobei ein Namensblock eine nichtleere Folge
    alphanumerischer Zeichen ist.
  </p>
  <div class="main-column">
<pre>
&lt;User&gt; -&gt; &lt;NameBlock&gt; | &lt;NameBlock&gt; . &lt;User&gt;
&lt;NameBlock&gt; -&gt; &lt;AlphaNum&gt; | &lt;AlphaNum&gt; &lt;NameBlock&gt;
</pre>
  </div>
  <p class="main-column">
    Nun haben wir unser Emailformat vollständig beschrieben. Das
    gesamte Regelwerk sehen Sie hier noch einmal im Ganzen:
  </p>
  <div
    id="email-context-free-grammar"
    class="main-column"
  >
<pre class="listing">
<span class="listing-bol"></span>&lt;EmailAddress&gt;    -&gt;    &lt;User&gt; @ &lt;Domain&gt;
<span class="listing-bol"></span>&lt;Domain&gt;          -&gt;    &lt;Label&gt; . &lt;Label&gt; | &lt;Label&gt; . &lt;Domain&gt;
<span class="listing-bol"></span>&lt;User&gt;            -&gt;    &lt;NameBlock&gt; | &lt;NameBlock&gt; . &lt;User&gt;
<span class="listing-bol"></span>&lt;NameBlock&gt;       -&gt;    &lt;AlphaNum&gt; | &lt;AlphaNum&gt; &lt;NameBlock&gt;
<span class="listing-bol"></span>&lt;Label&gt;           -&gt;    &lt;AlphaNumOrDash&gt; | &lt;AlphaNumOrDash&gt; &lt;Label&gt;
<span class="listing-bol"></span>&lt;AlphaNumOrDash&gt;  -&gt;    &lt;AlphaNum&gt; | -
<span class="listing-bol"></span>&lt;AlphaNum&gt;        -&gt;    a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z
<span class="listing-bol"></span>&lt;AlphaNum&gt;        -&gt;    A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
</pre>
  </div>
  <h2 class="main-column topic-announcement">
    Ein Beispiel einer formalen Grammatik und einer Ableitung
  </h2>
  <p class="main-column">
    Was Sie hier sehen, nennt man eine
    <span class="nowrap"><i>formale Grammatik</i>.</span>
    Ihre
    Bestandteile sind:
  </p>
  <div class="main-column">
    <ul>
      <li>
        <p>
          Das Alphabet $\Sigma$ aller verwendeten Zeichen, in unserem
          Fall also $\Sigma = \{a,\dots,z,A,\dots,Z,.,-,@\}$ . Wir
          nennen $\Sigma$ die Menge der
          <span class="nowrap"><i>terminalen Symbole</i>.</span>
        </p>
      </li>
      <li>
        <p>
          Eine Menge $N$ abstrakter Symbole, hier
        </p>
        <div class="math-block">
          $$
          N = \{\texttt{&lt;EmailAddress&gt;,&lt;Domain&gt;,&lt;User&gt;,&lt;NameBlock&gt;,&lt;Label&gt;,&lt;AlphaNumOrDash&gt;,&lt;AlphaNum&gt;}\} \ .
          $$
        </div>
        <p>
          Diese Menge nennen wir die
          <span class="nowrap"><i>nichtterminalen Symbole</i>.</span>
          Wir
          verlangen, dass $N \cap \Sigma = \emptyset$ gilt; ein Symbol
          kann also nicht gleichzeitig Terminalsymbol und
          Nichtterminalsymbol sein.
        </p>
      </li>
      <li>
        <p>
          Eine Menge $P$ von Regeln, auch
          <i>Produktionen</i>
          genannt, wobei
          jede Regel die Form $X \rightarrow \alpha$ hat, wobei $\alpha$
          eine beliebig lange endliche Folge von Symbolen in
          $\Sigma \cup N$ ist.
        </p>
      </li>
      <li>
        <p>
          Ein Startsymbol
          <span class="nowrap">$S \in N$,</span>
          das angibt, wo wir mit unserer
          Ableitung beginnen sollen. Im obigen Beispiel sind wir ja an
          Emailadressen interessiert, also ist
          <code>&lt;EmailAddress&gt;</code>
          das
          Startsymbol.
        </p>
      </li>
    </ul>
  </div>
  <p class="main-column">
    Wenn wir nun so eine Grammatik gegeben haben, können wir Wörter
    <span class="nowrap"><i>ableiten</i>;</span>
    das heißt, wir beginnen mit dem Startsymbol und
    ersetzen in jedem Schritt ein nichtterminales Symbol durch die
    rechte Seite einer entsprechenden Regel. Dieser Vorgang ist nicht
    eindeutig und lässt mehrere Möglichkeiten offen; das ist auch gut
    so, denn es soll ja mehr als eine Email-Adresse geben. Hier ist ein
    Beispiel für eine Ableitung basierend auf der obigen Grammatik:
  </p>
  <div class="main-column">
<pre>
&lt;EmailAddress&gt; -&gt; &lt;User&gt;@&lt;Domain&gt;
            -&gt; &lt;NameBlock&gt;.&lt;User&gt;@&lt;Domain&gt;
            -&gt; &lt;NameBlock&gt;.&lt;NameBlock&gt;@&lt;Domain&gt;
            -&gt; &lt;NameBlock&gt;.&lt;NameBlock&gt;@&lt;Label&gt;.&lt;Domain&gt;
            -&gt; &lt;NameBlock&gt;.&lt;NameBlock&gt;@&lt;Label&gt;.&lt;Label&gt;.&lt;Label&gt;
            -&gt; &lt;AlphaNum&gt;.&lt;NameBlock&gt;@&lt;Label&gt;.&lt;Label&gt;.&lt;Label&gt;
            -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;Label&gt;.&lt;Label&gt;.&lt;Label&gt;
            -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;Label&gt;.&lt;Label&gt;
            -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;Label&gt;
            -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;&lt;Label&gt;
            -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;&lt;AlphaNumOrDash&gt;
            -&gt; d.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;&lt;AlphaNumOrDash&gt;
            -&gt; d.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;e
            -&gt; d.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.de
            -&gt; d.s@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.de
            -&gt; d.s@&lt;AlphaNumOrDash&gt;.b.de
            -&gt; d.s@a.b.de
</pre>
  </div>
  <p class="main-column">
    Nach dem gleichen Schema könnten wir
    <code>d.s.@-.-.--</code>
    ableiten, was
    darauf schließen lässt, dass unsere Grammatik nicht wirklich das
    tut, was wir beabsichtigen, dass sie nämlich
    <i>zu viele</i>
    Emailadressen herleitet, auch solche, die wir nicht als zulässige
    Adressen gelten lassen wollen.
  </p>
  <div class="well exercise out">
    <p>
      <b>Übungsaufgabe 5.1</b>
      Formulieren Sie weitere Regeln, um unsinnige Domainnamen wie
      <code>-.-.--</code>
      zu verbieten. Wie müssen Sie die obige Grammatik ändern?
    </p>
  </div>
  <h2 class="main-column topic-announcement">
    Terminologie, formale Definitionen und Beispiele
  </h2>
  <p class="main-column">
    Im letzten Abschnitt haben wir die Regeln für die Bildung
    syntaktisch korrekter Emailadressen formalisiert. Zwar
    unvollständig, doch hoffe ich, dass das allgemeine Schema klar
    geworden ist. Wir werden nun alles formaler und abstrakter
    definieren.
  </p>
  <h3 class="main-column subtopic-announcement">
    Alphabet
  </h3>
  <p class="main-column">
    Wenn wir über formale Sprachen reden, so liegt immer eine
    (endliche) Menge von Symbolen zugrunde, das Alphabet
    <span class="nowrap">$\Sigma$.</span>
    Im
    Emailadressen-Beispiel war (\Sigma) recht groß: die 52 Buchstaben;
    10 Ziffern; die Zeichen
    <code>@ . -</code>
    . Für Java-Programme oder andere
    Programmiersprachen kämen noch weitere Zeichen hinzu, zum Beispiel
    <code>+ - / \ { }</code>
    und so weiter; wenn wir alle Unicode-Zeichen
    miteinschließen, landen wir im Millionenbereich. In den
    theoretischen Beispielen, die in diesem Kurs folgen werden, ist das
    Alphabet fast immer viel kleiner: typische Alphabete zum Beispiel
    sind $\{0,1\}$ , $\{a,b,c,d\}$ oder auch $\{1\}$ , ein Alphabet
    mit nur einem Zeichen. Für ein Alphabet $\Sigma$ bezeichnen wir
    mit  $\Sigma^*$ die Menge aller endlichen Strings über diesem
    Alphabet; das schließt den
    <i>leeren String</i>
    mit ein, den wir mit
    $\epsilon$ bezeichnen. So ist beispielsweise
  </p>
  <div class="math-block main-column">
    $$
    \{a,b\}^* = \{\epsilon, a, b, aa, ab, ba, bb, aaa, aab, aba, ...\}
    $$
  </div>
  <p class="main-column">
    Ein Element
    <span class="nowrap">$x \in \Sigma^*$,</span>
    also einen endlichen String aus
    <span class="nowrap">$\Sigma$-Symbolen,</span>
    bezeichnen wir als
    <span class="nowrap"><i>Wort über $\Sigma$</i>.</span>
    Mit
    $\Sigma^+$ bezeichnen wir die Menge aller nichtleeren Strings,
    also
    <span class="nowrap">$\Sigma^+ = \Sigma^* \setminus \{\epsilon\}$.</span>
  </p>
  <h3 class="main-column subtopic-announcement">
    Sprachen
  </h3>
  <p class="main-column">
    Eine Teilmenge $L \subseteq \Sigma$ bezeichnen wir in diesem
    Kontext als
    <i>Sprache</i>
    und kürzen Sie oft mit $L$ ab, was für
    <i>language</i>
    steht. Beispiele für Sprachen wären
  </p>
  <div class="main-column">
    <ol>
      <li>
        <p>
          Die Sprache aller syntaktisch korrekten Emailadressen.
        </p>
      </li>
      <li>
        <p>
          Die Sprache aller Java-Programme, die ohne Fehlermeldung
          kompilieren
        </p>
      </li>
      <li>
        <p>
          Die Sprache aller Java-Programme, die kompilieren, dann aber
          mit einem Laufzeitfehler abbrechen.
        </p>
      </li>
      <li>
        <p>
          Die Sprache aller Java-Programme, die kompilieren und nicht
          mit einem Laufzeitfehler abbrechen.
        </p>
      </li>
      <li>
        <p>
          Die Sprache aller Wörter über
          <span class="nowrap">$\{a,b\}$,</span>
          die gleich viele
          <span class="nowrap">$a$'s</span>
          wie
          <span class="nowrap">$b$'s</span>
          enthalten.
        </p>
      </li>
      <li>
        <p>
          Die Sprache aller Palindrome über
          <span class="nowrap">$\{a,b,c,d\}$,</span>
          also Wörter,
          die von vorne wie hinten gelesen gleich aussehen.
        </p>
      </li>
    </ol>
  </div>
  <p class="main-column">
    Wir wollen herausfinden, welche Arten von Sprachen wir mit den im
    letzten Abschnitt eingeführen Regelwerk aus Ableitungen beschreiben
    können. Für die gerade aufgelisteten sechs Sprachen lautet die
    Antwort
  </p>
  <div class="main-column">
    <ol>
      <li>
        <p>
          Ja, können wir.
        </p>
      </li>
      <li>
        <p>
          Ja, wenn wir leicht komplexere Ableitungsregeln erlauben.
        </p>
      </li>
      <li>
        <p>
          Ja, wenn wir leicht komplexere Ableitungsregeln erlaubten.
        </p>
      </li>
      <li>
        <p>
          Nein, können wir nicht.
        </p>
      </li>
      <li>
        <p>
          Ja, können wir.
        </p>
      </li>
      <li>
        <p>
          Ja, können wir.
        </p>
      </li>
    </ol>
  </div>
  <h3 class="main-column subtopic-announcement">
    Grammatiken
  </h3>
  <div class="well statement out">
    <p>
      <b>Definition</b>
      <b>5.1</b>
      <b>(Kontextfreie Grammatik).</b>
      Eine
      <i>kontextfreie Grammatik</i>
      besteht aus
    </p>
    <ol>
      <li>
        <p>
          einem endlichen Alphabet
          <span class="nowrap">$\Sigma$,</span>
          den
          <span class="nowrap"><i>terminalen
              Symbolen</i>;</span>
        </p>
      </li>
      <li>
        <p>
          einer dazu disjunkten endlichen Menge
          <span class="nowrap">$N$,</span>
          genannt die
          <span class="nowrap"><i>nichtterminalen Symbole</i>;</span>
        </p>
      </li>
      <li>
        <p>
          einer endlichen Menge $P$ von
          <i>Produktionsregeln</i>
          der Form
          $X \rightarrow \alpha$ mit $X \in N$ und
          <span class="nowrap">$\alpha \in (\Sigma \cup \N)^*$;</span>
          formal also
          <span class="nowrap">$P \subseteq N \times (\Sigma \cup \N)^*$.</span>
        </p>
      </li>
      <li>
        <p>
          einem Startsymbol
          <span class="nowrap">$S \in N$.</span>
        </p>
      </li>
    </ol>
    <p>
      Die Grammatik $G$ ist also ein 4-Tupel
      <span class="nowrap">$(\Sigma, N, P, S)$.</span>
    </p>
  </div>
  <p class="main-column">
    Woher der Name
    <i>kontextfrei</i>
    kommt, werden Sie hoffentlich
    verstehen, wenn wir
    <i>Ableitungen</i>
    definiert haben. Die Tradition
    will es, dass wir für die terminalen Symbole Zahlen oder
    lateinsiche Kleinbuchstaben und für die nichtterminalen Symbole
    lateinische Großbuchstaben verwenden. Dies ist eine Konvention, die
    hilfreich ist, solange wir auf abstrakt-theoretischer Ebene über
    formale Grammatiken sprechen; wenn Sie z.B. eine Grammatik für Java
    erstellen wollen, dann wird $\Sigma$ natürlich auch Großbuchstaben
    enthalten.
  </p>
  <div class="well statement out">
    <p>
      <b>Beispiel</b>
      <b>5.2</b>
      Wir betrachten die Grammatik $G = (\{a,b\}, \{S, A, B\}, P, S)$
      mit den Produktionsregeln
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      S&amp;\rightarrow A B \\
      A&amp;\rightarrow \epsilon \ | \ a A \\
      B&amp;\rightarrow \epsilon \ | \ b B \ . \\
      \end{align*}
      $$
    </div>
    <p>
      Formal sind die Produktionsregeln $P$ eine Teilmenge von
      <span class="nowrap">$N \times (\Sigma \cup \N)^*$,</span>
      also
    </p>
    <div class="math-block">
      $$
      P = \{ (S, AB), (A, \epsilon), (A, aA), (B, \epsilon), (B, bB) \} \ .
      $$
    </div>
    <p>
      Für konkrete Beispiele wie die gerade betrachtete Grammatik
      jedoch verwenden wir einfach die Pfeilschreibweise
      <span class="nowrap">$S \rightarrow AB, \dots$.</span>
      Hier ist eine
      <i>Ableitung</i>
      basierend
      auf der Grammatik:
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      S \Rightarrow AB \Rightarrow aAB \Rightarrow aAbB \Rightarrow aAbbB
      \Rightarrow aAbb \Rightarrow abb \ .
      \end{align*}
      $$
    </div>
    <p>
      In jedem Schritt wählen wir ein Nichtterminal aus, zum Beispiel
      im zweiten Schritt
      <span class="nowrap">$A$,</span>
      und wenden eine Regel an, zum Beispiel
      <span class="nowrap">$A \rightarrow aA$.</span>
      Dadurch wird $AB$ zu
      <span class="nowrap">$aAB$.</span>
      Wir setzen diese
      Ableitungsschritte so lange fort, bis nur noch terminale Symbole
      übrigbleiben. Dann hat sich ein Wort $\alpha \in \Sigma^*$
      ergeben.
    </p>
  </div>
  <div class="well statement out">
    <p>
      <b>Definition</b>
      <b>5.3</b>
      Gegeben sei eine kontextfreie Grammatik
      <span class="nowrap">$G = (\Sigma, N, P, S)$.</span>
      Ein String $\alpha \in (\Sigma \cup N)^*$ heißt
      <i>Wortform</i>
      (im
      Gegensatz zu einem Wort
      <span class="nowrap">$x \in \Sigma^*)$.</span>
      Für zwei Wortformen
      $\alpha , \beta$ schreiben wir
    </p>
    <div class="math-block">
      $$
      \alpha \Rightarrow \beta
      $$
    </div>
    <p>
      wenn wir $\alpha$ zu $\beta$ machen können, indem wir ein
      nichtterminales Symbol $X$ in $\alpha$ durch die rechte Seite
      $X \rightarrow \gamma$ ersetzen können. Formal gesprochen, wenn
      wir $\alpha = \alpha_1 X \alpha_2$ und
      $\beta = \beta_1 \gamma \beta_2$ mit Wortformen
      $\alpha_1, \alpha_2, \beta_1, \gamma, \beta_2$ und einem
      Nichtterminal $X$ schreiben können, so dass
      $X \rightarrow \gamma$ eine Produktionsregel in $P$ ist. Wenn
      wir $\alpha = \beta$ "vorlesen", dann sagen wir _ $\beta$ kann
      aus $\alpha$ in einem Schritt abgeleitet werden_. Wenn $\beta$
      aus $\alpha$ in mehreren (im Extremfall null) Schritten
      abgeleitet werden kann, so schreiben wir
      <span class="nowrap">$\alpha \Rightarrow^* \beta$.</span>
      Formal bedeutet
      <span class="nowrap">$\alpha \Rightarrow^* \beta$,</span>
      dass es ein $k \geq 0$ gibt und
      "Zwischenwortformen" $\alpha_0, \alpha_1, \dots, \alpha_k$ mit
      $\alpha = \alpha_0$ und
      <span class="nowrap">$\alpha_k = \beta$,</span>
      sodass
      $\alpha_i \Rightarrow \alpha_{i+1}$ für alle
      $i = 0, 1, \dots, k-1$ gilt. Dies schließt den "trivialen" Fall
      $k=0$ mit ein, in welchem $\alpha = \beta$ gilt.
    </p>
  </div>
  <p class="main-column">
    Nochmals: wenn $\alpha$ die Form $\alpha_1 X \alpha_2$ hat, dann
    dürfen Sie das Nichtterminal $X$ durch die rechte Seite einer
    Produktionsregel $X \rightarrow \gamma$ ersetzen; Sie dürfen das
    unabhängig von dem
    <span class="nowrap"><i>Kontext</i>,</span>
    in welchem $X$ in der Wortform
    $\alpha$ vorkommt. Daher rührt der Name
    <span class="nowrap"><i>kontextfreie Grammatik</i>.</span>
    Beachten Sie, dass $P$ per Definition eine
    <i>endliche Menge</i>
    von
    Regeln sein muss, dass jedoch $\Rightarrow$ im Allgemeinen
    unendlich ist. Bereits für unsere einfache Grammatik mit den
    Produktionsregeln
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    S&amp;\rightarrow A B \\
    A&amp;\rightarrow \epsilon \ | \ a A \\
    B&amp;\rightarrow \epsilon \ | \ b B \ . \\
    \end{align*}
    $$
  </div>
  <p class="main-column">
    haben wir beispielsweise
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    A&amp;\rightarrow aA \\
    aA&amp;\rightarrow aaA \\
    aaA&amp;\rightarrow aaaA \\
    \dots
    \end{align*}
    $$
  </div>
  <p class="main-column">
    und sehen, dass die Menge aller Paare $\alpha \Rightarrow \beta$
    unendlich ist.
  </p>
  <div class="well statement out">
    <p>
      <b>Definition</b>
      <b>5.4</b>
      <b>(Die von einer Grammatik erzeugte Sprache).</b>
      Sei
      $G = (\Sigma, N, P, S)$ eine kontextfreie Grammatik. Die von $G$
      erzeugte Sprache $L(G)$ ist die Menge aller Wörter, die vom
      Startsymbol $S$ abgeleitet werden können, also
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      L(G) := \{x \in \Sigma^* \ | \ S \Rightarrow^* x\} \ .
      \end{align*}
      $$
    </div>
    <p>
      Wenn es zu einer Sprache $L \subseteq \Sigma^*$ eine
      kontextfreie Grammatik $G$ mit $L(G) = L$ gibt, so nennen wir $L$
      eine
      <span class="nowrap"><i>kontextfreie Sprache</i>.</span>
      Beachten Sie, dass in dem obigen
      Beispiel die Wortform $aaAB$ zwar aus $S$ abgeleitet werden
      kann, allerdings kein
      <i>Wort</i>
      ist, da es noch nichtterminale
      Symbole enthält. Es gilt also
      <span class="nowrap">$aaAB \not \in L(G)$.</span>
      Oft können
      wir $L(G)$ kompakt mit natürlicher Sprache beschreiben:
    </p>
  </div>
  <div class="well statement out">
    <p>
      <b>Beispiel</b>
      <b>5.5</b>
      Sei $G$ die zuletzt betrachtete Grammatik. Dann ist $L(G)$ die
      Menge aller Wörter der Form
      <span class="nowrap">$a^* b^*$,</span>
      also Wörter, in denen auf
      beliebig viele
      <span class="nowrap">$a$'s</span>
      beliebig viele
      <span class="nowrap">$b$'s</span>
      folgen.
    </p>
  </div>
  <p class="main-column">
    Wir betrachten nun einige weitere Beispiele
  </p>
  <div class="well statement out">
    <p>
      <b>Beispiel</b>
      <b>5.6</b>
      Wir betrachten die Grammatik $G_2 = (\{a,b\}, \{S\}, P, S)$ mit
      den Produktionsregeln
    </p>
    <div class="math-block">
      $$
      \begin{align}
      S&amp;\rightarrow aSbS \\
      S&amp;\rightarrow bSaS \\
      S&amp;\rightarrow \epsilon \ .
      \end{align}
      $$
    </div>
    <p>
      Hier sind mögliche Ableitungen des Wortes
      <span class="nowrap">$abab$.</span>
      Zur
      Verdeutlichung schreiben wir über den Pfeil $\Rightarrow$ die
      Nummer der Regel, die wir angewendet haben:
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      S&amp;\stackrel{(1)}{\Rightarrow} aSbS
      \stackrel{(1)}{\Rightarrow} aSbaSbS
      \stackrel{(3)}{\Rightarrow} aSbaSb
      \stackrel{(3)}{\Rightarrow} abaSb
      \stackrel{(3)}{\Rightarrow} abab \\
      S&amp;\stackrel{(1)}{\Rightarrow} aSbS
      \stackrel{(3)}{\Rightarrow} abS
      \stackrel{(1)}{\Rightarrow} abaSbS
      \stackrel{(3)}{\Rightarrow} ababS
      \stackrel{(3)}{\Rightarrow} abab \ .
      \end{align*}
      $$
    </div>
    <p>
      Wir sehen also: das gleiche Wort kann mehrere Ableitungen haben.
      Da die Ersetzungsregeln
      <i>kontextfrei</i>
      sind, spielt es keine
      Rolle, in welcher Reihenfolge wir nichtterminale Symbole
      ersetzen. Wenn Sie scharf hinschauen, werden Sie erkennen, dass
      die beiden Ableitungen "irgendwie gleich" sind, dass nur die
      Ableitungen in anderer Reihenfolge durchgeführt worden sind. Ich
      werde das in einem späteren Kapitel formal definieren, was ich
      mit damit meine. Um Ordnung in das Chaos zu bringen, könnten wir
      uns zum Beispiel einigen, dass man immer das am weitesten links
      stehende Nichtterminal ersetzen muss. Das nennt man eine
      <span class="nowrap"><i>Linksableitung</i>.</span>
      Dies ist nicht wirklich eine Einschränkung, da
      die Ersetzungsreihenfolge keine Rolle spielt. Wir sehen, dass die
      zweite Ableitung des Wortes $abab$ oben eine Linksableitung ist;
      zusammen mit der Beschriftung
      <span class="nowrap">$\stackrel{(i)}{\Rightarrow}$,</span>
      die
      die Nummer der angewendeten Regel angibt, ist eindeutig, wie wir
      von $S$ zum abgeleiteten Wort gekommen sind. Betrachten Sie nun
      eine weitere Linksableitung
      <span class="nowrap">$S \Rightarrow^* abab$:</span>
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      S&amp;\stackrel{(1)}{\Rightarrow} aSbS
      \stackrel{(2)}{\Rightarrow} abSaSbS
      \stackrel{(3)}{\Rightarrow} abaSbS
      \stackrel{(3)}{\Rightarrow} ababS
      \stackrel{(3)}{\Rightarrow} abab
      \end{align*}
      $$
    </div>
    <p>
      Sehen Sie, dass diese Ableitung
      <i>qualitativ</i>
      anders ist, da wir
      hier auch die Regel $S \rightarrow bSaS$ angewendet haben? Um
      die Struktur der Ableitung zu verdeutlichen, könnten wir die
      ersten beiden Ableitungen mit Wort $S \Rightarrow^* (ab)(ab)$
      bezeichnen und die dritte mit Wort
      <span class="nowrap">$S \Rightarrow^* a(ba)b$.</span>
    </p>
  </div>
  <h2 class="main-column topic-announcement">
    Ziele der Theorie der formalen Sprachen
  </h2>
  <p class="main-column">
    Ganz allgemein gesagt wollen wir lernen, wie wir Sprachen formal
    beschreiben können; wie wir, gegeben eine Grammatik $G$ und ein
    Zielwort
    <span class="nowrap">$x$,</span>
    eine Ableitung $G \Rightarrow^* x$ finden können.
    Anhand der Ableitungssequenz können wir dann oft auf die logische
    Struktur von $x$ schließen. Handelt es sich bei $G$ zum Beispiel
    um eine Grammatik für die Programmiersprache Java, so wäre ein
    Ziel, aus der Ableitungssequenz $G \Rightarrow^* x$ die Struktur
    des Programms
    <span class="nowrap">$x$,</span>
    also Klassenstruktur, Methoden, etc., ablesen
    zu können und schlussendlich das Programm in ausführbaren
    Maschinencode kompilieren zu können.
  </p>
  <div class="well statement out">
    <p>
      <b>Algorithmisches Problem: Parsing</b>
      <b>5.7</b>
      Gegeben eine (kontextfreie) Grammatik $G$ und ein Zielwort $x$ ,
      finde eine Ableitung
      <span class="nowrap">$G \Rightarrow^* x$,</span>
      falls es so eine gibt.
      Für einen String $x$ eine Ableitung zu finden bezeichnen wir als
      <span class="nowrap"><i>parsen</i>,</span>
      das zugehörige Hauptwort als
      <span class="nowrap"><i>Parsing</i>.</span>
    </p>
  </div>
  <p class="main-column">
    <b>Die gute Nachricht:</b>
    Die gute Nachricht: wir kennen Algorithmen,
    die dieses Problem im effizient lösen, wenn wir den "theoretischen"
    Effizienzbegriff zugrund legen.
  </p>
  <p class="main-column">
    <b>Die schlechte Nachricht:</b>
    wir kennen keinen Algorithmus, der das
    Parsing kontextfreier Sprachen in seiner ganzen Allgemeinheit in
    <i>linearer Zeit</i>
    erledigt, dessen Laufzeit also proportional zur
    Länge des Zielwortes $x$ ist. Dies ist aber, was wir in der
    Praxis, zum Beispiel bei Compilern, erwarten.
  </p>
  <p class="main-column">
    <b>Die gute Nachricht:</b>
    in fast allen praktisch relevanten Fällen
    haben wir es mit Grammatiken zu tun, die Parsing in linearer Zeit
    ermöglichen. Und wenn wir Programmiersprachen, Datenformate etc.
    entwerfen, haben wir es ja in der Hand, Sprache und Grammatik so
    anzulegen, dass effizientes Parsen möglich ist. Im nächsten Kapitel
    lernen wir eine stark eingeschränkte, aber dennoch sehr wichtige
    Klasse kontextfreier Grammatik kennen, die allesamt ein sehr
    effizientes Parsing erlauben: die sogenannten
    <i>regulären</i>
    Grammatiken.
  </p>
</body>
</html>
