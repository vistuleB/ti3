<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Chapter 5 of TI-2 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI-2 - Chapter 5</title>
</head>
<body>
  <div class="body-wrapper">
    <div id="top-menu">
      <div id="top-menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./4-4.html"
        >&lt;&lt; Kapitel 4.4<span
            style="visibility:hidden"
            id="top-prev-page-tooltip"
          >Ein Schritt weiter:  while-Schleifen und
            <span class="nowrap">$\mu$-Rekursion</span></span></a>
      </div>
      <div id="top-menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./5-1.html"
        >Kapitel 5.1 &gt;&gt;<span
            style="visibility:hidden"
            id="top-next-page-tooltip"
          >Reguläre Grammatiken</span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        5.&ensp;Reguläre Sprachen
      </p>
    </div>
    <p class="main-column">
      Hier sehen Sie einige Beispiele für gültige und ungültige
      Email-Adressen. Mit
      <i>gültig</i>
      meine ich, dass sie syntaktisch
      korrekt sind, ungeachtet, ob ein Konto mit dieser Email-Adresse
      besteht.
    </p>
    <div class="main-column">
<pre class="orange-comments">
thomas.schmitz@hszg.de                              <span class="actual-orange-comment">Gültig</span>
dominik@cs.sjtu.edu.cn                              <span class="actual-orange-comment">Gültig</span>
raffaela@mayer@gmail.com                            <span class="actual-orange-comment">Ungültig: @ kommt zweimal vor</span>
lorenz.klein@greatest/company/in/the/world.com      <span class="actual-orange-comment">Ungültig: Domain-Name darf kein / enthalten</span>
.schlaumeier@gmail.com                              <span class="actual-orange-comment">Ungültig: Google will kein . an erster Stelle</span>
</pre>
    </div>
    <p class="main-column">
      Hier sehen Sie den Teil eines HTML-Dokuments. Beachten Sie die
      typische hierarchisch-geschachtelte Struktur (sie müssen es nicht
      im Detail lesen):
    </p>
    <div class="main-column">
<pre class="listing html">
<span class="listing-bol"></span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"carousel-inner"</span> <span class="xml-2">style</span><span class="xml-3">=</span><span class="xml-4">"display:inline-block"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"item active"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">p</span><span class="xml-0">&gt;</span>$110 x + 794$<span class="xml-0">&lt;/</span><span class="xml-1">p</span><span class="xml-0">&gt;</span><span class="xml-0">&lt;</span><span class="xml-1">img</span> <span class="xml-2">loading</span><span class="xml-3">=</span><span class="xml-4">"lazy"</span> <span class="xml-2">src</span><span class="xml-3">=</span><span class="xml-4">"img/hash/hashfunction_110_794.svg"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">div</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"item"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">p</span><span class="xml-0">&gt;</span>$502 x + 121$<span class="xml-0">&lt;/</span><span class="xml-1">p</span><span class="xml-0">&gt;</span><span class="xml-0">&lt;</span><span class="xml-1">img</span> <span class="xml-2">loading</span><span class="xml-3">=</span><span class="xml-4">"lazy"</span> <span class="xml-2">src</span><span class="xml-3">=</span><span class="xml-4">"img/hash/hashfunction_502_121.svg"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">div</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"item"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">p</span><span class="xml-0">&gt;</span>$617 x + 5$<span class="xml-0">&lt;/</span><span class="xml-1">p</span><span class="xml-0">&gt;</span><span class="xml-0">&lt;</span><span class="xml-1">img</span> <span class="xml-2">loading</span><span class="xml-3">=</span><span class="xml-4">"lazy"</span> <span class="xml-2">src</span><span class="xml-3">=</span><span class="xml-4">"img/hash/hashfunction_617_5.svg"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">div</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"item"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">p</span><span class="xml-0">&gt;</span>$815 x + 562$<span class="xml-0">&lt;/</span><span class="xml-1">p</span><span class="xml-0">&gt;</span><span class="xml-0">&lt;</span><span class="xml-1">img</span> <span class="xml-2">loading</span><span class="xml-3">=</span><span class="xml-4">"lazy"</span> <span class="xml-2">src</span><span class="xml-3">=</span><span class="xml-4">"img/hash/hashfunction_851_562.svg"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">div</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"item"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">p</span><span class="xml-0">&gt;</span>$868 x + 858$<span class="xml-0">&lt;/</span><span class="xml-1">p</span><span class="xml-0">&gt;</span><span class="xml-0">&lt;</span><span class="xml-1">img</span> <span class="xml-2">loading</span><span class="xml-3">=</span><span class="xml-4">"lazy"</span> <span class="xml-2">src</span><span class="xml-3">=</span><span class="xml-4">"img/hash/hashfunction_868_858.svg"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">div</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"item"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">p</span><span class="xml-0">&gt;</span>$915 x + 320$<span class="xml-0">&lt;/</span><span class="xml-1">p</span><span class="xml-0">&gt;</span><span class="xml-0">&lt;</span><span class="xml-1">img</span> <span class="xml-2">loading</span><span class="xml-3">=</span><span class="xml-4">"lazy"</span> <span class="xml-2">src</span><span class="xml-3">=</span><span class="xml-4">"img/hash/hashfunction_915_320.svg"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">div</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-0">&lt;/</span><span class="xml-1">div</span> <span class="xml-2">class</span><span class="xml-3">=</span><span class="xml-4">"carousel-inner"</span><span class="xml-0">&gt;</span>
</pre>
    </div>
    <p class="main-column">
      Hier sehen Sie einen Ausschnitt aus einem Elm-Programm (auch
      diesen müssen Sie nicht im Detail lesen):
    </p>
    <div class="main-column">
<pre class="listing">
<span class="listing-bol"></span><span class="elm-1">find</span> <span class="elm-0">:</span> <span class="elm-2">Bst</span> <span class="elm-6">-&gt;</span> <span class="elm-2">String</span> <span class="elm-6">-&gt;</span> <span class="elm-2">Maybe</span> <span class="elm-2">String</span>
<span class="listing-bol"></span><span class="elm-1">find</span> <span class="elm-3">tree</span> <span class="elm-3">key</span> <span class="elm-0">=</span>
<span class="listing-bol"></span>    <span class="elm-4">case</span> <span class="elm-3">tree</span> <span class="elm-4">of</span>
<span class="listing-bol"></span>        <span class="elm-5">Empty</span> <span class="elm-4">_</span> <span class="elm-6">-&gt;</span>
<span class="listing-bol"></span>            <span class="elm-5">Nothing</span>
<span class="listing-bol"></span>        <span class="elm-5">Node</span> <span class="elm-7">(</span> <span class="elm-3">keyHere</span>, <span class="elm-3">valueHere</span> <span class="elm-7">)</span> <span class="elm-3">leftChild</span> <span class="elm-3">rightChild</span> <span class="elm-6">-&gt;</span>
<span class="listing-bol"></span>            <span class="elm-4">if</span> <span class="elm-3">key</span> <span class="elm-6">==</span> <span class="elm-3">keyHere</span> <span class="elm-4">then</span>
<span class="listing-bol"></span>                <span class="elm-5">Just</span> <span class="elm-3">valueHere</span>
<span class="listing-bol"></span>            <span class="elm-4">else</span> <span class="elm-4">if</span> <span class="elm-3">key</span> <span class="elm-6">&lt;</span> <span class="elm-3">keyHere</span> <span class="elm-4">then</span>
<span class="listing-bol"></span>                <span class="elm-5">find</span> <span class="elm-3">leftChild</span> <span class="elm-3">key</span>
<span class="listing-bol"></span>            <span class="elm-4">else</span>
<span class="listing-bol"></span>                <span class="elm-5">find</span> <span class="elm-3">rightChild</span> <span class="elm-3">key</span>
</pre>
    </div>
    <p class="main-column">
      Als letztes Beispiel sehen Sie hier eine svg-Datei. Dies ist ein
      Dateiformat für Vektorgrafiken. In diesem Falle ein Kreis mit einer
      Geraden:
    </p>
    <div class="pseudowell">
      <figure>
        <img
          class="checkered"
          style="padding:0;margin-bottom:0.5rem;"
          src="./img/svg-example.svg"
        >
      </figure>
    </div>
    <div class="main-column">
<pre class="listing html">
<span class="listing-bol"></span><span class="xml-0">&lt;?</span><span class="xml-1">xml</span> <span class="xml-2">version</span><span class="xml-3">=</span><span class="xml-4">"1.0"</span> <span class="xml-2">encoding</span><span class="xml-3">=</span><span class="xml-4">"UTF-8"</span><span class="xml-0">?&gt;</span>
<span class="listing-bol"></span><span class="xml-0">&lt;</span><span class="xml-1">svg</span>
<span class="listing-bol"></span>    <span class="xml-2">xmlns</span><span class="xml-3">=</span><span class="xml-4">"http://www.w3.org/2000/svg"</span>
<span class="listing-bol"></span>    <span class="xml-2">xmlns:xlink</span><span class="xml-3">=</span><span class="xml-4">"http://www.w3.org/1999/xlink"</span>
<span class="listing-bol"></span>    <span class="xml-2">width</span><span class="xml-3">=</span><span class="xml-4">"204px"</span> <span class="xml-2">height</span><span class="xml-3">=</span><span class="xml-4">"204px"</span>
<span class="listing-bol"></span>    <span class="xml-2">viewBox</span><span class="xml-3">=</span><span class="xml-4">"0 0 102 102"</span>
<span class="listing-bol"></span>    <span class="xml-2">version</span><span class="xml-3">=</span><span class="xml-4">"1.1"</span>
<span class="listing-bol"></span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;</span><span class="xml-1">g</span> <span class="xml-2">id</span><span class="xml-3">=</span><span class="xml-4">"layer 1"</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">circle</span>
<span class="listing-bol"></span>            <span class="xml-2">style</span><span class="xml-3">=</span><span class="xml-4">"fill:none;stroke:rgba(255,0,0,255);stroke-width:0.7;"</span>
<span class="listing-bol"></span>            <span class="xml-2">cx</span><span class="xml-3">=</span><span class="xml-4">"51"</span>
<span class="listing-bol"></span>            <span class="xml-2">cy</span><span class="xml-3">=</span><span class="xml-4">"51"</span>
<span class="listing-bol"></span>            <span class="xml-2">r</span><span class="xml-3">=</span><span class="xml-4">"40"</span>
<span class="listing-bol"></span>        <span class="xml-0">/&gt;</span>
<span class="listing-bol"></span><span class="xml-5">        </span><span class="xml-0">&lt;</span><span class="xml-1">path</span>
<span class="listing-bol"></span>            <span class="xml-2">style</span><span class="xml-3">=</span><span class="xml-4">"fill:none;stroke:rgba(255,0,0,255);stroke-width:0.7;"</span>
<span class="listing-bol"></span>            <span class="xml-2">d</span><span class="xml-3">=</span><span class="xml-4">"M 51 51 l 33.5 -22.5"</span>
<span class="listing-bol"></span>        <span class="xml-0">/&gt;</span>
<span class="listing-bol"></span><span class="xml-5">    </span><span class="xml-0">&lt;/</span><span class="xml-1">g</span><span class="xml-0">&gt;</span>
<span class="listing-bol"></span><span class="xml-0">&lt;/</span><span class="xml-1">svg</span><span class="xml-0">&gt;</span>
</pre>
    </div>
    <p class="main-column">
      Was haben diese vier Beispiele gemeinsam? Es handelt sich in allen
      Fällen um
      <span class="nowrap"><i>Daten</i>,</span>
      die in einem bestimmten festgelegten
      <i>Format</i>
      dargelegt werden. Soll ein Rechner etwas sinnvolles damit anfangen
      (zum Beispiel das Elm-Programm starten oder die HTML-Seite oder die
      Svg-Datei auf dem Bildschirm darstellen), muss er dieses Format
      erst einmal "verstehen", also den bloßen String aus ASCII-Zeichen
      umwandeln in eine logisch sinnvolle Struktur. Und genau darum geht
      es in den Formalen Sprachen: wir wollen Begriffe, Regeln, Methoden,
      Algorithmen entwickeln, um Daten, die in einem bestimmten Format
      vorliegen, zu verarbeiten; ja auch erst einmal überhaupt Begriffe
      festlegen, wie man solche Formate definiert.
    </p>
    <h2 class="main-column topic-announcement">
      Korrekte Email-Adressen
    </h2>
    <p class="main-column">
      Kommen wir auf unser erstes, einfachstes Beispiel zurück: die
      Email-Adressen. Können Sie möglichst präzise und möglichst formal
      beschreiben, wie eine korrekte Email-Adresse auszusehen hat? Hier
      versuche ich es einmal:
    </p>
    <div class="well highlight out">
      <p>
        Eine Emailadresse besteht aus einem
        <i>Benutzernamen</i>
        und einem
        <span class="nowrap"><i>Domainnamen</i>,</span>
        die mit einem
        <code>@</code>
        verbunden sind. Der Benutzername
        ist ein nichtleerer String bestehend aus Groß- und
        Kleinbuchstaben, Zahlen, und Punkten
        <span class="nowrap">(<code>.</code>).</span>
        Erster und letzter
        Buchstaben dürfen keine Punkte sein, außerdem dürfen keine zwei
        Punkte nebeneinander stehen. Der Domainname ist eine Folge von
        mindestenes zwei
        <span class="nowrap"><i>Labels</i>,</span>
        die jeweils mit einem
        <code>.</code>
        separiert
        sind. Ein Label ist ein nichtleerer String aus Groß- und
        Kleinbuchstaben, Zahlen und dem Bindestrich
        <span class="nowrap">(<code>-</code>).</span>
      </p>
    </div>
    <p class="main-column">
      Die genauen Regeln mögen von Anbieter zu Anbieter variieren; ich
      habe mich mal an das gehalten, was ich experimentell bei
      <code>gmail.com</code>
      herausgefunden habe. Die obige Beschreibung ist
      (hoffentlich) verständlich und präzise und unzweideutig. Allerdings
      ist sie in natürlicher Sprache verfasst; es ist beispielsweise
      nicht klar, wie ein Rechner aus der obigen Beschreibung einen
      Algorithmus konstruieren kann, der Korrektheit einer Email-Adresse
      überprüft. Außerdem schleichen sich bei natürlicher Sprache schnell
      Zweideutigkeiten ein, die a priori nicht immer zu erkennen sind.
      Wir wollen daher ein formales Regelwerk erstellen, wie wir Formate
      dieser Art vollständig und eindeutig beschreiben können. Ich werde
      dies nun Schritt für Schritt entwickeln, erst informell anhand des
      Email-Adressen-Beispiels und dann, im nächsten Kapitel, formal und
      abstrakt. Eine Emailadresse ist von der Form
      <i>Benutzername</i><code>@</code><span class="nowrap"><i>Domainnname</i>.</span>
      Dies können wir als
      <i>Ableitungsregel</i>
      darstellen:
    </p>
    <div class="main-column">
<pre>
&lt;EmailAdress&gt; -&gt; &lt;User&gt; @ &lt;Domain&gt;
</pre>
    </div>
    <p class="main-column">
      Wie können wir nun beispielsweise eine ähnliche Ableitungsregeln
      für
      <code>&lt;Domain&gt;</code>
      erstellen? Eine
      <code>&lt;Domain&gt;</code>
      soll eine Folge aus
      mindestens zwei
      <code>&lt;Label&gt;</code>
      sein, jeweils durch einen
      <code>.</code>
      separiert.
      Wir erreichen dies, indem wir einen an Rekursion erinnernden Trick
      anwenden: entweder gibt es genau zwei Labels oder die Domain
      beginnt mit einem Label, gefolgt von einem Punkt und wiederum einer
      <span class="nowrap"><i>Folge von mindestens zwei durch
          <code>.</code>
          separierten Labels</i>,</span>
      also
      wiederum etwas, das wie ein Domainname aussieht. Daher:
    </p>
    <div class="main-column">
<pre>
&lt;Domain&gt; -&gt; &lt;Label&gt; . &lt;Label&gt;
&lt;Domain&gt; -&gt; &lt;Label&gt; . &lt;Domain&gt;
</pre>
    </div>
    <p class="main-column">
      Wir geben also
      <i>zwei</i>
      Möglichkeiten an, wie mit einem
      <code>&lt;Domain&gt;</code>
      zu verfahren ist. Was ist nun
      <span class="nowrap"><code>&lt;Label&gt;</code>?</span>
      Dies ist eine nichtleere
      Folge von in Domainnamen erlaubten Zeichen. Diese sind
      alphanumerisch (Buchstaben und Zahlen) und der Strich
      <code>-</code>
      (in der
      Praxis sind eventuell noch weitere Zeichen erlaubt; im Ernstfall
      hängt dies davon ab, was die Domain Name Server des jeweiligen
      Landes / der jeweiligen Top-Level-Domain erlauben, siehe zum
      <a
        href="https://en.wikipedia.org/wiki/Internationalized_domain_name"
        class=""
      >Beispiel Wikipedia: Internationalized Domain
        Name</a>.
      Wie formulieren wir
      <i>nichtleere Folge von ...</i>
      mit unserer
      <span class="nowrap"><code>--&gt;;</code>-Notation?</span>
      Wieder mit dem Rekursionstrick:
    </p>
    <div class="main-column">
<pre>
&lt;Label&gt; -&gt; &lt;AlphaNumOrDash&gt;
&lt;Label&gt; -&gt; &lt;AlphaNumOrDash&gt; &lt;Label&gt;
&lt;AlphaNumOrDash&gt; -&gt; &lt;AlphaNum&gt;
&lt;AlphaNumOrDash&gt; -&gt; -
</pre>
    </div>
    <p class="main-column">
      Nun müssen wir noch Regeln für
      <code>&lt;AlphaNum&gt;</code>
      angeben. Hier führen
      wir eine weitere Konvention ein: nämlich, dass wir verschiedene
      Alternativen mit einem senkrechten Strich | separieren:
    </p>
    <div class="main-column">
<pre>
&lt;AlphaNum&gt; -&gt; a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z
&lt;AlphaNum&gt; -&gt; A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
&lt;AlphaNum&gt; -&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</pre>
    </div>
    <p class="main-column">
      Beachten Sie: ich habe hier absichtlich nicht
      <code>&lt;AlphaNum&gt; *-&gt;* a
        *|* ... *|* z</code>
      geschrieben, weil ich in diesem Beispiel wirklich
      alles ausschreiben wollte und mit der ...-Notation schon wieder
      etwas menschen- aber nicht maschinenlesbares eingeführt hätte. Wir
      brauchen noch Regeln für
      <span class="nowrap"><code>&lt;User&gt;</code>.</span>
      Dies ist ein nichtleerer String
      aus alphanumerischen Zeichen und dem Punkt
      <span class="nowrap"><code>.</code>,</span>
      wobei der Punkt
      nicht am Anfang und nicht am Ende stehen darf. Also: eine
      nichtleere Folge von
      <span class="nowrap"><i>Namensblöcken</i>,</span>
      die jeweils durch
      <code>.</code>
      separiert sind, wobei ein Namensblock eine nichtleere Folge
      alphanumerischer Zeichen ist.
    </p>
    <div class="main-column">
<pre>
&lt;User&gt; -&gt; &lt;NameBlock&gt; | &lt;NameBlock&gt; . &lt;User&gt;
&lt;NameBlock&gt; -&gt; &lt;AlphaNum&gt; | &lt;AlphaNum&gt; &lt;NameBlock&gt;
</pre>
    </div>
    <p class="main-column">
      Nun haben wir unser Emailformat vollständig beschrieben. Das
      gesamte Regelwerk sehen Sie hier noch einmal im Ganzen:
    </p>
    <div
      id="email-context-free-grammar"
      class="main-column"
    >
<pre class="listing">
<span class="listing-bol"></span>&lt;EmailAddress&gt;    -&gt;    &lt;User&gt; @ &lt;Domain&gt;
<span class="listing-bol"></span>&lt;Domain&gt;          -&gt;    &lt;Label&gt; . &lt;Label&gt; | &lt;Label&gt; . &lt;Domain&gt;
<span class="listing-bol"></span>&lt;User&gt;            -&gt;    &lt;NameBlock&gt; | &lt;NameBlock&gt; . &lt;User&gt;
<span class="listing-bol"></span>&lt;NameBlock&gt;       -&gt;    &lt;AlphaNum&gt; | &lt;AlphaNum&gt; &lt;NameBlock&gt;
<span class="listing-bol"></span>&lt;Label&gt;           -&gt;    &lt;AlphaNumOrDash&gt; | &lt;AlphaNumOrDash&gt; &lt;Label&gt;
<span class="listing-bol"></span>&lt;AlphaNumOrDash&gt;  -&gt;    &lt;AlphaNum&gt; | -
<span class="listing-bol"></span>&lt;AlphaNum&gt;        -&gt;    a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z
<span class="listing-bol"></span>&lt;AlphaNum&gt;        -&gt;    A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
</pre>
    </div>
    <h2 class="main-column topic-announcement">
      Ein Beispiel einer formalen Grammatik und einer Ableitung
    </h2>
    <p class="main-column">
      Was Sie hier sehen, nennt man eine
      <span class="nowrap"><i>formale Grammatik</i>.</span>
      Ihre
      Bestandteile sind:
    </p>
    <div class="main-column">
      <ul>
        <li>
          <p>
            Das Alphabet $\Sigma$ aller verwendeten Zeichen, in unserem
            Fall also $\Sigma = \{a,\dots,z,A,\dots,Z,.,-,@\}$ . Wir
            nennen $\Sigma$ die Menge der
            <span class="nowrap"><i>terminalen Symbole</i>.</span>
          </p>
        </li>
        <li>
          <p>
            Eine Menge $N$ abstrakter Symbole, hier
          </p>
          <div class="math-block">
            $$
            N = \{\texttt{&lt;EmailAddress&gt;,&lt;Domain&gt;,&lt;User&gt;,&lt;NameBlock&gt;,&lt;Label&gt;,&lt;AlphaNumOrDash&gt;,&lt;AlphaNum&gt;}\} \ .
            $$
          </div>
          <p>
            Diese Menge nennen wir die
            <span class="nowrap"><i>nichtterminalen Symbole</i>.</span>
            Wir
            verlangen, dass $N \cap \Sigma = \emptyset$ gilt; ein Symbol
            kann also nicht gleichzeitig Terminalsymbol und
            Nichtterminalsymbol sein.
          </p>
        </li>
        <li>
          <p>
            Eine Menge $P$ von Regeln, auch
            <i>Produktionen</i>
            genannt, wobei
            jede Regel die Form $X \rightarrow \alpha$ hat, wobei $\alpha$
            eine beliebig lange endliche Folge von Symbolen in
            $\Sigma \cup N$ ist.
          </p>
        </li>
        <li>
          <p>
            Ein Startsymbol
            <span class="nowrap">$S \in N$,</span>
            das angibt, wo wir mit unserer
            Ableitung beginnen sollen. Im obigen Beispiel sind wir ja an
            Emailadressen interessiert, also ist
            <code>&lt;EmailAddress&gt;</code>
            das
            Startsymbol.
          </p>
        </li>
      </ul>
    </div>
    <p class="main-column">
      Wenn wir nun so eine Grammatik gegeben haben, können wir Wörter
      <span class="nowrap"><i>ableiten</i>;</span>
      das heißt, wir beginnen mit dem Startsymbol und
      ersetzen in jedem Schritt ein nichtterminales Symbol durch die
      rechte Seite einer entsprechenden Regel. Dieser Vorgang ist nicht
      eindeutig und lässt mehrere Möglichkeiten offen; das ist auch gut
      so, denn es soll ja mehr als eine Email-Adresse geben. Hier ist ein
      Beispiel für eine Ableitung basierend auf der obigen Grammatik:
    </p>
    <div class="main-column">
<pre>
&lt;EmailAddress&gt; -&gt; &lt;User&gt;@&lt;Domain&gt;
            -&gt; &lt;NameBlock&gt;.&lt;User&gt;@&lt;Domain&gt;
            -&gt; &lt;NameBlock&gt;.&lt;NameBlock&gt;@&lt;Domain&gt;
            -&gt; &lt;NameBlock&gt;.&lt;NameBlock&gt;@&lt;Label&gt;.&lt;Domain&gt;
            -&gt; &lt;NameBlock&gt;.&lt;NameBlock&gt;@&lt;Label&gt;.&lt;Label&gt;.&lt;Label&gt;
            -&gt; &lt;AlphaNum&gt;.&lt;NameBlock&gt;@&lt;Label&gt;.&lt;Label&gt;.&lt;Label&gt;
            -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;Label&gt;.&lt;Label&gt;.&lt;Label&gt;
            -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;Label&gt;.&lt;Label&gt;
            -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;Label&gt;
            -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;&lt;Label&gt;
            -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;&lt;AlphaNumOrDash&gt;
            -&gt; d.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;&lt;AlphaNumOrDash&gt;
            -&gt; d.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;e
            -&gt; d.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.de
            -&gt; d.s@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.de
            -&gt; d.s@&lt;AlphaNumOrDash&gt;.b.de
            -&gt; d.s@a.b.de
</pre>
    </div>
    <p class="main-column">
      Nach dem gleichen Schema könnten wir
      <code>d.s.@-.-.--</code>
      ableiten, was
      darauf schließen lässt, dass unsere Grammatik nicht wirklich das
      tut, was wir beabsichtigen, dass sie nämlich
      <i>zu viele</i>
      Emailadressen herleitet, auch solche, die wir nicht als zulässige
      Adressen gelten lassen wollen.
    </p>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 5.1</b>
        Formulieren Sie weitere Regeln, um unsinnige Domainnamen wie
        <code>-.-.--</code>
        zu verbieten. Wie müssen Sie die obige Grammatik ändern?
      </p>
    </div>
    <h2 class="main-column topic-announcement">
      Terminologie, formale Definitionen und Beispiele
    </h2>
    <p class="main-column">
      Im letzten Abschnitt haben wir die Regeln für die Bildung
      syntaktisch korrekter Emailadressen formalisiert. Zwar
      unvollständig, doch hoffe ich, dass das allgemeine Schema klar
      geworden ist. Wir werden nun alles formaler und abstrakter
      definieren.
    </p>
    <h3 class="main-column subtopic-announcement">
      Alphabet
    </h3>
    <p class="main-column">
      Wenn wir über formale Sprachen reden, so liegt immer eine
      (endliche) Menge von Symbolen zugrunde, das Alphabet
      <span class="nowrap">$\Sigma$.</span>
      Im
      Emailadressen-Beispiel war (\Sigma) recht groß: die 52 Buchstaben;
      10 Ziffern; die Zeichen
      <code>@ . -</code>
      . Für Java-Programme oder andere
      Programmiersprachen kämen noch weitere Zeichen hinzu, zum Beispiel
      <code>+ - / \ { }</code>
      und so weiter; wenn wir alle Unicode-Zeichen
      miteinschließen, landen wir im Millionenbereich. In den
      theoretischen Beispielen, die in diesem Kurs folgen werden, ist das
      Alphabet fast immer viel kleiner: typische Alphabete zum Beispiel
      sind $\{0,1\}$ , $\{a,b,c,d\}$ oder auch $\{1\}$ , ein Alphabet
      mit nur einem Zeichen. Für ein Alphabet $\Sigma$ bezeichnen wir
      mit  $\Sigma^*$ die Menge aller endlichen Strings über diesem
      Alphabet; das schließt den
      <i>leeren String</i>
      mit ein, den wir mit
      $\epsilon$ bezeichnen. So ist beispielsweise
    </p>
    <div class="math-block main-column">
      $$
      \{a,b\}^* = \{\epsilon, a, b, aa, ab, ba, bb, aaa, aab, aba, ...\}
      $$
    </div>
    <p class="main-column">
      Ein Element
      <span class="nowrap">$x \in \Sigma^*$,</span>
      also einen endlichen String aus
      <span class="nowrap">$\Sigma$-Symbolen,</span>
      bezeichnen wir als
      <span class="nowrap"><i>Wort über $\Sigma$</i>.</span>
      Mit
      $\Sigma^+$ bezeichnen wir die Menge aller nichtleeren Strings,
      also
      <span class="nowrap">$\Sigma^+ = \Sigma^* \setminus \{\epsilon\}$.</span>
    </p>
    <h3 class="main-column subtopic-announcement">
      Sprachen
    </h3>
    <p class="main-column">
      Eine Teilmenge $L \subseteq \Sigma$ bezeichnen wir in diesem
      Kontext als
      <i>Sprache</i>
      und kürzen Sie oft mit $L$ ab, was für
      <i>language</i>
      steht. Beispiele für Sprachen wären
    </p>
    <div class="main-column">
      <ol>
        <li>
          <p>
            Die Sprache aller syntaktisch korrekten Emailadressen.
          </p>
        </li>
        <li>
          <p>
            Die Sprache aller Java-Programme, die ohne Fehlermeldung
            kompilieren
          </p>
        </li>
        <li>
          <p>
            Die Sprache aller Java-Programme, die kompilieren, dann aber
            mit einem Laufzeitfehler abbrechen.
          </p>
        </li>
        <li>
          <p>
            Die Sprache aller Java-Programme, die kompilieren und nicht
            mit einem Laufzeitfehler abbrechen.
          </p>
        </li>
        <li>
          <p>
            Die Sprache aller Wörter über
            <span class="nowrap">$\{a,b\}$,</span>
            die gleich viele
            <span class="nowrap">$a$'s</span>
            wie
            <span class="nowrap">$b$'s</span>
            enthalten.
          </p>
        </li>
        <li>
          <p>
            Die Sprache aller Palindrome über
            <span class="nowrap">$\{a,b,c,d\}$,</span>
            also Wörter,
            die von vorne wie hinten gelesen gleich aussehen.
          </p>
        </li>
      </ol>
    </div>
    <p class="main-column">
      Wir wollen herausfinden, welche Arten von Sprachen wir mit den im
      letzten Abschnitt eingeführen Regelwerk aus Ableitungen beschreiben
      können. Für die gerade aufgelisteten sechs Sprachen lautet die
      Antwort
    </p>
    <div class="main-column">
      <ol>
        <li>
          <p>
            Ja, können wir.
          </p>
        </li>
        <li>
          <p>
            Ja, wenn wir leicht komplexere Ableitungsregeln erlauben.
          </p>
        </li>
        <li>
          <p>
            Ja, wenn wir leicht komplexere Ableitungsregeln erlaubten.
          </p>
        </li>
        <li>
          <p>
            Nein, können wir nicht.
          </p>
        </li>
        <li>
          <p>
            Ja, können wir.
          </p>
        </li>
        <li>
          <p>
            Ja, können wir.
          </p>
        </li>
      </ol>
    </div>
    <h3 class="main-column subtopic-announcement">
      Grammatiken
    </h3>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>5.1</b>
        <b>(Kontextfreie Grammatik).</b>
        Eine
        <i>kontextfreie Grammatik</i>
        besteht aus
      </p>
      <ol>
        <li>
          <p>
            einem endlichen Alphabet
            <span class="nowrap">$\Sigma$,</span>
            den
            <span class="nowrap"><i>terminalen
                Symbolen</i>;</span>
          </p>
        </li>
        <li>
          <p>
            einer dazu disjunkten endlichen Menge
            <span class="nowrap">$N$,</span>
            genannt die
            <span class="nowrap"><i>nichtterminalen Symbole</i>;</span>
          </p>
        </li>
        <li>
          <p>
            einer endlichen Menge $P$ von
            <i>Produktionsregeln</i>
            der Form
            $X \rightarrow \alpha$ mit $X \in N$ und
            <span class="nowrap">$\alpha \in (\Sigma \cup \N)^*$;</span>
            formal also
            <span class="nowrap">$P \subseteq N \times (\Sigma \cup \N)^*$.</span>
          </p>
        </li>
        <li>
          <p>
            einem Startsymbol
            <span class="nowrap">$S \in N$.</span>
          </p>
        </li>
      </ol>
      <p>
        Die Grammatik $G$ ist also ein 4-Tupel
        <span class="nowrap">$(\Sigma, N, P, S)$.</span>
      </p>
    </div>
    <p class="main-column">
      Woher der Name
      <i>kontextfrei</i>
      kommt, werden Sie hoffentlich
      verstehen, wenn wir
      <i>Ableitungen</i>
      definiert haben. Die Tradition
      will es, dass wir für die terminalen Symbole Zahlen oder
      lateinsiche Kleinbuchstaben und für die nichtterminalen Symbole
      lateinische Großbuchstaben verwenden. Dies ist eine Konvention, die
      hilfreich ist, solange wir auf abstrakt-theoretischer Ebene über
      formale Grammatiken sprechen; wenn Sie z.B. eine Grammatik für Java
      erstellen wollen, dann wird $\Sigma$ natürlich auch Großbuchstaben
      enthalten.
    </p>
    <div class="well statement out">
      <p>
        <b>Beispiel</b>
        <b>5.2</b>
        Wir betrachten die Grammatik $G = (\{a,b\}, \{S, A, B\}, P, S)$
        mit den Produktionsregeln
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\rightarrow A B \\
        A&amp;\rightarrow \epsilon \ | \ a A \\
        B&amp;\rightarrow \epsilon \ | \ b B \ . \\
        \end{align*}
        $$
      </div>
      <p>
        Formal sind die Produktionsregeln $P$ eine Teilmenge von
        <span class="nowrap">$N \times (\Sigma \cup \N)^*$,</span>
        also
      </p>
      <div class="math-block">
        $$
        P = \{ (S, AB), (A, \epsilon), (A, aA), (B, \epsilon), (B, bB) \} \ .
        $$
      </div>
      <p>
        Für konkrete Beispiele wie die gerade betrachtete Grammatik
        jedoch verwenden wir einfach die Pfeilschreibweise
        <span class="nowrap">$S \rightarrow AB, \dots$.</span>
        Hier ist eine
        <i>Ableitung</i>
        basierend
        auf der Grammatik:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S \Rightarrow AB \Rightarrow aAB \Rightarrow aAbB \Rightarrow aAbbB
        \Rightarrow aAbb \Rightarrow abb \ .
        \end{align*}
        $$
      </div>
      <p>
        In jedem Schritt wählen wir ein Nichtterminal aus, zum Beispiel
        im zweiten Schritt
        <span class="nowrap">$A$,</span>
        und wenden eine Regel an, zum Beispiel
        <span class="nowrap">$A \rightarrow aA$.</span>
        Dadurch wird $AB$ zu
        <span class="nowrap">$aAB$.</span>
        Wir setzen diese
        Ableitungsschritte so lange fort, bis nur noch terminale Symbole
        übrigbleiben. Dann hat sich ein Wort $\alpha \in \Sigma^*$
        ergeben.
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>5.3</b>
        Gegeben sei eine kontextfreie Grammatik
        <span class="nowrap">$G = (\Sigma, N, P, S)$.</span>
        Ein String $\alpha \in (\Sigma \cup N)^*$ heißt
        <i>Wortform</i>
        (im
        Gegensatz zu einem Wort
        <span class="nowrap">$x \in \Sigma^*)$.</span>
        Für zwei Wortformen
        $\alpha , \beta$ schreiben wir
      </p>
      <div class="math-block">
        $$
        \alpha \Rightarrow \beta
        $$
      </div>
      <p>
        wenn wir $\alpha$ zu $\beta$ machen können, indem wir ein
        nichtterminales Symbol $X$ in $\alpha$ durch die rechte Seite
        $X \rightarrow \gamma$ ersetzen können. Formal gesprochen, wenn
        wir $\alpha = \alpha_1 X \alpha_2$ und
        $\beta = \beta_1 \gamma \beta_2$ mit Wortformen
        $\alpha_1, \alpha_2, \beta_1, \gamma, \beta_2$ und einem
        Nichtterminal $X$ schreiben können, so dass
        $X \rightarrow \gamma$ eine Produktionsregel in $P$ ist. Wenn
        wir $\alpha = \beta$ "vorlesen", dann sagen wir _ $\beta$ kann
        aus $\alpha$ in einem Schritt abgeleitet werden_. Wenn $\beta$
        aus $\alpha$ in mehreren (im Extremfall null) Schritten
        abgeleitet werden kann, so schreiben wir
        <span class="nowrap">$\alpha \Rightarrow^* \beta$.</span>
        Formal bedeutet
        <span class="nowrap">$\alpha \Rightarrow^* \beta$,</span>
        dass es ein $k \geq 0$ gibt und
        "Zwischenwortformen" $\alpha_0, \alpha_1, \dots, \alpha_k$ mit
        $\alpha = \alpha_0$ und
        <span class="nowrap">$\alpha_k = \beta$,</span>
        sodass
        $\alpha_i \Rightarrow \alpha_{i+1}$ für alle
        $i = 0, 1, \dots, k-1$ gilt. Dies schließt den "trivialen" Fall
        $k=0$ mit ein, in welchem $\alpha = \beta$ gilt.
      </p>
    </div>
    <p class="main-column">
      Nochmals: wenn $\alpha$ die Form $\alpha_1 X \alpha_2$ hat, dann
      dürfen Sie das Nichtterminal $X$ durch die rechte Seite einer
      Produktionsregel $X \rightarrow \gamma$ ersetzen; Sie dürfen das
      unabhängig von dem
      <span class="nowrap"><i>Kontext</i>,</span>
      in welchem $X$ in der Wortform
      $\alpha$ vorkommt. Daher rührt der Name
      <span class="nowrap"><i>kontextfreie Grammatik</i>.</span>
      Beachten Sie, dass $P$ per Definition eine
      <i>endliche Menge</i>
      von
      Regeln sein muss, dass jedoch $\Rightarrow$ im Allgemeinen
      unendlich ist. Bereits für unsere einfache Grammatik mit den
      Produktionsregeln
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      S&amp;\rightarrow A B \\
      A&amp;\rightarrow \epsilon \ | \ a A \\
      B&amp;\rightarrow \epsilon \ | \ b B \ . \\
      \end{align*}
      $$
    </div>
    <p class="main-column">
      haben wir beispielsweise
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      A&amp;\rightarrow aA \\
      aA&amp;\rightarrow aaA \\
      aaA&amp;\rightarrow aaaA \\
      \dots
      \end{align*}
      $$
    </div>
    <p class="main-column">
      und sehen, dass die Menge aller Paare $\alpha \Rightarrow \beta$
      unendlich ist.
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>5.4</b>
        <b>(Die von einer Grammatik erzeugte Sprache).</b>
        Sei
        $G = (\Sigma, N, P, S)$ eine kontextfreie Grammatik. Die von $G$
        erzeugte Sprache $L(G)$ ist die Menge aller Wörter, die vom
        Startsymbol $S$ abgeleitet werden können, also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        L(G) := \{x \in \Sigma^* \ | \ S \Rightarrow^* x\} \ .
        \end{align*}
        $$
      </div>
      <p>
        Wenn es zu einer Sprache $L \subseteq \Sigma^*$ eine
        kontextfreie Grammatik $G$ mit $L(G) = L$ gibt, so nennen wir $L$
        eine
        <span class="nowrap"><i>kontextfreie Sprache</i>.</span>
        Beachten Sie, dass in dem obigen
        Beispiel die Wortform $aaAB$ zwar aus $S$ abgeleitet werden
        kann, allerdings kein
        <i>Wort</i>
        ist, da es noch nichtterminale
        Symbole enthält. Es gilt also
        <span class="nowrap">$aaAB \not \in L(G)$.</span>
        Oft können
        wir $L(G)$ kompakt mit natürlicher Sprache beschreiben:
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Beispiel</b>
        <b>5.5</b>
        Sei $G$ die zuletzt betrachtete Grammatik. Dann ist $L(G)$ die
        Menge aller Wörter der Form
        <span class="nowrap">$a^* b^*$,</span>
        also Wörter, in denen auf
        beliebig viele
        <span class="nowrap">$a$'s</span>
        beliebig viele
        <span class="nowrap">$b$'s</span>
        folgen.
      </p>
    </div>
    <p class="main-column">
      Wir betrachten nun einige weitere Beispiele
    </p>
    <div class="well statement out">
      <p>
        <b>Beispiel</b>
        <b>5.6</b>
        Wir betrachten die Grammatik $G_2 = (\{a,b\}, \{S\}, P, S)$ mit
        den Produktionsregeln
      </p>
      <div class="math-block">
        $$
        \begin{align}
        S&amp;\rightarrow aSbS \\
        S&amp;\rightarrow bSaS \\
        S&amp;\rightarrow \epsilon \ .
        \end{align}
        $$
      </div>
      <p>
        Hier sind mögliche Ableitungen des Wortes
        <span class="nowrap">$abab$.</span>
        Zur
        Verdeutlichung schreiben wir über den Pfeil $\Rightarrow$ die
        Nummer der Regel, die wir angewendet haben:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\stackrel{(1)}{\Rightarrow} aSbS
        \stackrel{(1)}{\Rightarrow} aSbaSbS
        \stackrel{(3)}{\Rightarrow} aSbaSb
        \stackrel{(3)}{\Rightarrow} abaSb
        \stackrel{(3)}{\Rightarrow} abab \\
        S&amp;\stackrel{(1)}{\Rightarrow} aSbS
        \stackrel{(3)}{\Rightarrow} abS
        \stackrel{(1)}{\Rightarrow} abaSbS
        \stackrel{(3)}{\Rightarrow} ababS
        \stackrel{(3)}{\Rightarrow} abab \ .
        \end{align*}
        $$
      </div>
      <p>
        Wir sehen also: das gleiche Wort kann mehrere Ableitungen haben.
        Da die Ersetzungsregeln
        <i>kontextfrei</i>
        sind, spielt es keine
        Rolle, in welcher Reihenfolge wir nichtterminale Symbole
        ersetzen. Wenn Sie scharf hinschauen, werden Sie erkennen, dass
        die beiden Ableitungen "irgendwie gleich" sind, dass nur die
        Ableitungen in anderer Reihenfolge durchgeführt worden sind. Ich
        werde das in einem späteren Kapitel formal definieren, was ich
        mit damit meine. Um Ordnung in das Chaos zu bringen, könnten wir
        uns zum Beispiel einigen, dass man immer das am weitesten links
        stehende Nichtterminal ersetzen muss. Das nennt man eine
        <span class="nowrap"><i>Linksableitung</i>.</span>
        Dies ist nicht wirklich eine Einschränkung, da
        die Ersetzungsreihenfolge keine Rolle spielt. Wir sehen, dass die
        zweite Ableitung des Wortes $abab$ oben eine Linksableitung ist;
        zusammen mit der Beschriftung
        <span class="nowrap">$\stackrel{(i)}{\Rightarrow}$,</span>
        die
        die Nummer der angewendeten Regel angibt, ist eindeutig, wie wir
        von $S$ zum abgeleiteten Wort gekommen sind. Betrachten Sie nun
        eine weitere Linksableitung
        <span class="nowrap">$S \Rightarrow^* abab$:</span>
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\stackrel{(1)}{\Rightarrow} aSbS
        \stackrel{(2)}{\Rightarrow} abSaSbS
        \stackrel{(3)}{\Rightarrow} abaSbS
        \stackrel{(3)}{\Rightarrow} ababS
        \stackrel{(3)}{\Rightarrow} abab
        \end{align*}
        $$
      </div>
      <p>
        Sehen Sie, dass diese Ableitung
        <i>qualitativ</i>
        anders ist, da wir
        hier auch die Regel $S \rightarrow bSaS$ angewendet haben? Um
        die Struktur der Ableitung zu verdeutlichen, könnten wir die
        ersten beiden Ableitungen mit Wort $S \Rightarrow^* (ab)(ab)$
        bezeichnen und die dritte mit Wort
        <span class="nowrap">$S \Rightarrow^* a(ba)b$.</span>
      </p>
    </div>
    <h2 class="main-column topic-announcement">
      Ziele der Theorie der formalen Sprachen
    </h2>
    <p class="main-column">
      Ganz allgemein gesagt wollen wir lernen, wie wir Sprachen formal
      beschreiben können; wie wir, gegeben eine Grammatik $G$ und ein
      Zielwort
      <span class="nowrap">$x$,</span>
      eine Ableitung $G \Rightarrow^* x$ finden können.
      Anhand der Ableitungssequenz können wir dann oft auf die logische
      Struktur von $x$ schließen. Handelt es sich bei $G$ zum Beispiel
      um eine Grammatik für die Programmiersprache Java, so wäre ein
      Ziel, aus der Ableitungssequenz $G \Rightarrow^* x$ die Struktur
      des Programms
      <span class="nowrap">$x$,</span>
      also Klassenstruktur, Methoden, etc., ablesen
      zu können und schlussendlich das Programm in ausführbaren
      Maschinencode kompilieren zu können.
    </p>
    <div class="well statement out">
      <p>
        <b>Algorithmisches Problem: Parsing</b>
        <b>5.7</b>
        Gegeben eine (kontextfreie) Grammatik $G$ und ein Zielwort $x$ ,
        finde eine Ableitung
        <span class="nowrap">$G \Rightarrow^* x$,</span>
        falls es so eine gibt.
        Für einen String $x$ eine Ableitung zu finden bezeichnen wir als
        <span class="nowrap"><i>parsen</i>,</span>
        das zugehörige Hauptwort als
        <span class="nowrap"><i>Parsing</i>.</span>
      </p>
    </div>
    <p class="main-column">
      <b>Die gute Nachricht:</b>
      Die gute Nachricht: wir kennen Algorithmen,
      die dieses Problem im effizient lösen, wenn wir den "theoretischen"
      Effizienzbegriff zugrund legen.
    </p>
    <p class="main-column">
      <b>Die schlechte Nachricht:</b>
      wir kennen keinen Algorithmus, der das
      Parsing kontextfreier Sprachen in seiner ganzen Allgemeinheit in
      <i>linearer Zeit</i>
      erledigt, dessen Laufzeit also proportional zur
      Länge des Zielwortes $x$ ist. Dies ist aber, was wir in der
      Praxis, zum Beispiel bei Compilern, erwarten.
    </p>
    <p class="main-column">
      <b>Die gute Nachricht:</b>
      in fast allen praktisch relevanten Fällen
      haben wir es mit Grammatiken zu tun, die Parsing in linearer Zeit
      ermöglichen. Und wenn wir Programmiersprachen, Datenformate etc.
      entwerfen, haben wir es ja in der Hand, Sprache und Grammatik so
      anzulegen, dass effizientes Parsen möglich ist. Im nächsten Kapitel
      lernen wir eine stark eingeschränkte, aber dennoch sehr wichtige
      Klasse kontextfreier Grammatik kennen, die allesamt ein sehr
      effizientes Parsing erlauben: die sogenannten
      <i>regulären</i>
      Grammatiken.
    </p>
    <div id="end-of-page-elt">
    </div>
    <div id="bottom-menu">
      <div id="bottom-menu-left">
        <a href="./4-4.html">&lt;&lt; Kapitel 4.4<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >Ein Schritt weiter:  while-Schleifen und
            <span class="nowrap">$\mu$-Rekursion</span></span></a>
      </div>
      <div id="bottom-menu-right">
        <a href="./5-1.html">Kapitel 5.1 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >Reguläre Grammatiken</span></a>
      </div>
    </div>
  </div>
</body>
</html>
