<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Chapter 5 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="ti3.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./ti3.js"></script>
  <title>TI3 - Chapter 5</title>
</head>
<body class="page-chapter chapter-5">
  <div
    path="/5-0.html"
    class="chapter"
  >
    <div class="menu">
      <div class="menu-left">
        <a href="./index.html">Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./4-4.html"
        >&lt;&lt; Kapitel 4.4</a>
      </div>
      <div class="menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./5-1.html"
        >Kapitel 5.1  &gt;&gt;</a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        5. 
        Reguläre Sprachen
      </p>
    </div>
    <p class="main-column">
      Hier sehen Sie einige Beispiele für gültige und ungültige
      Email-Adressen. Mit
      <i>gültig</i>
      meine ich, dass sie syntaktisch
      korrekt sind, ungeachtet, ob ein Konto mit dieser Email-Adresse
      besteht.
    </p>
    <div
      style="padding-left: 0.2rem"
      class="well highlight out"
    >
<pre>
thomas.schmitz@hszg.de                              <span class="comment">Gültig</span><br>dominik@cs.sjtu.edu.cn                              <span class="comment">Gültig</span><br>raffaela@mayer@gmail.com                            <span class="comment">Ungültig: @ kommt zweimal vor</span><br>lorenz.klein@greatest/company/in/the/world.com      <span class="comment">Ungültig: Domain-Name darf kein / enthalten</span><br>.schlaumeier@gmail.com                              <span class="comment">Ungültig: Google will kein . an erster Stelle</span>
</pre>
    </div>
    <p class="main-column">
      Hier sehen Sie den Teil eines HTML-Dokuments. Beachten
      Sie die typische hierarchisch-geschachtelte Struktur
      (sie müssen es nicht im Detail lesen):
    </p>
    <div class="well highlight out">
<pre class="listing">
<span>&lt;div class='carousel-inner' style='display:inline-block'&gt;</span><br><span>   &lt;div class='item active'&gt;</span><br><span>       <span class="nowrap">&lt;p&gt;$110 x + 794$&lt;/p&gt;&lt;img</span> loading="lazy" src='../img/hash/hashfunction_110_794.svg'&gt;</span><br><span>   &lt;/div&gt;</span><br><span>   &lt;div class='item'&gt;</span><br><span>       <span class="nowrap">&lt;p&gt;$502 x + 121$&lt;/p&gt;&lt;img</span> loading="lazy" src='../img/hash/hashfunction_502_121.svg'&gt;</span><br><span>    &lt;/div&gt;</span><br><span>   &lt;div class='item'&gt;</span><br><span>       <span class="nowrap">&lt;p&gt;$617 x + 5$&lt;/p&gt;&lt;img</span> loading="lazy" src='../img/hash/hashfunction_617_5.svg'&gt;</span><br><span>   &lt;/div&gt;</span><br><span>   &lt;div class='item'&gt;</span><br><span>       <span class="nowrap">&lt;p&gt;$815 x + 562$&lt;/p&gt;&lt;img</span> loading="lazy" src='../img/hash/hashfunction_851_562.svg'&gt;</span><br><span>   &lt;/div&gt;</span><br><span>   &lt;div class='item'&gt;</span><br><span>       <span class="nowrap">&lt;p&gt;$868 x + 858$&lt;/p&gt;&lt;img</span> loading="lazy" src='../img/hash/hashfunction_868_858.svg'&gt;</span><br><span>   &lt;/div&gt;</span><br><span>   &lt;div class='item'&gt;</span><br><span>       <span class="nowrap">&lt;p&gt;$915 x + 320$&lt;/p&gt;&lt;img</span> loading="lazy" src='../img/hash/hashfunction_915_320.svg'&gt;</span><br><span>   &lt;/div&gt;</span><br><span>&lt;/div class='carousel-inner'&gt; </span>
</pre>
    </div>
    <p class="main-column">
      Hier sehen Sie einen Ausschnitt aus einem Elm-Programm
      (auch diesen müssen Sie nicht im Detail lesen):
    </p>
    <div class="well highlight out">
<pre class="listing numbered-pre">
find : Bst -&gt; String -&gt; Maybe String
find tree key =
   case tree of
       Empty _ -&gt;
           Nothing
       Node ( keyHere, valueHere ) leftChild rightChild -&gt;
           if key == keyHere then
               Just valueHere
           else if key&lt; keyHere then
               find leftChild key
           else
               find rightChild key
</pre>
    </div>
    <p class="main-column">
      Als letztes Beispiel sehen Sie hier eine svg-Datei.
      Dies ist ein Dateiformat für Vektorgrafiken. In diesem
      Falle ein Kreis mit einer Geraden:
    </p>
    <figure class="main-column">
      <img
        style="height:4em"
        src="./img/svg-example.svg"
        class="constrained transition-all"
        onClick="onImgClick(event)"
      >
    </figure>
    <div class="well highlight out">
<pre class="listing">
<span>&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span>&lt;svg xmlns="http://www.w3.org/2000/svg" </span><br><span>   xmlns:xlink="http://www.w3.org/1999/xlink" </span><br><span>   width="102pt" height="102pt"</span><br><span>   viewBox="0 0 102 102"</span><br><span>   version="1.1"&gt;</span><br><span>&lt;g id="surface2322"&gt;</span><br><span>&lt;circle style="fill:none;stroke-width:0.4;stroke:rgba(0,0,0,100);"</span><br><span>   cx="51" cy="51" r="40"/&gt;</span><br><span>&lt;path style="fill:none;stroke-width:0.4;stroke:rgba(0,0,0,100);"</span><br><span>   d="M 50 50 l 33.5 -22.5"/&gt;</span><br><span>&lt;/g&gt;</span><br><span>&lt;/svg&gt;</span>
</pre>
    </div>
    <p class="main-column">
      Was haben diese vier Beispiele gemeinsam? Es handelt
      sich in allen Fällen um
      <i>Daten</i>, die in einem bestimmten
      festgelegten
      <i>Format</i>
      dargelegt werden. Soll ein Rechner
      etwas sinnvolles damit anfangen (zum Beispiel das Elm-Programm
      starten oder die HTML-Seite oder die Svg-Datei auf
      dem Bildschirm darstellen), muss er dieses Format erst
      einmal "verstehen", also den bloßen String aus ASCII-Zeichen
      umwandeln in eine logisch sinnvolle Struktur. Und genau
      darum geht es in den Formalen Sprachen: wir wollen
      Begriffe, Regeln, Methoden, Algorithmen entwickeln,
      um Daten, die in einem bestimmten Format vorliegen,
      zu verarbeiten; ja auch erst einmal überhaupt Begriffe
      festlegen, wie man solche Formate definiert.
    </p>
    <h1 class="main-column">
      Korrekte Email-Adressen
    </h1>
    <p class="main-column">
      Kommen wir auf unser erstes, einfachstes Beispiel
      zurück: die Email-Adressen. Können Sie möglichst präzise
      und möglichst formal beschreiben, wie eine korrekte
      Email-Adresse auszusehen hat? Hier versuche ich es
      einmal:
    </p>
    <div class="well highlight out">
      <p>
        Eine Emailadresse besteht aus einem
        <i>Benutzernamen</i>
        und einem
        <i>Domainnamen</i>, die mit einem
        <code>@</code>
        verbunden
        sind. Der Benutzername ist ein nichtleerer String bestehend
        aus Groß- und Kleinbuchstaben, Zahlen, und Punkten
        (<code>.</code>). Erster und letzter Buchstaben dürfen keine Punkte
        sein, außerdem dürfen keine zwei Punkte nebeneinander
        stehen. Der Domainname ist eine Folge von mindestenes
        zwei
        <i>Labels</i>, die jeweils mit einem
        <code>.</code>
        separiert
        sind. Ein Label ist ein nichtleerer String aus Groß-
        und Kleinbuchstaben, Zahlen und dem Bindestrich (<code>-</code>).
      </p>
    </div>
    <p class="main-column">
      Die genauen Regeln mögen von Anbieter zu Anbieter
      variieren; ich habe mich mal an das gehalten, was ich
      experimentell bei
      <code>gmail.com</code>
      herausgefunden habe.
      Die obige Beschreibung ist (hoffentlich) verständlich
      und präzise und unzweideutig. Allerdings ist sie in
      natürlicher Sprache verfasst; es ist beispielsweise
      nicht klar, wie ein Rechner aus der obigen Beschreibung
      einen Algorithmus konstruieren kann, der Korrektheit
      einer Email-Adresse überprüft. Außerdem schleichen
      sich bei natürlicher Sprache schnell Zweideutigkeiten
      ein, die a priori nicht immer zu erkennen sind. Wir
      wollen daher ein formales Regelwerk erstellen, wie
      wir Formate dieser Art vollständig und eindeutig beschreiben
      können. Ich werde dies nun Schritt für Schritt entwickeln,
      erst informell anhand des Email-Adressen-Beispiels
      und dann, im nächsten Kapitel, formal und abstrakt.
      Eine Emailadresse ist von der Form
      <i>Benutzername</i>`@`<i>Domainnname</i>.
      Dies können wir als
      <i>Ableitungsregel</i>
      darstellen:
    </p>
    <div class="well highlight out">
<pre>
&lt;EmailAdress&gt; -&gt; &lt;User&gt; @ &lt;Domain&gt;
</pre>
    </div>
    <p class="main-column">
      Wie können wir nun beispielsweise eine ähnliche Ableitungsregeln
      für
      <code>&lt;Domain&gt;</code>
      erstellen? Eine
      <code>&lt;Domain&gt;</code>
      soll eine Folge aus mindestens zwei
      <code>&lt;Label&gt;</code>
      sein, jeweils durch einen
      <code>.</code>
      separiert. Wir erreichen
      dies, indem wir einen an Rekursion erinnernden Trick
      anwenden: entweder gibt es genau zwei Labels oder die
      Domain beginnt mit einem Label, gefolgt von einem Punkt
      und wiederum einer
      <i>Folge von mindestens zwei durch
        <code>.</code>
        separierten Labels</i>, also wiederum etwas, das wie
      ein Domainname aussieht. Daher:
    </p>
    <div class="well highlight out">
<pre>
&lt;Domain&gt; -&gt; &lt;Label&gt; . &lt;Label&gt;
&lt;Domain&gt; -&gt; &lt;Label&gt; . &lt;Domain&gt;
</pre>
    </div>
    <p class="main-column">
      Wir geben also
      <i>zwei</i>
      Möglichkeiten an, wie mit einem
      <code>&lt;Domain&gt;</code>
      zu verfahren ist. Was ist nun
      <code>&lt;Label&gt;</code>?
      Dies ist eine nichtleere Folge von in Domainnamen erlaubten
      Zeichen. Diese sind alphanumerisch (Buchstaben und
      Zahlen) und der Strich
      <code>-</code>
      (in der Praxis sind eventuell
      noch weitere Zeichen erlaubt; im Ernstfall hängt dies
      davon ab, was die Domain Name Server des jeweiligen
      Landes / der jeweiligen Top-Level-Domain erlauben,
      siehe zum Beispiel
      <a href="https://en.wikipedia.org/wiki/Internationalized_domain_name">Wikipedia: Internationalized Domain Name</a>). Wie formulieren wir
      <i>nichtleere Folge von ...</i>
      mit unserer
      <code>--&gt;</code>-Notation? Wieder mit dem Rekursionstrick:
    </p>
    <div class="well highlight out">
<pre>
&lt;Label&gt; -&gt; &lt;AlphaNumOrDash&gt;
&lt;Label&gt; -&gt; &lt;AlphaNumOrDash&gt; &lt;Label&gt;
&lt;AlphaNumOrDash&gt; -&gt; &lt;AlphaNum&gt;
&lt;AlphaNumOrDash&gt; -&gt; -
</pre>
    </div>
    <p class="main-column">
      Nun müssen wir noch Regeln für
      <code>&lt;AlphaNum&gt;</code>
      angeben. Hier führen wir eine weitere Konvention ein:
      nämlich, dass wir verschiedene Alternativen mit einem
      senkrechten Strich | separieren:
    </p>
    <div class="well highlight out">
<pre>
&lt;AlphaNum&gt; -&gt; a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z
&lt;AlphaNum&gt; -&gt; A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z
&lt;AlphaNum&gt; -&gt; 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
</pre>
    </div>
    <p class="main-column">
      Beachten Sie: ich habe hier absichtlich nicht
      <code>&lt;AlphaNum&gt;
        *-&gt;* a *|* ... *|* z</code>
      geschrieben, weil ich in diesem
      Beispiel wirklich alles ausschreiben wollte und mit
      der ...-Notation schon wieder etwas menschen- aber
      nicht maschinenlesbares eingeführt hätte.
      Wir brauchen noch Regeln für
      <code>&lt;User&gt;</code>. Dies
      ist ein nichtleerer String aus alphanumerischen Zeichen
      und dem Punkt
      <code>.</code>, wobei der Punkt nicht am Anfang
      und nicht am Ende stehen darf. Also: eine nichtleere
      Folge von
      <i>Namensblöcken</i>, die jeweils durch
      <code>.</code>
      separiert
      sind, wobei ein Namensblock eine nichtleere Folge alphanumerischer
      Zeichen ist.
    </p>
    <div class="well highlight out">
<pre>
&lt;User&gt; -&gt; &lt;NameBlock&gt; | &lt;NameBlock&gt; . &lt;User&gt;
&lt;NameBlock&gt; -&gt; &lt;AlphaNum&gt; | &lt;AlphaNum&gt; &lt;NameBlock&gt;
</pre>
    </div>
    <p class="main-column">
      Nun haben wir unser Emailformat vollständig beschrieben.
      Das gesamte Regelwerk sehen Sie hier noch einmal im
      Ganzen:
    </p>
    <div class="well highlight out">
<pre class="listing">
<span>&lt;EmailAddress&gt;    -&gt;    &lt;User&gt; @ &lt;Domain&gt;</span><br><span>&lt;Domain&gt;          -&gt;    &lt;Label&gt; . &lt;Label&gt; | &lt;Label&gt; . &lt;Domain&gt;</span><br><span>&lt;User&gt;            -&gt;    &lt;NameBlock&gt; | &lt;NameBlock&gt; . &lt;User&gt;</span><br><span>&lt;NameBlock&gt;       -&gt;    &lt;AlphaNum&gt; | &lt;AlphaNum&gt; &lt;NameBlock&gt;</span><br><span>&lt;Label&gt;           -&gt;    &lt;AlphaNumOrDash&gt; | &lt;AlphaNumOrDash&gt; &lt;Label&gt;</span><br><span>&lt;AlphaNumOrDash&gt;  -&gt;    &lt;AlphaNum&gt; | - </span><br><span>&lt;AlphaNum&gt;        -&gt;    a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z</span><br><span>&lt;AlphaNum&gt;        -&gt;    A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z</span>
</pre>
    </div>
    <h1 class="main-column">
      Ein Beispiel einer formalen Grammatik und einer Ableitung
    </h1>
    <p class="main-column">
      Was Sie hier sehen, nennt man eine
      <i>formale Grammatik</i>.
      Ihre Bestandteile sind:
    </p>
    <ul class="main-column">
      <li>
        <p>
          Das Alphabet $\Sigma$ aller verwendeten Zeichen, in
          unserem Fall also
          <span class="nowrap">$\Sigma = \{a,\dots,z,A,\dots,Z,.,-,@\}$.</span>
          Wir nennen 
          $\Sigma$ die Menge der
          <i>terminalen Symbole</i>.
        </p>
      </li>
      <li>
        <p>
          Eine Menge $N$ abstrakter Symbole, hier
        </p>
        <div class="math-block">
          $$
          N = \{\texttt{&lt;EmailAddress&gt;,&lt;Domain&gt;,
          &lt;User&gt;,&lt;NameBlock&gt;,&lt;Label&gt;,&lt;AlphaNumOrDash&gt;,&lt;AlphaNum&gt;}
          \} \ .
          $$
        </div>
        <p>
          Diese Menge nennen wir die
          <i>nichtterminalen Symbole</i>.
          Wir verlangen, dass $N \cap \Sigma = \emptyset$ gilt;
          ein Symbol kann also nicht gleichzeitig Terminalsymbol
          und Nichtterminalsymbol sein.
        </p>
      </li>
      <li>
        <p>
          Eine Menge $P$ von Regeln, auch
          <i>Produktionen</i>
          genannt,
          wobei jede Regel die Form $X \rightarrow \alpha$ hat,
          wobei $\alpha$ eine beliebig lange endliche Folge
          von Symbolen in $\Sigma \cup N$ ist.
        </p>
      </li>
      <li>
        <p>
          Ein Startsymbol
          <span class="nowrap">$S \in N$,</span>
          das angibt, wo wir mit
          unserer Ableitung beginnen sollen. Im obigen Beispiel
          sind wir ja an Emailadressen interessiert, also ist
          <code>&lt;EmailAddress&gt;</code>
          das Startsymbol.
        </p>
      </li>
    </ul>
    <p class="main-column">
      Wenn wir nun so eine Grammatik gegeben haben, können
      wir Wörter
      <i>ableiten</i>; das heißt, wir beginnen mit
      dem Startsymbol und ersetzen in jedem Schritt ein nichtterminales
      Symbol durch die rechte Seite einer entsprechenden
      Regel. Dieser Vorgang ist nicht eindeutig und lässt
      mehrere Möglichkeiten offen; das ist auch gut so, denn
      es soll ja mehr als eine Email-Adresse geben. Hier
      ist ein Beispiel für eine Ableitung basierend auf der
      obigen Grammatik:
    </p>
    <div class="well highlight out">
<pre>
<span>&lt;EmailAddress&gt; -&gt; &lt;User&gt;@&lt;Domain&gt;</span><br><span>               -&gt; &lt;NameBlock&gt;.&lt;User&gt;@&lt;Domain&gt;</span><br><span>               -&gt; &lt;NameBlock&gt;.&lt;NameBlock&gt;@&lt;Domain&gt;</span><br><span>               -&gt; &lt;NameBlock&gt;.&lt;NameBlock&gt;@&lt;Label&gt;.&lt;Domain&gt;</span><br><span>               -&gt; &lt;NameBlock&gt;.&lt;NameBlock&gt;@&lt;Label&gt;.&lt;Label&gt;.&lt;Label&gt;</span><br><span>               -&gt; &lt;AlphaNum&gt;.&lt;NameBlock&gt;@&lt;Label&gt;.&lt;Label&gt;.&lt;Label&gt;</span><br><span>               -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;Label&gt;.&lt;Label&gt;.&lt;Label&gt;</span><br><span>               -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;Label&gt;.&lt;Label&gt;</span><br><span>               -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;Label&gt;</span><br><span>               -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;&lt;Label&gt;</span><br><span>               -&gt; &lt;AlphaNum&gt;.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;&lt;AlphaNumOrDash&gt;</span><br><span>               -&gt; d.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;&lt;AlphaNumOrDash&gt;</span><br><span>               -&gt; d.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;e</span><br><span>               -&gt; d.&lt;AlphaNum&gt;@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.de</span><br><span>               -&gt; d.s@&lt;AlphaNumOrDash&gt;.&lt;AlphaNumOrDash&gt;.de</span><br><span>               -&gt; d.s@&lt;AlphaNumOrDash&gt;.b.de</span><br><span>               -&gt; d.s@a.b.de</span>
</pre>
    </div>
    <p class="main-column">
      Nach dem gleichen Schema könnten wir
      <code>d.s.@-.-.--</code>
      ableiten, was darauf schließen lässt, dass unsere Grammatik
      nicht wirklich das tut, was wir beabsichtigen, dass
      sie nämlich
      <i>zu viele</i>
      Emailadressen herleitet, auch
      solche, die wir nicht als zulässige Adressen gelten
      lassen wollen.
    </p>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 5.1</b>
        Formulieren Sie weitere Regeln, um unsinnige Domainnamen
        wie
        <code>-.-.--</code>
        zu verbieten. Wie müssen Sie die obige
        Grammatik ändern?
      </p>
    </div>
    <h1 class="main-column">
      Terminologie, formale Definitionen und Beispiele
    </h1>
    <p class="main-column">
      Im letzten Abschnitt haben wir die Regeln für die
      Bildung syntaktisch korrekter Emailadressen formalisiert.
      Zwar unvollständig, doch hoffe ich, dass das allgemeine
      Schema klar geworden ist. Wir werden nun alles formaler
      und abstrakter definieren.
    </p>
    <h2 class="main-column">
      Alphabet
    </h2>
    <p class="main-column">
      Wenn wir über formale Sprachen reden, so liegt immer
      eine (endliche) Menge von Symbolen zugrunde, das Alphabet
      <span class="nowrap">$\Sigma$.</span>
      Im Emailadressen-Beispiel war (\Sigma) recht
      groß: die 52 Buchstaben; 10 Ziffern; die Zeichen
      <code>@
        . -</code>
      . Für Java-Programme oder andere Programmiersprachen
      kämen noch weitere Zeichen hinzu, zum Beispiel
      <code>+ -
        / \ { }</code>
      und so weiter; wenn wir alle Unicode-Zeichen miteinschließen,
      landen wir im Millionenbereich. In den theoretischen
      Beispielen, die in diesem Kurs folgen werden, ist das
      Alphabet fast immer viel kleiner: typische Alphabete
      zum Beispiel sind $ \{0,1\}$ , $\{a,b,c,d\}$ oder
      auch
      <span class="nowrap">$\{1\}$,</span>
      ein Alphabet mit nur einem Zeichen.
      Für ein Alphabet $\Sigma$ bezeichnen wir mit 
      $\Sigma^*$ die Menge aller endlichen Strings über
      diesem Alphabet; das schließt den
      <i>leeren String</i>
      mit
      ein, den wir mit $\epsilon$ bezeichnen. So ist beispielsweise
    </p>
    <div class="math-block main-column">
      $$
      \{a,b\}^* = \{\epsilon, a, b, aa, ab, ba, bb, aaa, aab, aba, ...\}
      $$
    </div>
    <p class="main-column">
      Ein Element
      <span class="nowrap">$x \in \Sigma^*$,</span>
      also einen endlichen
      String aus
      <span class="nowrap">$\Sigma$-Symbolen,</span>
      bezeichnen wir als
      <i>Wort
        über $\Sigma$</i>. Mit $\Sigma^+$ bezeichnen wir die
      Menge aller nichtleeren Strings, also
      <span class="nowrap">$\Sigma^+ = \Sigma^* \setminus \{\epsilon\}$.</span>
      
    </p>
    <h2 class="main-column">
      Sprachen
    </h2>
    <p class="main-column">
      Eine Teilmenge $L \subseteq \Sigma$ bezeichnen wir
      in diesem Kontext als
      <i>Sprache</i>
      und kürzen Sie oft
      mit $L$ ab, was für
      <i>language</i>
      steht. Beispiele für
      Sprachen wären
    </p>
    <ol class="main-column">
      <li>
        <p>
          Die Sprache aller syntaktisch korrekten Emailadressen.
        </p>
      </li>
      <li>
        <p>
          Die Sprache aller Java-Programme, die ohne Fehlermeldung
          kompilieren
        </p>
      </li>
      <li>
        <p>
          Die Sprache aller Java-Programme, die kompilieren,
          dann aber mit einem Laufzeitfehler abbrechen.
        </p>
      </li>
      <li>
        <p>
          Die Sprache aller Java-Programme, die kompilieren
          und nicht mit einem Laufzeitfehler abbrechen.
        </p>
      </li>
      <li>
        <p>
          Die Sprache aller Wörter über
          <span class="nowrap">$\{a,b\}$,</span>
          die gleich
          viele
          <span class="nowrap">$a$'s</span>
          wie
          <span class="nowrap">$b$'s</span>
          enthalten.
        </p>
      </li>
      <li>
        <p>
          Die Sprache aller Palindrome über
          <span class="nowrap">$\{a,b,c,d\}$,</span>
          also
          Wörter, die von vorne wie hinten gelesen gleich aussehen.
        </p>
      </li>
    </ol>
    <p class="main-column">
      Wir wollen herausfinden, welche Arten von Sprachen
      wir mit den im letzten Abschnitt eingeführen Regelwerk
      aus Ableitungen beschreiben können. Für die gerade
      aufgelisteten sechs Sprachen lautet die Antwort
    </p>
    <ol class="main-column">
      <li>
        <p>
          Ja, können wir.
        </p>
      </li>
      <li>
        <p>
          Ja, wenn wir leicht komplexere Ableitungsregeln erlauben.
        </p>
      </li>
      <li>
        <p>
          Ja, wenn wir leicht komplexere Ableitungsregeln erlaubten.
        </p>
      </li>
      <li>
        <p>
          Nein, können wir nicht.
        </p>
      </li>
      <li>
        <p>
          Ja, können wir.
        </p>
      </li>
      <li>
        <p>
          Ja, können wir.
        </p>
      </li>
    </ol>
    <h2 class="main-column">
      Grammatiken
    </h2>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>5.1</b>
        <b>(Kontextfreie Grammatik).</b>
        Eine
        <i>kontextfreie Grammatik</i>
        besteht aus
      </p>
      <ol>
        <li>
          <p>
            einem endlichen Alphabet
            <span class="nowrap">$\Sigma$,</span>
            den
            <i>terminalen
              Symbolen</i>;
          </p>
        </li>
        <li>
          <p>
            einer dazu disjunkten endlichen Menge
            <span class="nowrap">$N$,</span>
            genannt
            die
            <i>nichtterminalen Symbole</i>;
          </p>
        </li>
        <li>
          <p>
            einer endlichen Menge $P$ von
            <i>Produktionsregeln</i>
            der Form $X \rightarrow \alpha$ mit $X \in N$ und
            <span class="nowrap">$\alpha \in (\Sigma \cup \N)^*$;</span>
            formal also
            <span class="nowrap">$P \subseteq N \times (\Sigma \cup \N)^*$.</span>
            
          </p>
        </li>
        <li>
          <p>
            einem Startsymbol
            <span class="nowrap">$S \in N$.</span>
            
          </p>
        </li>
      </ol>
      <p>
        Die Grammatik $G$ ist also ein 4-Tupel
        <span class="nowrap">$(\Sigma, N, P, S)$.</span>
        
      </p>
    </div>
    <p class="main-column">
      Woher der Name
      <i>kontextfrei</i>
      kommt, werden Sie hoffentlich
      verstehen, wenn wir
      <i>Ableitungen</i>
      definiert haben.
      Die Tradition will es, dass wir für die terminalen
      Symbole Zahlen oder lateinsiche Kleinbuchstaben und
      für die nichtterminalen Symbole lateinische Großbuchstaben
      verwenden. Dies ist eine Konvention, die hilfreich
      ist, solange wir auf abstrakt-theoretischer Ebene über
      formale Grammatiken sprechen; wenn Sie z.B. eine Grammatik
      für Java erstellen wollen, dann wird $\Sigma$ natürlich
      auch Großbuchstaben enthalten.
    </p>
    <div class="well statement out">
      <p>
        <b>Beispiel</b>
        <b>5.2</b>
        Wir betrachten die Grammatik 
        $G = (\{a,b\}, \{S, A, B\}, P, S)$ mit den Produktionsregeln
      </p>
      <div class="math-block">
        $$\begin{align*}
        S&amp;\rightarrow A B \\
        A&amp;\rightarrow \epsilon \ | \ a A \\
        B&amp;\rightarrow \epsilon \ | \ b B \ . \\
        \end{align*}$$
      </div>
      <p>
        Formal sind die Produktionsregeln $P$ eine Teilmenge
        von
        <span class="nowrap">$ N \times (\Sigma \cup \N)^*$,</span>
        also
      </p>
      <div class="math-block">
        $$
        P = \{ (S, AB), (A, \epsilon), (A, aA), (B, \epsilon), (B, bB) \} \ .
        $$
      </div>
      <p>
        Für konkrete Beispiele wie die gerade betrachtete
        Grammatik jedoch verwenden wir einfach die Pfeilschreibweise
        <span class="nowrap">$S \rightarrow AB, \dots$.</span>
        Hier ist eine
        <i>Ableitung</i>
        basierend auf der Grammatik:
      </p>
      <div class="math-block">
        $$\begin{align*}
        S \Rightarrow AB \Rightarrow aAB \Rightarrow aAbB \Rightarrow aAbbB
        \Rightarrow aAbb \Rightarrow abb \ .
        \end{align*}$$
      </div>
      <p>
        In jedem Schritt wählen wir ein Nichtterminal aus,
        zum Beispiel im zweiten Schritt
        <span class="nowrap">$A$,</span>
        und wenden eine
        Regel an, zum Beispiel
        <span class="nowrap">$A \rightarrow aA$.</span>
        Dadurch
        wird $AB$ zu
        <span class="nowrap">$aAB$.</span>
        Wir setzen diese Ableitungsschritte
        so lange fort, bis nur noch terminale Symbole übrigbleiben.
        Dann hat sich ein Wort $\alpha \in \Sigma^*$ ergeben.
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>5.3</b>
        Gegeben sei eine kontextfreie Grammatik
        <span class="nowrap">$G = (\Sigma, N, P, S)$.</span>
        Ein String 
        $\alpha \in (\Sigma \cup N)^*$ heißt
        <i>Wortform</i>
        (im
        Gegensatz zu einem Wort
        <span class="nowrap">$x \in \Sigma^*)$.</span>
        Für zwei
        Wortformen $\alpha , \beta$ schreiben wir
      </p>
      <div class="math-block">
        $$
        \alpha \Rightarrow \beta
        $$
      </div>
      <p>
        wenn wir $\alpha$ zu $\beta$ machen können, indem
        wir ein nichtterminales Symbol $X$ in $\alpha$ durch
        die rechte Seite $X \rightarrow \gamma$ ersetzen können.
        Formal gesprochen, wenn wir 
        $\alpha = \alpha_1 X \alpha_2$ und 
        $\beta = \beta_1 \gamma \beta_2$ mit Wortformen 
        $\alpha_1, \alpha_2, \beta_1, \gamma, \beta_2$ und
        einem Nichtterminal $X$ schreiben können, so dass 
        $X \rightarrow \gamma $ eine Produktionsregel in 
        $P$ ist.
        Wenn wir $\alpha = \beta$ "vorlesen", dann sagen wir
        <i>$\beta$ kann aus $\alpha$ in einem Schritt abgeleitet
          werden</i>. Wenn $\beta$ aus $\alpha$ in mehreren (im
        Extremfall null) Schritten abgeleitet werden kann,
        so schreiben wir
        <span class="nowrap">$\alpha \Rightarrow^* \beta$.</span>
        Formal bedeutet
        <span class="nowrap">$\alpha \Rightarrow^* \beta$,</span>
        dass
        es ein $k \geq 0$ gibt und "Zwischenwortformen" 
        $\alpha_0, \alpha_1, \dots, \alpha_k$ mit 
        $\alpha = \alpha_0$ und
        <span class="nowrap">$\alpha_k = \beta$,</span>
        sodass 
        $\alpha_i \Rightarrow \alpha_{i+1}$ für alle 
        $i = 0, 1, \dots, k-1$ gilt. Dies schließt den "trivialen"
        Fall $k=0$ mit ein, in welchem $\alpha = \beta$ gilt.
      </p>
    </div>
    <p class="main-column">
      Nochmals: wenn $\alpha$ die Form 
      $\alpha_1 X \alpha_2$ hat, dann dürfen Sie das Nichtterminal 
      $X$ durch die rechte Seite einer Produktionsregel 
      $X \rightarrow \gamma$ ersetzen; Sie dürfen das unabhängig
      von dem
      <i>Kontext</i>, in welchem $X$ in der Wortform 
      $\alpha$ vorkommt. Daher rührt der Name
      <i>kontextfreie
        Grammatik</i>.
      Beachten Sie, dass $P$ per Definition eine
      <i>endliche
        Menge</i>
      von Regeln sein muss, dass jedoch 
      $\Rightarrow$ im Allgemeinen unendlich ist. Bereits
      für unsere einfache Grammatik mit den Produktionsregeln
    </p>
    <div class="math-block main-column">
      $$\begin{align*}
      S&amp;\rightarrow A B \\
      A&amp;\rightarrow \epsilon \ | \ a A \\
      B&amp;\rightarrow \epsilon \ | \ b B \ . \\
      \end{align*}$$
    </div>
    <p class="main-column">
      haben wir beispielsweise
    </p>
    <div class="math-block main-column">
      $$\begin{align*}
      A&amp;\rightarrow aA \\
      aA&amp;\rightarrow aaA \\
      aaA&amp;\rightarrow aaaA \\
      \dots
      \end{align*}$$
    </div>
    <p class="main-column">
      und sehen, dass die Menge aller Paare 
      $\alpha \Rightarrow \beta$ unendlich ist.
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>5.4</b>
        <b>(Die von einer Grammatik erzeugte Sprache).</b>
        Sei 
        $G = (\Sigma, N, P, S) $ eine kontextfreie Grammatik.
        Die von $G$ erzeugte Sprache $L(G)$ ist die Menge
        aller Wörter, die vom Startsymbol $S$ abgeleitet werden
        können, also
      </p>
      <div class="math-block">
        $$\begin{align*}
        L(G) := \{x \in \Sigma^* \ | \ S \Rightarrow^* x\} \ .
        \end{align*}$$
      </div>
      <p>
        Wenn es zu einer Sprache $L \subseteq \Sigma^*$ eine
        kontextfreie Grammatik $G$ mit $L(G) = L$ gibt, so
        nennen wir $L$ eine
        <i>kontextfreie Sprache</i>. Beachten
        Sie, dass in dem obigen Beispiel die Wortform 
        $aaAB$ zwar aus $S$ abgeleitet werden kann, allerdings
        kein
        <i>Wort</i>
        ist, da es noch nichtterminale Symbole
        enthält. Es gilt also
        <span class="nowrap">$aaAB \not \in L(G)$.</span>
        Oft können
        wir $L(G)$ kompakt mit natürlicher Sprache beschreiben:
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Beispiel</b>
        <b>5.5</b>
        Sei $G$ die zuletzt betrachtete Grammatik. Dann ist 
        $L(G)$ die Menge aller Wörter der Form
        <span class="nowrap">$a^* b^*$,</span>
        also Wörter, in denen auf beliebig viele
        <span class="nowrap">$a$'s</span>
        beliebig
        viele
        <span class="nowrap">$b$'s</span>
        folgen.
      </p>
    </div>
    <p class="main-column">
      Wir betrachten nun einige weitere Beispiele
    </p>
    <div class="well statement out">
      <p>
        <b>Beispiel</b>
        <b>5.6</b>
        Wir betrachten die Grammatik 
        $G_2 = (\{a,b\}, \{S\}, P, S)$ mit den Produktionsregeln
      </p>
      <div class="math-block">
        $$\begin{align}
        S&amp;\rightarrow aSbS \\
        S&amp;\rightarrow bSaS \\
        S&amp;\rightarrow \epsilon \ .
        \end{align}$$
      </div>
      <p>
        Hier sind mögliche Ableitungen des Wortes
        <span class="nowrap">$abab$.</span>
        Zur Verdeutlichung schreiben wir über den Pfeil 
        $\Rightarrow$ die Nummer der Regel, die wir angewendet
        haben:
      </p>
      <div class="math-block">
        $$\begin{align*}
        S&amp;\stackrel{(1)}{\Rightarrow} aSbS
        \stackrel{(1)}{\Rightarrow} aSbaSbS
        \stackrel{(3)}{\Rightarrow} aSbaSb
        \stackrel{(3)}{\Rightarrow} abaSb
        \stackrel{(3)}{\Rightarrow} abab \\
        S&amp;\stackrel{(1)}{\Rightarrow} aSbS
        \stackrel{(3)}{\Rightarrow} abS
        \stackrel{(1)}{\Rightarrow} abaSbS
        \stackrel{(3)}{\Rightarrow} ababS
        \stackrel{(3)}{\Rightarrow} abab \ .
        \end{align*}$$
      </div>
      <p>
        Wir sehen also: das gleiche Wort kann mehrere Ableitungen
        haben. Da die Ersetzungsregeln
        <i>kontextfrei</i>
        sind,
        spielt es keine Rolle, in welcher Reihenfolge wir nichtterminale
        Symbole ersetzen. Wenn Sie scharf hinschauen, werden
        Sie erkennen, dass die beiden Ableitungen "irgendwie
        gleich" sind, dass nur die Ableitungen in anderer Reihenfolge
        durchgeführt worden sind. Ich werde das in einem späteren
        Kapitel formal definieren, was ich mit damit meine.
        Um Ordnung in das Chaos zu bringen, könnten wir uns
        zum Beispiel einigen, dass man immer das am weitesten
        links stehende Nichtterminal ersetzen muss. Das nennt
        man eine
        <i>Linksableitung</i>. Dies ist nicht wirklich
        eine Einschränkung, da die Ersetzungsreihenfolge keine
        Rolle spielt. Wir sehen, dass die zweite Ableitung
        des Wortes $abab$ oben eine Linksableitung ist; zusammen
        mit der Beschriftung
        <span class="nowrap">$\stackrel{(i)}{\Rightarrow}$,</span>
        die die Nummer der angewendeten Regel angibt, ist eindeutig,
        wie wir von $S$ zum abgeleiteten Wort gekommen sind.
        Betrachten Sie nun eine weitere Linksableitung
        <span class="nowrap">$S \Rightarrow^* abab$:</span>
        
      </p>
      <div class="math-block">
        $$\begin{align*}
        S&amp;\stackrel{(1)}{\Rightarrow} aSbS
        \stackrel{(2)}{\Rightarrow} abSaSbS
        \stackrel{(3)}{\Rightarrow} abaSbS
        \stackrel{(3)}{\Rightarrow} ababS
        \stackrel{(3)}{\Rightarrow} abab
        \end{align*}$$
      </div>
      <p>
        Sehen Sie, dass diese Ableitung
        <i>qualitativ</i>
        anders
        ist, da wir hier auch die Regel 
        $S \rightarrow bSaS$ angewendet haben? Um die Struktur
        der Ableitung zu verdeutlichen, könnten wir die ersten
        beiden Ableitungen mit Wort 
        $S \Rightarrow^* (ab)(ab)$ bezeichnen und die dritte
        mit Wort
        <span class="nowrap">$S \Rightarrow^* a(ba)b$.</span>
        
      </p>
    </div>
    <h1 class="main-column">
      Ziele der Theorie der formalen Sprachen
    </h1>
    <p class="main-column">
      Ganz allgemein gesagt wollen wir lernen, wie wir Sprachen
      formal beschreiben können; wie wir, gegeben eine Grammatik 
      $G$ und ein Zielwort
      <span class="nowrap">$x$,</span>
      eine Ableitung 
      $G \Rightarrow^* x$ finden können. Anhand der Ableitungssequenz
      können wir dann oft auf die logische Struktur von 
      $x$ schließen. Handelt es sich bei $G$ zum Beispiel
      um eine Grammatik für die Programmiersprache Java,
      so wäre ein Ziel, aus der Ableitungssequenz 
      $G \Rightarrow^* x$ die Struktur des Programms
      <span class="nowrap">$x$,</span>
      also Klassenstruktur, Methoden, etc., ablesen zu können
      und schlussendlich das Programm in ausführbaren Maschinencode
      kompilieren zu können.
    </p>
    <div class="well statement out">
      <p>
        <b>Algorithmisches Problem: Parsing</b>
        <b>5.7</b>
        Gegeben eine (kontextfreie) Grammatik $G$ und ein
        Zielwort
        <span class="nowrap">$x$,</span>
        finde eine Ableitung
        <span class="nowrap">$G \Rightarrow^* x$,</span>
        falls es so eine gibt.
        Für einen String $x$ eine Ableitung zu finden bezeichnen
        wir als
        <i>parsen</i>, das zugehörige Hauptwort als
        <i>Parsing</i>.
      </p>
    </div>
    <p class="main-column">
      <b>Die gute Nachricht:</b>
      Die gute Nachricht: wir kennen
      Algorithmen, die dieses Problem im effizient lösen,
      wenn wir den "theoretischen" Effizienzbegriff zugrund
      legen.
      <b>Die schlechte Nachricht:</b>
      wir kennen keinen Algorithmus,
      der das Parsing kontextfreier Sprachen in seiner ganzen
      Allgemeinheit in
      <i>linearer Zeit</i>
      erledigt, dessen Laufzeit
      also proportional zur Länge des Zielwortes $x$ ist.
      Dies ist aber, was wir in der Praxis, zum Beispiel
      bei Compilern, erwarten.
      <b>Die gute Nachricht:</b>
      in fast allen praktisch relevanten
      Fällen haben wir es mit Grammatiken zu tun, die Parsing
      in linearer Zeit ermöglichen. Und wenn wir Programmiersprachen,
      Datenformate etc. entwerfen, haben wir es ja in der
      Hand, Sprache und Grammatik so anzulegen, dass effizientes
      Parsen möglich ist.
      Im nächsten Kapitel lernen wir eine stark eingeschränkte,
      aber dennoch sehr wichtige Klasse kontextfreier Grammatik
      kennen, die allesamt ein sehr effizientes Parsing erlauben:
      die sogenannten
      <i>regulären</i>
      Grammatiken.
    </p>
  </div>
</body>
</html>
