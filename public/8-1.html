<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 8.1 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 8, Section 1</title>
</head>
<body>
  <div class="body-wrapper">
    <div id="top-menu">
      <div class="top-menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./8-0.html"
        >&lt;&lt; Kapitel 8<span
            style="visibility:hidden"
            id="top-prev-page-tooltip"
          >Turingmaschinen</span></a>
      </div>
      <div class="top-menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./8-2.html"
        >Kapitel 8.2 &gt;&gt;<span
            style="visibility:hidden"
            id="top-next-page-tooltip"
          >Beispiele</span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        8.1&ensp;Turingmaschinen: Formale Definition und Beispiele
      </p>
    </div>
    <p class="main-column">
      Eine Turingmaschine besteht aus einem
      <span class="nowrap"><i>Band</i>,</span>
      das in Zellen
      unterteilt ist und in beide Richtungen unbegrenzt ist, und einem
      <span class="nowrap"><i>Schreib-Lese-Kopf</i>.</span>
      Dieser befindet sich in jedem Schritt auf
      einer Zelle. Wie auch der endliche Automat oder der Kellerautomat
      hat die Turingmaschine einen internen
      <span class="nowrap"><i>Zustand</i>.</span>
      In jedem Schritt
      liest die Maschine das Zeichen, das sich in der aktuellen Zelle des
      Bandes befindet (dort, wo der Kopf steht). Abhängig vom gelesenen
      Zeichen $s$ und dem internen Zustand $q$ schreibt die
      Turingmaschine ein neues Symbol $s'$ in die Zelle, wechselt in
      einen neuen Zustand $q'$ und bewegt den Kopf um maximal eine
      Zelle, also nach link, rechts, oder gar nicht.
    </p>
    <div class="pseudowell">
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img
                style="width:37em"
                src="img/turing-machines/exampe-1/01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="width:37em"
                src="img/turing-machines/exampe-1/02.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="width:37em"
                src="img/turing-machines/exampe-1/03.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="width:37em"
                src="img/turing-machines/exampe-1/04.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="width:37em"
                src="img/turing-machines/exampe-1/05.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="width:37em"
                src="img/turing-machines/exampe-1/06.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="width:37em"
                src="img/turing-machines/exampe-1/07.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="width:37em"
                src="img/turing-machines/exampe-1/08.svg"
              >
            </div>
          </div>
        </div>
      </div>
    </div>
    <p class="main-column">
      Sie können sich das Band auch als Magnetband vorstellen, das nach
      vorn oder nach hinten gespult wird, anstatt dass der Kopf sich
      bewegt. Am Anfang steht auf dem Band das
      <i>Eingabewort</i>
      und der Kopf
      auf dem ersten Symbol dieses Wortes. Die Turingmaschine wendet nun
      ihre Regeln an, bis Sie einen
      <i>Endzustand</i>
      erreicht. Bei
      <span class="nowrap"><i>Entscheidungsproblemen</i>,</span>
      wo uns nur eine Ja/Nein-Antwort
      interessiert, wird die Antwort durch den Entzustand angegeben: der
      Zustand $\qaccept$ entspricht einem
      <span class="nowrap"><i>Ja</i>,</span>
      der Zustand $\qreject$
      entspricht einem
      <span class="nowrap"><i>Nein</i>.</span>
      Diese zwei Endzustände reichen im
      Allgemeinen aus. Wenn wir von der Maschine eine komplexere Ausgabe
      als Ja/Nein erwarten, so betrachten wir als
      <i>Ausgabe der
        Turingmaschine</i>
      den Inhalt des Bandes zu dem Zeitpunkt, da die
      Maschine den Zustand $\qaccept$ erreicht. Was brauchen wir also,
      um so eine Turingmaschine und ihre Arbeitsweise zu beschreiben?
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>8.1.1</b>
        <b>(Turingmaschine).</b>
        Eine Turingmaschine besteht aus folgenden
        Elementen:
      </p>
      <ol>
        <li>
          <p>
            Einem endlichen Eingabe-Alphabet $\Sigma$ . Dies sind die
            Symbole, die für das Eingabewort in Frage kommen.
          </p>
        </li>
        <li>
          <p>
            Einem endlichen Bandalphabet
            <span class="nowrap">$\Gamma$;</span>
            das sind die Symbole,
            die auf dem Band stehen dürfen. Offensichtlich muss
            $\Sigma \subseteq \Gamma$ gelten. Jede Zelle kann genau ein
            Zeichen aus $\Gamma$ enthalten. Darüberhinaus gibt es noch
            das sogenannte Blanksymbol
            <span class="nowrap">$\square \in \Gamma \setminus \Sigma$.</span>
            Dies zeigt an, dass
            die Zelle im Moment leer ist. Im obigen Beispiel ist die
            Zelle links vom ersten $a$ beispielsweise leer. Am Anfang
            steht auf dem Band also ein Eingabewort $w \in \Sigma^*$ und
            rechts und links davon unendlich viele $\square$ -Symbole.
          </p>
        </li>
        <li>
          <p>
            Einer endliche Menge $Q$ an inneren Zuständen. Dies
            entspricht in etwa den Prozessor-Registern eines Computers.
            Ein Zustand $\texttt{start} \in Q$ ist der Startzustand, in
            welchem sich die Maschine zu Beginn befindet.
          </p>
        </li>
        <li>
          <p>
            Einer Zustandsübergangsfunktion
            <span class="nowrap">$\delta$,</span>
            die sagt, was die
            Turingmaschine tun soll, wenn Sie im Zustand $q$ ist und
            Zeichen $s$ liest. Formal:
          </p>
          <div class="math-block">
            $$
            \begin{align*}
            \delta : Q \times \Gamma \rightarrow Q \times \Gamma \times \lsr \ ,
            \end{align*}
            $$
          </div>
          <p>
            wobei
            <code>L</code>
            für
            <i>gehe eine Zelle nach links</i>
            <span class="nowrap">steht,<code>R</code></span>
            für
            rechts und
            <code>S</code>
            für
            <span class="nowrap"><i>stay</i>,</span>
            also die Anweisung, den Kopf nicht
            zu bewegen.
          </p>
        </li>
        <li>
          <p>
            Zwei besonderen Zuständen $\qaccept$ und
            <span class="nowrap">$\qreject$.</span>
          </p>
        </li>
      </ol>
    </div>
    <p class="main-column">
      Für die Turingmaschine in dem obigen Beispiel haben wir zwei
      Regeln gesehen:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \delta(q_2, b)&amp;= (q_3, a, \texttt{R}) \\
      \delta(q_3, \#)&amp;= (q_4, b, \texttt{L})
      \end{align*}
      $$
    </div>
    <h3 class="main-column subtopic-announcement">
      Was macht eine Turingmaschine?
    </h3>
    <p class="main-column">
      Sie haben nun wohl bereits eine vage Vorstellung, was eine
      Turingmaschine macht. Versuchen wir, es noch weiter zu
      formalisieren. Um den
      <i>Gesamtzustand</i>
      der Turingmaschine zu
      beschreiben, also eine vollständige Momentaufnahme, reicht nicht
      der aktuelle innere Zustand
      <span class="nowrap">$q$;</span>
      wir brauchen auch den Bandinhalt
      und insbesondere die Position, an der sich der Kopf befindet. Das
      alles zusammen nennt man die
      <span class="nowrap"><i>Konfiguration der Turingmaschine</i>.</span>
      Wir wollen sie mit uns bereits bekannten mathematischen Begriffen
      beschreiben.
    </p>
    <div class="pseudowell">
      <figure>
        <img
          style="height:20em"
          src="img/turing-machines/configuration.svg"
        >
      </figure>
    </div>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>8.1.2</b>
        Die
        <i>Konfiguration</i>
        einer Turingmaschine ist ein Element in
        <span class="nowrap">$\Gamma^* \times Q \times \Gamma^*$,</span>
        also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        C = u q v
        \end{align*}
        $$
      </div>
      <p>
        wobei $uv \in \Gamma^*$ der Bandinhalt ist, der
        Schreib-Lese-Kopf auf dem ersten Zeichen von $v$ steht und $q$
        der innere Zustand der Turingmaschine ist. Das $q$ in $C$
        kennzeichnet also sowohl die Position des Schreib-Lese-Kopfes auf
        dem Band sowie den inneren Zustand Die Menge aller
        Konfigurationen ist
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \mathcal{C} := \Gamma^* \times Q \times \Gamma^*
        \end{align*}
        $$
      </div>
      <p>
        Der
        <i>Zustand einer Konfiguration</i>
        $C = uqv$ ist
        <span class="nowrap">$q$,</span>
        also der
        innere Zustand, in dem sich die Maschine gerade befindet. Wir
        bezeichnen mit
        <span class="nowrap">$\state(C)$.</span>
        Formal:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \state: \mathcal{C}&amp;\rightarrow Q \\
        uqv&amp;\mapsto q \ .
        \end{align*}
        $$
      </div>
      <p>
        Eine Konfiguration $C$ ist eine
        <i>akzeptierende Endkonfiguration</i>
        wenn $\state(C) = \qaccept$ ist; eine
        <i>ablehnende
          Endkonfiguration</i>
        , wenn $\state(C) = \qreject$ ist. In beiden
        Fällen ist $C$ eine
        <span class="nowrap"><i>Endkonfiguration</i>.</span>
      </p>
    </div>
    <p class="main-column">
      Wenn also das Eingabewort $w \in \Sigma^*$ und $\qstart$ der
      Startzustand ist, dann ist
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      C_{\rm start} = \qstart{} w
      \end{align*}
      $$
    </div>
    <p class="main-column">
      die
      <span class="nowrap"><i>Startkonfiguration</i>.</span>
    </p>
    <div class="well alert-info out main-column">
      <p>
        <span class="nowrap"><b>Die Rolle des
            <span class="nowrap">$\square$-Symbols</span></b>.</span>
        Das Band der Turingmaschine
        ist ja unendlich. Um eine Momentaufnahme dennoch als endliches
        Objekt beschreiben zu können, lassen wir die $\square$ -Symbole
        links und rechts vom "eigentlichen" Bandinhalt weg. Bei einer
        Konfiguration $uqv$ stehen also links vom $u$ und rechts vom $v$
        unendlich viele $\square$ -Symbole auf dem Band. Nach der
        formalen Definition $uqv \in \Gamma^* \times Q \times \Gamma^*$
        ist es nicht verboten, dass $u$ auch mit einem
        <span class="nowrap">$\square$-Symbol</span>
        beginnt oder $v$ mit einem aufhört. Allerdings wären die
        Konfiguration $\square u q v$ und $u q v \square$ genauso gut
        mit $u q v$ beschrieben. Wir können uns also auf die Konvention
        einigen, dass $\square$ nie am Rande einer Konfiguration $uqv$
        steht. Beachten Sie auch, dass die Zellen nicht "numeriert" sind.
        Die beiden folgenden Momentaufnahmen
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:18em"
            src="img/turing-machines/configuration-two.svg"
          >
        </figure>
      </div>
      <p>
        können also beide mit der Konfiguration $aAAaq\#ba$ beschrieben
        werden, obwohl die Zellen nun andere Inhalte haben, weil die
        Turingmaschine es irgendwie geschafft hat, den ganzen Bandinhalt
        um eins nach rechts zu kopieren. Es sollte klar sein, dass die
        Turingmaschine keine Möglichkeit hat, die obere von der unteren
        Situation zu unterscheiden, und dass es somit nur recht und
        billig ist, beide als eine identische Konfiguration aufzufassen.
        All diese Schwierigkeiten verschwinden, wenn wir uns den Speicher
        einer Turingmaschine nicht als unendliches Band vorstellen,
        sondern als zwei Stapel, einer links vom Kopf und einer rechts
        vom Kopf. Allerdings hat sich die Vorstellung vom Band irgendwie
        als Standard durchgesetzt. Hier sehen Sie die gleiche
        Konfiguration in dem Modell mit zwei Stapeln:
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:18em"
            src="img/turing-machines/two-stacks.svg"
          >
        </figure>
      </div>
      <p>
        Alternativ können wir auch der Turingmaschine verbieten, das
        Blank-Symbol $\Box$ jemals zu schreiben. Dann wäre also
        <span class="nowrap">$\delta: Q \times \Gamma \rightarrow Q \times (\Gamma
          \setminus \{\Box\}) \times \lsr$.</span>
        All diese Betrachtungsweisen unterscheiden sich nicht wesentlich.
        Wir bleiben bei unserem "alten"
        <span class="nowrap">$\delta$,</span>
        erlauben also, $\Box$
        zu schreiben, und leben damit, dass $uqv$ und
        $\Box \Box u q v \Box$ formal zwei verschiedene Konfigurationen
        sind, auch wenn beide irgendwie das selbe beschreiben.
      </p>
    </div>
    <p class="main-column">
      Formal definiert $\delta$ nun auch eine Funktion auf der Menge der
      Konfigurationen:
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>8.1.3</b>
        <b>(erweiterte Zustandsübergangsfunktion)</b>
        Die erweiterte
        Zustandsübergangsfunktion einer Turingmaschine ist
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \hat{\delta} : \mathcal{C} \rightarrow \mathcal{C} \
        \end{align*}
        $$
      </div>
      <p>
        Sie beschreibt für eine Konfiguration
        <span class="nowrap">$C$,</span>
        welches die
        Konfiguration im nächsten Schritt ist. Per Konvention legen wir
        fest, dass $\hat{\delta}(C) = C$ gilt, wenn $C$ eine
        Endkonfiguration ist.
      </p>
    </div>
    <p class="main-column">
      Unsere obige Turingmaschine hat beispielsweise die Regeln
      $\delta(q_2,b) = (q_3, a,R)$ und
      <span class="nowrap">$\delta(q_3, \#) = (q_4, b, \texttt{L})$,</span>
      und somit würden
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \hat{\delta}(aaAq_2b\#ba)&amp;= aaAaq_3\#ba \\
      \hat{\delta}(aaAaq_3\#ba)&amp;= aaAq_4abba \\
      \hat{\delta}(abAq_2bba\#)&amp;= abAaq_3ba\# \\
      \end{align*}
      $$
    </div>
    <p class="main-column">
      gelten. Sie sehen: Die Definition von $\hat{\delta}$ ist nichts
      wirklich Tiefgründiges, sondern einfach eine Implementierung der
      Turingmaschinen-Momentaufnahme mit uns bereits geläufigen
      mathematischen "Datenstrukturen" (hier: der Menge
      <span class="nowrap">$\Gamma^* \times Q \times \Gamma^*$).</span>
      Stellen Sie sich einfach
      vor, Sie müssten eine Turingmaschine in Java implementieren. Dann
      würden Sie es wahrscheilich irgendwie so ähnlich machen.
    </p>
    <h3 class="main-column subtopic-announcement">
      Ausgabekonfiguration einer Turingmaschine
    </h3>
    <p class="main-column">
      Die Funktion $\hat{\delta}$ bildet aus einer Konfiguration die
      Folgekonfiguration. Wir definieren nun
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \hat{\delta}^{(i)} (C) := \underbrace{\hat{\delta}(\hat{\delta}(\dots (\hat{\delta}}_{i \textnormal{
      mal}} (C) \dots)))
      \end{align*}
      $$
    </div>
    <p class="main-column">
      also die Konfiguration, die die Turingmaschine nach $i$
      Rechenschritten erreicht hat. Weiterhin definieren wir
      $\hat{\delta}^* (C)$ als die Endkonfiguration, die bei
      wiederholter Anwendung von $\hat{\delta}$ schlussendlich erreicht
      wird. Hier taucht ein Problem auf: es ist nicht gesagt, dass die
      Turingmaschine, von Konfiguration $C$ beginnend, überhaupt
      irgendwann in einer Endkonfiguration landen wird. Daher kann
      $\hat{\delta}^*$ auch
      <code>undefined</code>
      sein:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \hat{\delta}^* (C) := \begin{cases}
      \hat{\delta}^{(i)} (C)&amp;
      \textnormal{ wenn es ein \(i\) gibt, so dass $\hat{\delta}^{(i)} (C)$ eine Endkonfiguration ist} \\
      \texttt{undefined}&amp;\textnormal{sonst.}
      \end{cases}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Nochmal zur Verdeutlichung: wenn $\delta^{(i)}(C)$ eine
      Endkonfiguration ist, dann ist auch $\delta^{(j)}(C)$ eine, für
      jedes
      <span class="nowrap">$j \geq i$,</span>
      weil wir $\hat{\delta}(C') = C'$ für jede
      Endkonfiguration $C'$ definiert haben. Es spielt also in der
      obigen Formulierung
      <i>wenn es ein $i$ gibt</i>
      keine Rolle, welches
      solche $i$ wir wählen. Für ein Eingabewort $x \in \Sigma^*$ können
      wir nun das Ergebnis der Berechnung von Turingmaschine $M$ auf
      $x = x_1 \dots x_n$ definieren:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \hat{M}(x) := \hat{\delta}^* (\qstart{} x_1 x_2 x_3 \dots x_n) \ .
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Wir beginnen also mit der Startkonfiguration und lassen die
      Turingmaschine dann laufen, bis sie einen Endzustand erreicht. Die
      erreichte Konfiguration bezeichnen wir mit
      <span class="nowrap">$\hat{M}(x)$.</span>
      Falls nie
      ein Endzustand erreicht wird (die Turingmaschine also endlos
      läuft), ist $\hat{M}(x)$
      <span class="nowrap"><code>undefined</code>.</span>
    </p>
    <h2 class="main-column topic-announcement">
      Sprachen entscheiden
    </h2>
    <p class="main-column">
      Ein
      <i>Entscheidungsproblem</i>
      ist eine Funktion
      <span class="nowrap">$P : \Sigma^* \rightarrow \{\texttt{true}, \texttt{false}\}$,</span>
      beispielsweise:
      <i>gegeben ein Wort, stellt dieses Wort ein korrektes
        Java-Programm dar?</i>
      oder
      <i>gegeben eine Zahl in Dezimalschreibweise,
        ist dies eine Primzahl?</i>
      Eine äquivalente Sichtweise ist die eines
      Entscheidungsproblems als
      <i>Sprache</i>
      <span class="nowrap">$L \subseteq \Sigma^*$.</span>
      Wir
      identifizieren $L$ hier mit der Menge aller Wörter $x$ mit
      <span class="nowrap">$P(x) = \texttt{true}$.</span>
      Wenn wir es mit einem Entscheidungsproblem
      zu tun haben und dieses mit einer Turingmaschine lösen wollen, so
      interessiert uns am Endergebnis $\hat{M}(x)$ (also der erreichten
      Endkonfiguration) nicht der Bandinhalt, sondern nur, ob der Zustand
      <code>accept</code>
      <span class="nowrap">oder<code>reject</code></span>
      ist. Wir definieren daher
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      f_M(x) = \begin{cases}
      \texttt{accept}&amp;\textnormal{ falls $\state(\hat{M}(x)) = \qaccept$, wenn also $\hat{M}(x)$
      eine akzeptierende Endkonfiguration ist, }\\
      \texttt{reject}&amp;\textnormal{ falls $\state(\hat{M}(x)) = \qreject$ ,}\\
      \texttt{undefined}&amp;\textnormal{ falls $\hat{M}(x) = \texttt{undefined}$ }
      \end{cases}
      \end{align*}
      $$
    </div>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>8.1.4</b>
        <b>(Turingmaschine entscheidet eine Sprache)</b>
        Eine Turingmaschine
        $M$
        <i>entscheidet</i>
        die Sprache $L \subseteq \Sigma^*$ wenn
      </p>
      <ol>
        <li>
          <p>
            $f_M(x) = \texttt{accept}$ für alle
            <span class="nowrap">$x \in L$,</span>
          </p>
        </li>
        <li>
          <p>
            $f_M(x) = \texttt{reject}$ für alle
            <span class="nowrap">$x \in \Sigma^* \setminus L$.</span>
          </p>
        </li>
      </ol>
      <p>
        Insbesondere heißt das, dass $M$ auf jedem Eingabewort
        terminiert. Eine Sprache $L$ heißt
        <span class="nowrap"><i>entscheidbar</i>,</span>
        wenn es eine
        Turingmaschine gibt, die sie entscheidet.
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>8.1.5</b>
        <b>(Turingmaschine akzeptiert eine Sprache)</b>
        Eine Turingmaschine
        $M$
        <i>akzeptiert</i>
        die Sprache $L \subseteq \Sigma^*$ wenn
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        x \in L \Longleftrightarrow f_M(x) = \texttt{accept}
        \end{align*}
        $$
      </div>
      <p>
        für alle $x \in \Sigma^*$ gilt. Das heißt, dass $M$ für
        $x \not \in \Sigma^*$ entweder irgendwann den Endzustand
        $\qreject$ erreicht oder nie einen Endzustand erreicht. Eine
        Sprache $L \subseteq \Sigma^*$ heißt
        <span class="nowrap"><i>semi-entscheidbar</i>,</span>
        wenn
        es eine Turingmaschine $M$ gibt, die $L$ akzeptiert.
      </p>
    </div>
    <p class="main-column">
      In beiden Definition verlangen wir natürlich, dass $\Sigma$ das
      Eingabealphabet der Turingmaschine ist.
    </p>
    <h2 class="main-column topic-announcement">
      Funktionen berechnen
    </h2>
    <p class="main-column">
      Oft wollen wir nicht nur eine Sprache $L \subseteq \Sigma^*$
      entscheiden, sondern eine Funktion
      $g: \Sigma_1^* \rightarrow \Sigma_2^*$ berechnen. Mit einer
      Turingmaschine heißt das einfach, dass bei Eingabe
      $x \in \Sigma_1^*$ die Turingmaschine in einer akzeptierenden
      Endkonfiguration $C$ landet, und in $C$ steht dann $g(x)$ auf dem
      Band. Formal müssen wir noch klären, was
      <i>$g(x)$ steht auf dem
        Band</i>
      bedeutet.
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>8.1.6</b>
        <b>(Turingmaschine berechnet eine Funktion)</b>
        Seien
        $\Sigma_1, \Sigma_2$ zwei endliche Alphabete und
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        g : \Sigma_1^* \rightarrow \Sigma_2^*
        \end{align*}
        $$
      </div>
      <p>
        eine Funktion. Eine Turingmaschine $M$
        <span class="nowrap"><i>berechnet die Funktion
            $g$</i>,</span>
        wenn
      </p>
      <ol>
        <li>
          <p>
            $\Sigma_1$ das Eingabealphabet von $M$ ist,
          </p>
        </li>
        <li>
          <p>
            $\Sigma_1 \cup \Sigma_2 \subseteq \Gamma$ gilt und
            <span class="nowrap">$\square \in \Gamma \setminus (\Sigma_1 \cup \Sigma_2)$;</span>
            das
            Blank-Symbol ist also weder Teil das Eingabealphabets noch
            des Ausgabealphabets.
          </p>
        </li>
        <li>
          <p>
            $M$ terminiert für jedes $x \in \Sigma^*$ .
          </p>
        </li>
        <li>
          <p>
            In der Endkonfiguration $\hat{M}(x)$ steht auf dem
            Arbeitsband das Wort $g(x) \in \Sigma_2^*$ und der Kopf
            steht ganz links, also
            <span class="nowrap">$\hat{M}(x) = \qaccept{} g(x)$.</span>
          </p>
        </li>
      </ol>
    </div>
    <h2 class="main-column topic-announcement">
      Turingmaschinen und formale Grammatiken
    </h2>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>8.1.7</b>
        Sei $M$ eine Turingmaschine und $L(M)$ die von ihr akzeptierte
        Sprache. Dann gibt es eine formale Grammatik $G$ mit
        <span class="nowrap">$L(G) = L(M)$.</span>
        In anderen Worten: formale Grammatiken sind
        mindestens so mächtig wie Turingmaschinen.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Die Idee ist, dass wir eine Grammatik $G$ schreiben, die "in
        umgekehrter Reihenfolge" läuft, also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \texttt{\$} q_{\rm start} w \texttt{.} \Step{}^* S
        \end{align*}
        $$
      </div>
      <p>
        ableiten kann genau dann, wenn $w \in S$ gilt. Wir brauchen
        \(\texttt{\$}\) und $\texttt{.}$ als Randmarkierungen. Wir
        lassen hier temporär zu, dass die linke Seite ausschließlich aus
        Terminalsymbolen bestehen kann. Hierfür definieren wir für jede
        Regel der Turingmaschine eine Grammatik-Regel:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \begin{array}{lcl}
        \delta(q,x) = (r,y,\texttt{S} )&amp;\textnormal{wird zur Produktion}&amp;qx \rightarrow ry \\
        \delta(q,x) = (y,r,\texttt{R})&amp;\textnormal{wird zur Produktionen}&amp;qx \rightarrow yr \\
        \delta(q,x) = (y,r,\texttt{L})&amp;\textnormal{wird zu den Produktionen}&amp;aqx \rightarrow ray
        \textnormal{ für alle $a \in \Gamma$}
        \end{array}
        \end{align*}
        $$
      </div>
      <p>
        Die Asymmetrie zwischen den Regeln, die den Kopf nach rechts
        verschieben und denen, die ihn nach links verschieben, ergibt
        sich aus unserer Konvention, die Konfigurationen $uqv$ so zu
        interpretieren, dass der Kopf auf dem ersten Symbol von $v$ und
        nicht etwa auf dem letzten von $u$ steht. Ein Problem ergibt
        sich, wenn $q$ am Rand steht. Hierfür erlauben wir, an den
        Rändern der Konfiguration
        <span class="nowrap">$\square$-Symbole</span>
        zu erzeugen:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \texttt{\$}&amp;\rightarrow \texttt{\$} \square \\
        \texttt{.}&amp;\rightarrow \square \texttt{.} \
        \end{align*}
        $$
      </div>
      <p>
        Wenn der Kopf also vor dem $\texttt{.}$ stehen sollte, dann
        können wir
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \texttt{\$}uq\texttt{.} \Step{} \texttt{\$}uq\square \texttt{.}
        \end{align*}
        $$
      </div>
      <p>
        anwenden und dann die Produktion, die der Regel von
        $\delta(q,\square)$ entspricht. Es sollte nun klar sein, dass
        folgendes gilt:
      </p>
      <div class="well statement">
        <p>
          <b>Beobachtung</b>
          <b>8.1.8</b>
          Wenn $\hat{\delta}^{(i)} (uqv) = u'q'v'$ gilt, die
          Turingmaschine also in $i$ Schritten von Konfiguration $uqv$
          nach $u'q'v'$ übergeht, dann gilt in der gerade entwickelten
          Grammatik auch
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          \texttt{\$}uqv\texttt{.} \Step{}^* \texttt{\$}\square^* u'q'v'\square^*\texttt{.}
          \end{align*}
          $$
        </div>
      </div>
      <p>
        Als nächstes definieren wir
        <span class="nowrap"><i>Aufräumregeln</i>:</span>
        wenn
        <span class="nowrap">$q = \texttt{accept}$,</span>
        dann können wir jedes Zeichen löschen:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \texttt{accept}\ x&amp;\rightarrow \texttt{accept} \\
        x\ \texttt{accept}&amp;\rightarrow \texttt{accept}
        \end{align*}
        $$
      </div>
      <p>
        wobei $\texttt{accept}$ ein Nichtterminal der Grammatik ist. Und
        somit gilt auch
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \texttt{\$} u \ \texttt{accept} \ v \texttt{.}&amp;\Step{}^*
        \texttt{\$}\ \texttt{accept} \ \texttt{.}
        \end{align*}
        $$
      </div>
      <p>
        Als letzte Regel definieren wir:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \texttt{\$ }\ \texttt{accept}\ \texttt{.} \rightarrow S
        \end{align*}
        $$
      </div>
      <p>
        Wir haben nun eine Grammatik mit den folgenden Eigenschaften:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        M(x_1 x_2 \dots x_n) = \texttt{accept}&amp;\textnormal{ genau dann, wenn }
        \texttt{\$} \texttt{start} x_1 x_2 \dots x_n \texttt{.} \Step{}^* S
        \end{align*}
        $$
      </div>
      <p>
        Wir bauen nun eine weitere Grammatik
        <span class="nowrap">$G$,</span>
        in der wir jede
        Produktion $\alpha \rightarrow \beta$ umdrehen, also durch
        $\beta \rightarrow \alpha$ ersetzen. Zusätzlich definieren wir
        Abschlussregeln
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \texttt{\$}&amp;\rightarrow \epsilon \\
        \texttt{.}&amp;\rightarrow \epsilon \\
        \texttt{start}&amp;\rightarrow \epsilon
        \end{align*}
        $$
      </div>
      <p>
        die die Randmarkierungen ersetzen. In dieser Grammatik gilt nun
        für alle Wörter
        <span class="nowrap">$x \in \Sigma^*$:</span>
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        x \in L(M) \Longleftrightarrow S \rightarrow
        G: S \Step{}^* x
        \end{align*}
        $$
      </div>
      <p>
        und somit gilt
        <span class="nowrap">$L(G) = L(M)$.</span>
        Zusammenfassend besitzt $G$ also
        die Produktionen
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\step{1} \texttt{\$} \ \texttt{accept} \ \texttt{.} \\
        \texttt{accept}&amp;\step{2} x \ \texttt{accept} \ | \ \texttt{accept} \ x \quad
        \tag{ für jedes \(x \in \Gamma\)} \\
        ry&amp;\step{3} qx \quad \tag{ wenn $\delta(q,x) = (r,y, \texttt{S})$}\\
        yr&amp;\step{4} qx \quad \tag{ wenn $\delta(q,x) = (r,y, \texttt{R})$}\\
        ray&amp;\step{5} aqx \quad \tag{ wenn $\delta(q,x) = (r,y, \texttt{L})$, für jedes \(a \in
        \Gamma\)} \\
        \texttt{\$} \square&amp;\step{6} \texttt{\$} \\
        \texttt{.}\square&amp;\step{7} \texttt{.} \\
        \texttt{\$}&amp;\step{8} \epsilon \\
        \texttt{.}&amp;\step{9} \epsilon \\
        \texttt{start}&amp;\step{10} \epsilon
        \end{align*}
        $$
      </div>
      <p>
        Um also ein Wort $x \in L(M)$ abzuleiten, müssen wir die
        akzeptierende Endkonfiguration $C$ von $M(x)$ "erraten" und dann
        per Produktionen 1 und 2 die Wortform \(\texttt{\$}C\texttt{.}\)
        ableiten. Von da an verwenden wir die Produktionen 3, 4, 5, 6, 7,
        um die Berechnung der Turingmaschine $M(x)$ von hinten nach
        vorne zu simulieren, bis wir bei
        \(\texttt{\$} \texttt{start}\ x \texttt{.}\) angelangt sind.
        Dann lassen wir \(\texttt{\$}, \texttt{start}, \texttt{.}\) mit
        den Produktionen 8, 9, 10 verschwinden und haben $x$ abgeleitet.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <div id="end-of-page-elt">
    </div>
    <div id="bottom-menu">
      <div class="bottom-menu-left">
        <a href="./8-0.html">&lt;&lt; Kapitel 8<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >Turingmaschinen</span></a>
      </div>
      <div class="bottom-menu-right">
        <a href="./8-2.html">Kapitel 8.2 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >Beispiele</span></a>
      </div>
    </div>
  </div>
</body>
</html>
