<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 8.1 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 8, Section 1</title>
</head>
<body class="page-sub chapter-8 sub-1">
  <div class="menu">
    <div class="menu-left">
      <a href="./index.html">Inhaltsverzeichnis</a><a
        href="./8-0.html"
        id="prev-page"
      >&lt;&lt; Kapitel 8</a>
    </div>
    <div class="menu-right">
      <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
        href="./8-2.html"
        id="next-page"
      >Kapitel 8.2  &gt;&gt;</a>
    </div>
  </div>
  <div class="main-column page-title">
    <p>
      8.1 
      Turingmaschinen: Formale Definition und Beispiele
    </p>
  </div>
  <p class="main-column">
    Eine Turingmaschine besteht aus einem
    <span class="nowrap"><i>Band</i>,</span>
    das in Zellen
    unterteilt ist und in beide Richtungen unbegrenzt ist, und einem
    <span class="nowrap"><i>Schreib-Lese-Kopf</i>.</span>
    Dieser befindet sich in jedem Schritt auf
    einer Zelle. Wie auch der endliche Automat oder der Kellerautomat
    hat die Turingmaschine einen internen
    <span class="nowrap"><i>Zustand</i>.</span>
    In jedem Schritt
    liest die Maschine das Zeichen, das sich in der aktuellen Zelle des
    Bandes befindet (dort, wo der Kopf steht). Abhängig vom gelesenen
    Zeichen $s$ und dem internen Zustand $q$ schreibt die
    Turingmaschine ein neues Symbol $s'$ in die Zelle, wechselt in
    einen neuen Zustand $q'$ und bewegt den Kopf um maximal eine
    Zelle, also nach link, rechts, oder gar nicht.
  </p>
  <div class="carousel__container main-column">
    <div class="carousel">
      <div class="carousel__items">
        <div class="carousel__item">
          <img src="img/turing-machines/exampe-1/01.svg">
        </div>
        <div class="carousel__item">
          <img src="img/turing-machines/exampe-1/02.svg">
        </div>
        <div class="carousel__item">
          <img src="img/turing-machines/exampe-1/03.svg">
        </div>
        <div class="carousel__item">
          <img src="img/turing-machines/exampe-1/04.svg">
        </div>
        <div class="carousel__item">
          <img src="img/turing-machines/exampe-1/05.svg">
        </div>
        <div class="carousel__item">
          <img src="img/turing-machines/exampe-1/06.svg">
        </div>
        <div class="carousel__item">
          <img src="img/turing-machines/exampe-1/07.svg">
        </div>
        <div class="carousel__item">
          <img src="img/turing-machines/exampe-1/08.svg">
        </div>
      </div>
    </div>
  </div>
  <p class="main-column">
    Sie können sich das Band auch als Magnetband vorstellen, das nach
    vorn oder nach hinten gespult wird, anstatt dass der Kopf sich
    bewegt. Am Anfang steht auf dem Band das
    <i>Eingabewort</i>
    und der Kopf
    auf dem ersten Symbol dieses Wortes. Die Turingmaschine wendet nun
    ihre Regeln an, bis Sie einen
    <i>Endzustand</i>
    erreicht. Bei
    <span class="nowrap"><i>Entscheidungsproblemen</i>,</span>
    wo uns nur eine Ja/Nein-Antwort
    interessiert, wird die Antwort durch den Entzustand angegeben: der
    Zustand $\qaccept$ entspricht einem
    <span class="nowrap"><i>Ja</i>,</span>
    der Zustand $\qreject$
    entspricht einem
    <span class="nowrap"><i>Nein</i>.</span>
    Diese zwei Endzustände reichen im
    Allgemeinen aus. Wenn wir von der Maschine eine komplexere Ausgabe
    als Ja/Nein erwarten, so betrachten wir als
    <i>Ausgabe der
      Turingmaschine</i>
    den Inhalt des Bandes zu dem Zeitpunkt, da die
    Maschine den Zustand $\qaccept$ erreicht. Was brauchen wir also,
    um so eine Turingmaschine und ihre Arbeitsweise zu beschreiben?
  </p>
  <div class="well statement out">
    <p>
      <b>Definition</b>
      <b>8.1.1</b>
      <b>(Turingmaschine).</b>
      Eine Turingmaschine besteht aus folgenden
      Elementen:
    </p>
    <ol>
      <li>
        <p>
          Einem endlichen Eingabe-Alphabet $\Sigma$ . Dies sind die
          Symbole, die für das Eingabewort in Frage kommen.
        </p>
      </li>
      <li>
        <p>
          Einem endlichen Bandalphabet
          <span class="nowrap">$\Gamma$;</span>
          das sind die Symbole,
          die auf dem Band stehen dürfen. Offensichtlich muss
          $\Sigma \subseteq \Gamma$ gelten. Jede Zelle kann genau ein
          Zeichen aus $\Gamma$ enthalten. Darüberhinaus gibt es noch
          das sogenannte Blanksymbol
          <span class="nowrap">$\square \in \Gamma \setminus \Sigma$.</span>
          Dies zeigt an, dass
          die Zelle im Moment leer ist. Im obigen Beispiel ist die
          Zelle links vom ersten $a$ beispielsweise leer. Am Anfang
          steht auf dem Band also ein Eingabewort $w \in \Sigma^*$ und
          rechts und links davon unendlich viele $\square$ -Symbole.
        </p>
      </li>
      <li>
        <p>
          Einer endliche Menge $Q$ an inneren Zuständen. Dies
          entspricht in etwa den Prozessor-Registern eines Computers.
          Ein Zustand $\texttt{start} \in Q$ ist der Startzustand, in
          welchem sich die Maschine zu Beginn befindet.
        </p>
      </li>
      <li>
        <p>
          Einer Zustandsübergangsfunktion
          <span class="nowrap">$\delta$,</span>
          die sagt, was die
          Turingmaschine tun soll, wenn Sie im Zustand $q$ ist und
          Zeichen $s$ liest. Formal:
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          \delta : Q \times \Gamma \rightarrow Q \times \Gamma \times \lsr \ ,
          \end{align*}
          $$
        </div>
        <p>
          wobei
          <code>L</code>
          für
          <i>gehe eine Zelle nach links</i>
          <span class="nowrap">steht,<code>R</code></span>
          für
          rechts und
          <code>S</code>
          für
          <span class="nowrap"><i>stay</i>,</span>
          also die Anweisung, den Kopf nicht
          zu bewegen.
        </p>
      </li>
      <li>
        <p>
          Zwei besonderen Zuständen $\qaccept$ und
          <span class="nowrap">$\qreject$.</span>
        </p>
      </li>
    </ol>
  </div>
  <p class="main-column">
    Für die Turingmaschine in dem obigen Beispiel haben wir zwei
    Regeln gesehen:
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \delta(q_2, b)&amp;= (q_3, a, \texttt{R}) \\
    \delta(q_3, \#)&amp;= (q_4, b, \texttt{L})
    \end{align*}
    $$
  </div>
  <h3 class="main-column subtopic-announcement">
    Was macht eine Turingmaschine?
  </h3>
  <p class="main-column">
    Sie haben nun wohl bereits eine vage Vorstellung, was eine
    Turingmaschine macht. Versuchen wir, es noch weiter zu
    formalisieren. Um den
    <i>Gesamtzustand</i>
    der Turingmaschine zu
    beschreiben, also eine vollständige Momentaufnahme, reicht nicht
    der aktuelle innere Zustand
    <span class="nowrap">$q$;</span>
    wir brauchen auch den Bandinhalt
    und insbesondere die Position, an der sich der Kopf befindet. Das
    alles zusammen nennt man die
    <span class="nowrap"><i>Konfiguration der Turingmaschine</i>.</span>
    Wir wollen sie mit uns bereits bekannten mathematischen Begriffen
    beschreiben.
  </p>
  <figure class="main-column">
    <img
      loading="lazy"
      src="img/turing-machines/configuration.svg"
      style="height:20em"
      class="constrained transition-all"
      onClick="onImgClick(event)"
    >
  </figure>
  <div class="well statement out">
    <p>
      <b>Definition</b>
      <b>8.1.2</b>
      Die
      <i>Konfiguration</i>
      einer Turingmaschine ist ein Element in
      <span class="nowrap">$\Gamma^* \times Q \times \Gamma^*$,</span>
      also
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      C = u q v
      \end{align*}
      $$
    </div>
    <p>
      wobei $uv \in \Gamma^*$ der Bandinhalt ist, der
      Schreib-Lese-Kopf auf dem ersten Zeichen von $v$ steht und $q$
      der innere Zustand der Turingmaschine ist. Das $q$ in $C$
      kennzeichnet also sowohl die Position des Schreib-Lese-Kopfes auf
      dem Band sowie den inneren Zustand Die Menge aller
      Konfigurationen ist
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \mathcal{C} := \Gamma^* \times Q \times \Gamma^*
      \end{align*}
      $$
    </div>
    <p>
      Der
      <i>Zustand einer Konfiguration</i>
      $C = uqv$ ist
      <span class="nowrap">$q$,</span>
      also der
      innere Zustand, in dem sich die Maschine gerade befindet. Wir
      bezeichnen mit
      <span class="nowrap">$\state(C)$.</span>
      Formal:
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \state: \mathcal{C}&amp;\rightarrow Q \\
      uqv&amp;\mapsto q \ .
      \end{align*}
      $$
    </div>
    <p>
      Eine Konfiguration $C$ ist eine
      <i>akzeptierende Endkonfiguration</i>
      wenn $\state(C) = \qaccept$ ist; eine
      <i>ablehnende
        Endkonfiguration</i>
      , wenn $\state(C) = \qreject$ ist. In beiden
      Fällen ist $C$ eine
      <span class="nowrap"><i>Endkonfiguration</i>.</span>
    </p>
  </div>
  <p class="main-column">
    Wenn also das Eingabewort $w \in \Sigma^*$ und $\qstart$ der
    Startzustand ist, dann ist
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    C_{\rm start} = \qstart{} w
    \end{align*}
    $$
  </div>
  <p class="main-column">
    die
    <span class="nowrap"><i>Startkonfiguration</i>.</span>
  </p>
  <div class="well alert-info out main-column">
    <p>
      <span class="nowrap"><b>Die Rolle des
          <span class="nowrap">$\square$-Symbols</span></b>.</span>
      Das Band der Turingmaschine
      ist ja unendlich. Um eine Momentaufnahme dennoch als endliches
      Objekt beschreiben zu können, lassen wir die $\square$ -Symbole
      links und rechts vom "eigentlichen" Bandinhalt weg. Bei einer
      Konfiguration $uqv$ stehen also links vom $u$ und rechts vom $v$
      unendlich viele $\square$ -Symbole auf dem Band. Nach der
      formalen Definition $uqv \in \Gamma^* \times Q \times \Gamma^*$
      ist es nicht verboten, dass $u$ auch mit einem
      <span class="nowrap">$\square$-Symbol</span>
      beginnt oder $v$ mit einem aufhört. Allerdings wären die
      Konfiguration $\square u q v$ und $u q v \square$ genauso gut
      mit $u q v$ beschrieben. Wir können uns also auf die Konvention
      einigen, dass $\square$ nie am Rande einer Konfiguration $uqv$
      steht. Beachten Sie auch, dass die Zellen nicht "numeriert" sind.
      Die beiden folgenden Momentaufnahmen
    </p>
    <figure>
      <img
        loading="lazy"
        src="img/turing-machines/configuration-two.svg"
        style="height:18em"
        class="constrained transition-all"
        onClick="onImgClick(event)"
      >
    </figure>
    <p>
      können also beide mit der Konfiguration $aAAaq\#ba$ beschrieben
      werden, obwohl die Zellen nun andere Inhalte haben, weil die
      Turingmaschine es irgendwie geschafft hat, den ganzen Bandinhalt
      um eins nach rechts zu kopieren. Es sollte klar sein, dass die
      Turingmaschine keine Möglichkeit hat, die obere von der unteren
      Situation zu unterscheiden, und dass es somit nur recht und
      billig ist, beide als eine identische Konfiguration aufzufassen.
      All diese Schwierigkeiten verschwinden, wenn wir uns den Speicher
      einer Turingmaschine nicht als unendliches Band vorstellen,
      sondern als zwei Stapel, einer links vom Kopf und einer rechts
      vom Kopf. Allerdings hat sich die Vorstellung vom Band irgendwie
      als Standard durchgesetzt. Hier sehen Sie die gleiche
      Konfiguration in dem Modell mit zwei Stapeln:
    </p>
    <figure>
      <img
        loading="lazy"
        src="img/turing-machines/two-stacks.svg"
        style="height:18em"
        class="constrained transition-all"
        onClick="onImgClick(event)"
      >
    </figure>
    <p>
      Alternativ können wir auch der Turingmaschine verbieten, das
      Blank-Symbol $\Box$ jemals zu schreiben. Dann wäre also
      <span class="nowrap">$\delta: Q \times \Gamma \rightarrow Q \times (\Gamma
        \setminus \{\Box\}) \times \lsr$.</span>
      All diese Betrachtungsweisen unterscheiden sich nicht wesentlich.
      Wir bleiben bei unserem "alten"
      <span class="nowrap">$\delta$,</span>
      erlauben also, $\Box$
      zu schreiben, und leben damit, dass $uqv$ und
      $\Box \Box u q v \Box$ formal zwei verschiedene Konfigurationen
      sind, auch wenn beide irgendwie das selbe beschreiben.
    </p>
  </div>
  <p class="main-column">
    Formal definiert $\delta$ nun auch eine Funktion auf der Menge der
    Konfigurationen:
  </p>
  <div class="well statement out">
    <p>
      <b>Definition</b>
      <b>8.1.3</b>
      <b>(erweiterte Zustandsübergangsfunktion)</b>
      Die erweiterte
      Zustandsübergangsfunktion einer Turingmaschine ist
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \hat{\delta} : \mathcal{C} \rightarrow \mathcal{C} \
      \end{align*}
      $$
    </div>
    <p>
      Sie beschreibt für eine Konfiguration
      <span class="nowrap">$C$,</span>
      welches die
      Konfiguration im nächsten Schritt ist. Per Konvention legen wir
      fest, dass $\hat{\delta}(C) = C$ gilt, wenn $C$ eine
      Endkonfiguration ist.
    </p>
  </div>
  <p class="main-column">
    Unsere obige Turingmaschine hat beispielsweise die Regeln
    $\delta(q_2,b) = (q_3, a,R)$ und
    <span class="nowrap">$\delta(q_3, \#) = (q_4, b, \texttt{L})$,</span>
    und somit würden
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \hat{\delta}(aaAq_2b\#ba)&amp;= aaAaq_3\#ba \\
    \hat{\delta}(aaAaq_3\#ba)&amp;= aaAq_4abba \\
    \hat{\delta}(abAq_2bba\#)&amp;= abAaq_3ba\# \\
    \end{align*}
    $$
  </div>
  <p class="main-column">
    gelten. Sie sehen: Die Definition von $\hat{\delta}$ ist nichts
    wirklich Tiefgründiges, sondern einfach eine Implementierung der
    Turingmaschinen-Momentaufnahme mit uns bereits geläufigen
    mathematischen "Datenstrukturen" (hier: der Menge
    <span class="nowrap">$\Gamma^* \times Q \times \Gamma^*$).</span>
    Stellen Sie sich einfach
    vor, Sie müssten eine Turingmaschine in Java implementieren. Dann
    würden Sie es wahrscheilich irgendwie so ähnlich machen.
  </p>
  <h3 class="main-column subtopic-announcement">
    Ausgabekonfiguration einer Turingmaschine
  </h3>
  <p class="main-column">
    Die Funktion $\hat{\delta}$ bildet aus einer Konfiguration die
    Folgekonfiguration. Wir definieren nun
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \hat{\delta}^{(i)} (C) := \underbrace{\hat{\delta}(\hat{\delta}(\dots (\hat{\delta}}_{i \textnormal{
    mal}} (C) \dots)))
    \end{align*}
    $$
  </div>
  <p class="main-column">
    also die Konfiguration, die die Turingmaschine nach $i$
    Rechenschritten erreicht hat. Weiterhin definieren wir
    $\hat{\delta}^* (C)$ als die Endkonfiguration, die bei
    wiederholter Anwendung von $\hat{\delta}$ schlussendlich erreicht
    wird. Hier taucht ein Problem auf: es ist nicht gesagt, dass die
    Turingmaschine, von Konfiguration $C$ beginnend, überhaupt
    irgendwann in einer Endkonfiguration landen wird. Daher kann
    $\hat{\delta}^*$ auch
    <code>undefined</code>
    sein:
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \hat{\delta}^* (C) := \begin{cases}
    \hat{\delta}^{(i)} (C)&amp;
    \textnormal{ wenn es ein \(i\) gibt, so dass $\hat{\delta}^{(i)} (C)$ eine Endkonfiguration ist} \\
    \texttt{undefined}&amp;\textnormal{sonst.}
    \end{cases}
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Nochmal zur Verdeutlichung: wenn $\delta^{(i)}(C)$ eine
    Endkonfiguration ist, dann ist auch $\delta^{(j)}(C)$ eine, für
    jedes
    <span class="nowrap">$j \geq i$,</span>
    weil wir $\hat{\delta}(C') = C'$ für jede
    Endkonfiguration $C'$ definiert haben. Es spielt also in der
    obigen Formulierung
    <i>wenn es ein $i$ gibt</i>
    keine Rolle, welches
    solche $i$ wir wählen. Für ein Eingabewort $x \in \Sigma^*$ können
    wir nun das Ergebnis der Berechnung von Turingmaschine $M$ auf
    $x = x_1 \dots x_n$ definieren:
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \hat{M}(x) := \hat{\delta}^* (\qstart{} x_1 x_2 x_3 \dots x_n) \ .
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Wir beginnen also mit der Startkonfiguration und lassen die
    Turingmaschine dann laufen, bis sie einen Endzustand erreicht. Die
    erreichte Konfiguration bezeichnen wir mit
    <span class="nowrap">$\hat{M}(x)$.</span>
    Falls nie
    ein Endzustand erreicht wird (die Turingmaschine also endlos
    läuft), ist $\hat{M}(x)$
    <span class="nowrap"><code>undefined</code>.</span>
  </p>
  <h2 class="main-column topic-announcement">
    Sprachen entscheiden
  </h2>
  <p class="main-column">
    Ein
    <i>Entscheidungsproblem</i>
    ist eine Funktion
    <span class="nowrap">$P : \Sigma^* \rightarrow \{\texttt{true}, \texttt{false}\}$,</span>
    beispielsweise:
    <i>gegeben ein Wort, stellt dieses Wort ein korrektes
      Java-Programm dar?</i>
    oder
    <i>gegeben eine Zahl in Dezimalschreibweise,
      ist dies eine Primzahl?</i>
    Eine äquivalente Sichtweise ist die eines
    Entscheidungsproblems als
    <i>Sprache</i>
    <span class="nowrap">$L \subseteq \Sigma^*$.</span>
    Wir
    identifizieren $L$ hier mit der Menge aller Wörter $x$ mit
    <span class="nowrap">$P(x) = \texttt{true}$.</span>
    Wenn wir es mit einem Entscheidungsproblem
    zu tun haben und dieses mit einer Turingmaschine lösen wollen, so
    interessiert uns am Endergebnis $\hat{M}(x)$ (also der erreichten
    Endkonfiguration) nicht der Bandinhalt, sondern nur, ob der Zustand
    <code>accept</code>
    <span class="nowrap">oder<code>reject</code></span>
    ist. Wir definieren daher
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    f_M(x) = \begin{cases}
    \texttt{accept}&amp;\textnormal{ falls $\state(\hat{M}(x)) = \qaccept$, wenn also $\hat{M}(x)$
    eine akzeptierende Endkonfiguration ist, }\\
    \texttt{reject}&amp;\textnormal{ falls $\state(\hat{M}(x)) = \qreject$ ,}\\
    \texttt{undefined}&amp;\textnormal{ falls $\hat{M}(x) = \texttt{undefined}$ }
    \end{cases}
    \end{align*}
    $$
  </div>
  <div class="well statement out">
    <p>
      <b>Definition</b>
      <b>8.1.4</b>
      <b>(Turingmaschine entscheidet eine Sprache)</b>
      Eine Turingmaschine
      $M$
      <i>entscheidet</i>
      die Sprache $L \subseteq \Sigma^*$ wenn
    </p>
    <ol>
      <li>
        <p>
          $f_M(x) = \texttt{accept}$ für alle
          <span class="nowrap">$x \in L$,</span>
        </p>
      </li>
      <li>
        <p>
          $f_M(x) = \texttt{reject}$ für alle
          <span class="nowrap">$x \in \Sigma^* \setminus L$.</span>
        </p>
      </li>
    </ol>
    <p>
      Insbesondere heißt das, dass $M$ auf jedem Eingabewort
      terminiert. Eine Sprache $L$ heißt
      <span class="nowrap"><i>entscheidbar</i>,</span>
      wenn es eine
      Turingmaschine gibt, die sie entscheidet.
    </p>
  </div>
  <div class="well statement out">
    <p>
      <b>Definition</b>
      <b>8.1.5</b>
      <b>(Turingmaschine akzeptiert eine Sprache)</b>
      Eine Turingmaschine
      $M$
      <i>akzeptiert</i>
      die Sprache $L \subseteq \Sigma^*$ wenn
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      x \in L \Longleftrightarrow f_M(x) = \texttt{accept}
      \end{align*}
      $$
    </div>
    <p>
      für alle $x \in \Sigma^*$ gilt. Das heißt, dass $M$ für
      $x \not \in \Sigma^*$ entweder irgendwann den Endzustand
      $\qreject$ erreicht oder nie einen Endzustand erreicht. Eine
      Sprache $L \subseteq \Sigma^*$ heißt
      <span class="nowrap"><i>semi-entscheidbar</i>,</span>
      wenn
      es eine Turingmaschine $M$ gibt, die $L$ akzeptiert.
    </p>
  </div>
  <p class="main-column">
    In beiden Definition verlangen wir natürlich, dass $\Sigma$ das
    Eingabealphabet der Turingmaschine ist.
  </p>
  <h2 class="main-column topic-announcement">
    Funktionen berechnen
  </h2>
  <p class="main-column">
    Oft wollen wir nicht nur eine Sprache $L \subseteq \Sigma^*$
    entscheiden, sondern eine Funktion
    $g: \Sigma_1^* \rightarrow \Sigma_2^*$ berechnen. Mit einer
    Turingmaschine heißt das einfach, dass bei Eingabe
    $x \in \Sigma_1^*$ die Turingmaschine in einer akzeptierenden
    Endkonfiguration $C$ landet, und in $C$ steht dann $g(x)$ auf dem
    Band. Formal müssen wir noch klären, was
    <i>$g(x)$ steht auf dem
      Band</i>
    bedeutet.
  </p>
  <div class="well statement out">
    <p>
      <b>Definition</b>
      <b>8.1.6</b>
      <b>(Turingmaschine berechnet eine Funktion)</b>
      Seien
      $\Sigma_1, \Sigma_2$ zwei endliche Alphabete und
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      g : \Sigma_1^* \rightarrow \Sigma_2^*
      \end{align*}
      $$
    </div>
    <p>
      eine Funktion. Eine Turingmaschine $M$
      <span class="nowrap"><i>berechnet die Funktion
          $g$</i>,</span>
      wenn
    </p>
    <ol>
      <li>
        <p>
          $\Sigma_1$ das Eingabealphabet von $M$ ist,
        </p>
      </li>
      <li>
        <p>
          $\Sigma_1 \cup \Sigma_2 \subseteq \Gamma$ gilt und
          <span class="nowrap">$\square \in \Gamma \setminus (\Sigma_1 \cup \Sigma_2)$;</span>
          das
          Blank-Symbol ist also weder Teil das Eingabealphabets noch
          des Ausgabealphabets.
        </p>
      </li>
      <li>
        <p>
          $M$ terminiert für jedes $x \in \Sigma^*$ .
        </p>
      </li>
      <li>
        <p>
          In der Endkonfiguration $\hat{M}(x)$ steht auf dem
          Arbeitsband das Wort $g(x) \in \Sigma_2^*$ und der Kopf
          steht ganz links, also
          <span class="nowrap">$\hat{M}(x) = \qaccept{} g(x)$.</span>
        </p>
      </li>
    </ol>
  </div>
  <h2 class="main-column topic-announcement">
    Turingmaschinen und formale Grammatiken
  </h2>
  <div class="well statement out">
    <p>
      <b>Theorem</b>
      <b>8.1.7</b>
      Sei $M$ eine Turingmaschine und $L(M)$ die von ihr akzeptierte
      Sprache. Dann gibt es eine formale Grammatik $G$ mit
      <span class="nowrap">$L(G) = L(M)$.</span>
      In anderen Worten: formale Grammatiken sind
      mindestens so mächtig wie Turingmaschinen.
    </p>
  </div>
  <div class="well highlight out">
    <p>
      <b>Beweis.</b>
      Die Idee ist, dass wir eine Grammatik $G$ schreiben, die "in
      umgekehrter Reihenfolge" läuft, also
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \texttt{\$} q_{\rm start} w \texttt{.} \Step{}^* S
      \end{align*}
      $$
    </div>
    <p>
      ableiten kann genau dann, wenn $w \in S$ gilt. Wir brauchen
      \(\texttt{\$}\) und $\texttt{.}$ als Randmarkierungen. Wir
      lassen hier temporär zu, dass die linke Seite ausschließlich aus
      Terminalsymbolen bestehen kann. Hierfür definieren wir für jede
      Regel der Turingmaschine eine Grammatik-Regel:
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \begin{array}{lcl}
      \delta(q,x) = (r,y,\texttt{S} )&amp;\textnormal{wird zur Produktion}&amp;qx \rightarrow ry \\
      \delta(q,x) = (y,r,\texttt{R})&amp;\textnormal{wird zur Produktionen}&amp;qx \rightarrow yr \\
      \delta(q,x) = (y,r,\texttt{L})&amp;\textnormal{wird zu den Produktionen}&amp;aqx \rightarrow ray
      \textnormal{ für alle $a \in \Gamma$}
      \end{array}
      \end{align*}
      $$
    </div>
    <p>
      Die Asymmetrie zwischen den Regeln, die den Kopf nach rechts
      verschieben und denen, die ihn nach links verschieben, ergibt
      sich aus unserer Konvention, die Konfigurationen $uqv$ so zu
      interpretieren, dass der Kopf auf dem ersten Symbol von $v$ und
      nicht etwa auf dem letzten von $u$ steht. Ein Problem ergibt
      sich, wenn $q$ am Rand steht. Hierfür erlauben wir, an den
      Rändern der Konfiguration
      <span class="nowrap">$\square$-Symbole</span>
      zu erzeugen:
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \texttt{\$}&amp;\rightarrow \texttt{\$} \square \\
      \texttt{.}&amp;\rightarrow \square \texttt{.} \
      \end{align*}
      $$
    </div>
    <p>
      Wenn der Kopf also vor dem $\texttt{.}$ stehen sollte, dann
      können wir
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \texttt{\$}uq\texttt{.} \Step{} \texttt{\$}uq\square \texttt{.}
      \end{align*}
      $$
    </div>
    <p>
      anwenden und dann die Produktion, die der Regel von
      $\delta(q,\square)$ entspricht. Es sollte nun klar sein, dass
      folgendes gilt:
    </p>
    <div class="well statement">
      <p>
        <b>Beobachtung</b>
        <b>8.1.8</b>
        Wenn $\hat{\delta}^{(i)} (uqv) = u'q'v'$ gilt, die
        Turingmaschine also in $i$ Schritten von Konfiguration $uqv$
        nach $u'q'v'$ übergeht, dann gilt in der gerade entwickelten
        Grammatik auch
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \texttt{\$}uqv\texttt{.} \Step{}^* \texttt{\$}\square^* u'q'v'\square^*\texttt{.}
        \end{align*}
        $$
      </div>
    </div>
    <p>
      Als nächstes definieren wir
      <span class="nowrap"><i>Aufräumregeln</i>:</span>
      wenn
      <span class="nowrap">$q = \texttt{accept}$,</span>
      dann können wir jedes Zeichen löschen:
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \texttt{accept}\ x&amp;\rightarrow \texttt{accept} \\
      x\ \texttt{accept}&amp;\rightarrow \texttt{accept}
      \end{align*}
      $$
    </div>
    <p>
      wobei $\texttt{accept}$ ein Nichtterminal der Grammatik ist. Und
      somit gilt auch
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \texttt{\$} u \ \texttt{accept} \ v \texttt{.}&amp;\Step{}^*
      \texttt{\$}\ \texttt{accept} \ \texttt{.}
      \end{align*}
      $$
    </div>
    <p>
      Als letzte Regel definieren wir:
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \texttt{\$ }\ \texttt{accept}\ \texttt{.} \rightarrow S
      \end{align*}
      $$
    </div>
    <p>
      Wir haben nun eine Grammatik mit den folgenden Eigenschaften:
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      M(x_1 x_2 \dots x_n) = \texttt{accept}&amp;\textnormal{ genau dann, wenn }
      \texttt{\$} \texttt{start} x_1 x_2 \dots x_n \texttt{.} \Step{}^* S
      \end{align*}
      $$
    </div>
    <p>
      Wir bauen nun eine weitere Grammatik
      <span class="nowrap">$G$,</span>
      in der wir jede
      Produktion $\alpha \rightarrow \beta$ umdrehen, also durch
      $\beta \rightarrow \alpha$ ersetzen. Zusätzlich definieren wir
      Abschlussregeln
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \texttt{\$}&amp;\rightarrow \epsilon \\
      \texttt{.}&amp;\rightarrow \epsilon \\
      \texttt{start}&amp;\rightarrow \epsilon
      \end{align*}
      $$
    </div>
    <p>
      die die Randmarkierungen ersetzen. In dieser Grammatik gilt nun
      für alle Wörter
      <span class="nowrap">$x \in \Sigma^*$:</span>
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      x \in L(M) \Longleftrightarrow S \rightarrow
      G: S \Step{}^* x
      \end{align*}
      $$
    </div>
    <p>
      und somit gilt
      <span class="nowrap">$L(G) = L(M)$.</span>
      Zusammenfassend besitzt $G$ also
      die Produktionen
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      S&amp;\step{1} \texttt{\$} \ \texttt{accept} \ \texttt{.} \\
      \texttt{accept}&amp;\step{2} x \ \texttt{accept} \ | \ \texttt{accept} \ x \quad
      \tag{ für jedes \(x \in \Gamma\)} \\
      ry&amp;\step{3} qx \quad \tag{ wenn $\delta(q,x) = (r,y, \texttt{S})$}\\
      yr&amp;\step{4} qx \quad \tag{ wenn $\delta(q,x) = (r,y, \texttt{R})$}\\
      ray&amp;\step{5} aqx \quad \tag{ wenn $\delta(q,x) = (r,y, \texttt{L})$, für jedes \(a \in
      \Gamma\)} \\
      \texttt{\$} \square&amp;\step{6} \texttt{\$} \\
      \texttt{.}\square&amp;\step{7} \texttt{.} \\
      \texttt{\$}&amp;\step{8} \epsilon \\
      \texttt{.}&amp;\step{9} \epsilon \\
      \texttt{start}&amp;\step{10} \epsilon
      \end{align*}
      $$
    </div>
    <p>
      Um also ein Wort $x \in L(M)$ abzuleiten, müssen wir die
      akzeptierende Endkonfiguration $C$ von $M(x)$ "erraten" und dann
      per Produktionen 1 und 2 die Wortform \(\texttt{\$}C\texttt{.}\)
      ableiten. Von da an verwenden wir die Produktionen 3, 4, 5, 6, 7,
      um die Berechnung der Turingmaschine $M(x)$ von hinten nach
      vorne zu simulieren, bis wir bei
      \(\texttt{\$} \texttt{start}\ x \texttt{.}\) angelangt sind.
      Dann lassen wir \(\texttt{\$}, \texttt{start}, \texttt{.}\) mit
      den Produktionen 8, 9, 10 verschwinden und haben $x$ abgeleitet.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
    </p>
  </div>
</body>
</html>
