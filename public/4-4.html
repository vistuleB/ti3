<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 4.4 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 4, Section 4</title>
</head>
<body class="page-sub chapter-4 sub-4">
  <div id="menu">
    <div class="menu-left">
      <a href="./index.html">Inhaltsverzeichnis</a>
      <div>
        <a
          href="./4-3.html"
          id="prev-page"
        >&lt;&lt; Kapitel 4.3<span
            id="prev-page-tooltip"
            style="visibility:hidden"
          >4.3 
            Primitive Rekursion kann nicht alles: die Péter-Ackermann-Funktion</span></a>
      </div>
    </div>
    <div class="menu-right">
      <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a>
      <div>
        <a
          href="./5-0.html"
          id="next-page"
        >Kapitel 5 &gt;&gt;<span
            id="next-page-tooltip"
            style="visibility:hidden"
          >5. 
            Reguläre Sprachen</span></a>
      </div>
    </div>
  </div>
  <div class="main-column page-title">
    <p>
      4.4 
      Ein Schritt weiter:  while-Schleifen und
      <span class="nowrap">$\mu$-Rekursion</span>
    </p>
  </div>
  <p class="main-column">
    Primitive Rekursion erlaubt uns Schleifen, allerdings nur in einer
    sehr restriktiven Form:
  </p>
  <div class="main-column">
    <ol>
      <li>
        <p>
          Wir müssen anfangs bereits angeben, wie oft wir die Schleife
          durchlaufen wollen;
        </p>
      </li>
      <li>
        <p>
          wir dürfen nur eine lokale Variable mitführen (und den
          Iterationsindex).
        </p>
      </li>
    </ol>
  </div>
  <p class="main-column">
    Der zweite Punkt ist keine echte Beschränkung, wie wir gesehen
    haben: wenn wir zwei lokale Variablen $a,b$ führen wollen, können
    wir die via der Bijektion ${\rm pair} : \N^2 \rightarrow \N$ in
    <i>eine</i>
    natürliche Zahl codieren. Der erste Punkt allerdings scheint
    eine echte Beschränkung zu sein: wir wissen schließlich nicht
    immer, wie oft wir eine Tätigkeit wiederholen müssen, bis wir
    fertig sind, und ob wir überhaupt jemals fertig werden. Sie kennen
    vielleicht die Collatz-Vermutung.
  </p>
  <h2 class="main-column topic-announcement">
    Die Collatz-Vermutung
  </h2>
  <p class="main-column">
    Wir definieren eine Funktion $f: \N_+ \rightarrow \N_+$ wie folgt:
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    f : \N_+&amp;\rightarrow \N_+ \\
    n&amp;\mapsto
    \begin{cases}
    n/2&amp;\textnormal{ if $n$ even} \\
    3n+1&amp;\textnormal{ if $n$ odd.}
    \end{cases}
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Für eine natürliche Zahl $n$ können wir dann die Collatz-Folge
    definieren:
    <span class="nowrap">$n, f(n), f(f(n)), ...$.</span>
    Man sieht leicht, dass diese
    Folge in einer Schleife landen kann:
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    13 \mapsto 40 \mapsto 20 \mapsto 10 \mapsto 5 \mapsto 16 \mapsto 8 \mapsto 4 \mapsto 2 \mapsto 1
    \mapsto 4 \mapsto 2 \mapsto 1 \dots
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Wir beenden die Sequenz daher üblicherweise, wenn wir bei 1 (und
    somit in dieser Dreierschleife) gelandet sind. Es kann allerdings
    etwas länger dauern:
  </p>
  <figure class="textfigure main-column">
    7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1.
  </figure>
  <p class="main-column">
    Oder noch länger. Wenn wir mit 27 beginnen, dann erhalten wir die
    Folge
  </p>
  <figure class="textfigure main-column">
    27, 82, 41, 124, 62, 31, 94, 47, 142, 71, 214, 107, 322, 161,
    484, 242, 121, 364, 182, 91, 274, 137, 412, 206, 103, 310, 155,
    466, 233, 700, 350, 175, 526, 263, 790, 395, 1186, 593, 1780,
    890, 445, 1336, 668, 334, 167, 502, 251, 754, 377, 1132, 566,
    283, 850, 425, 1276, 638, 319, 958, 479, 1438, 719, 2158, 1079,
    3238, 1619, 4858, 2429, 7288, 3644, 1822, 911, 2734, 1367, 4102,
    2051, 6154, 3077, 9232, 4616, 2308, 1154, 577, 1732, 866, 433,
    1300, 650, 325, 976, 488, 244, 122, 61, 184, 92, 46, 23, 70, 35,
    106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1
  </figure>
  <p class="main-column">
    Experimentieren Sie! Ich habe dafür die Html-Seite
    <a href="./code/primitive-recursion/collatz.html">collatz.html</a>
    erstellt.
    Es scheint: egal, wo Sie anfangen, Sie enden immer bei 1.
    Allerdings wissen wir nicht im Voraus,
    <i>wie oft</i>
    wir die Funktion
    $f$ anwenden müssen. Und wir wissen nicht einmal, ob man immer bei
    1 ankommt, ob es andere Zyklen gibt oder ob es Startwerte gibt, für
    die die Folge einfach nach Unendlich divergiert. Bis zum heutigen
    Tage (Stand 30. April 2024) hat sich die Collatz-Vermutung
    zahlreichen Lösungsversuchung widersetzt und demonstriert
    eindrucksvoll, dass auch mathematische Probleme mit sehr einfacher
    Formulierung extrem schwierig sein können.
  </p>
  <h2 class="main-column topic-announcement">
    While-Schleifen
  </h2>
  <p class="main-column">
    Eine Einschränkung primitiv-rekursiver Funktionen ist also, dass
    wir immer vor der Schleife angeben müssen, wie oft diese
    durchlaufen werden soll. Es gibt also keine
    <span class="nowrap"><code>while</code>-Schleifen.</span>
    Führen wir diese nun ein.
  </p>
  <div class="main-column">
<pre class="listing">
<span class="listing-bol"></span>def While (condition, step):
<span class="listing-bol"></span>    def f(x):
<span class="listing-bol"></span>        temp = x
<span class="listing-bol"></span>        while (condition(temp)):
<span class="listing-bol"></span>            temp = step(temp)
<span class="listing-bol"></span>        return temp
<span class="listing-bol"></span>    return f
</pre>
  </div>
  <div
    _="ExerciseCounter 1"
    class="well exercise out"
  >
    <p>
      <b>Übungsaufgabe 4.4.1</b>
      Schreiben Sie mit Hilfe von
      <span class="nowrap"><code>While</code>,</span>
      <code>PrimRec</code>
      und
      <code>Comp</code>
      eine
      Funktion
      <span class="nowrap"><code>collatzList</code>,</span>
      die aus einer Zahl die Collatz-Folge
      baut, also
    </p>
<pre class="python-prompt">
<span class="python-prompt-carets">&gt;&gt;&gt;</span><span class="python-prompt-content"> collatzList(7)</span>
<span class="python-prompt-ok-response">[]</span>
</pre>
  </div>
</body>
</html>
