<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 9.6 of TI-2 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI-2 - Chapter 9, Section 6</title>
</head>
<body>
  <div id="body-wrapper">
    <div id="top-menu">
      <div id="top-menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./9-5.html"
        >&lt;&lt; Kapitel 9.5<span
            style="visibility:hidden"
            id="top-prev-page-tooltip"
          >Reduktionen</span></a>
      </div>
      <div id="top-menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./9-7.html"
        >Kapitel 9.7 &gt;&gt;<span
            style="visibility:hidden"
            id="top-next-page-tooltip"
          >Beschränkter Speicherplatz</span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        9.6&ensp;Ganz NP reduziert auf SAT: das Cook-Levin-Theorem
      </p>
    </div>
    <p class="main-column">
      Hier eine kurze Übersicht über die Reduktionen, die Sie im
      vorherigen Kapitel kennengelernt haben.
    </p>
    <div class="main-column">
      <ol>
        <li>
          <p>
            <span class="sc">3-Colorability $\leq_p$ CNF-Satisfiability</span>
          </p>
        </li>
        <li>
          <p>
            <span class="sc">CNF-Satisfiability $\leq_p$ 3-SAT</span>
          </p>
        </li>
        <li>
          <p>
            <span class="sc">3-SAT $\leq_p$ 3-Colorability</span>
          </p>
        </li>
        <li>
          <p>
            <span class="sc">3-SAT $\leq_p$ Independent Set</span>
          </p>
        </li>
        <li>
          <p>
            <span class="sc">Hamilton Path $\leq_p$ Hamilton Cycle</span>
          </p>
        </li>
        <li>
          <p>
            <span class="sc">Hamilton Cycle $\leq_p$ Hamilton Path</span>
          </p>
        </li>
      </ol>
    </div>
    <p class="main-column">
      Mit etwas Anstrengung würden wir auch<span class="sc">Hamilton Path $\leq_p$
        CNF-Satisfiability</span>hinkriegen. Alle erwähnten Probleme
      Mitglieder von NP: wir können Ja-Instanzen effizient verifizieren.
      Gibt es in NP "Allzweckwaffen", also Probleme, mit deren Hilfe wir
      <i>alle anderen</i>
      NP-Probleme lösen könnten?
    </p>
    <div class="well statement out">
      <p>
        <b>Definition 9.6.1</b>
        Ein Entscheidungsproblem $L \subseteq \Sigma^*$ heißt
        <span class="nowrap"><i>NP-schwer</i>,</span>
        wenn für jedes Problem $K \in {\rm NP}$ gilt:
        <span class="nowrap">$K \leq_p L$.</span>
        Wenn sich also jedes NP-Problem auf $K$ in
        polynomieller Zeit reduzieren lässt. $L$ ist
        <span class="nowrap">NP-<i>vollständig</i>,</span>
        wenn zusätzlich $L$ selbst in NP ist.
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Theorem 9.6.2 
          (Cook-Levin-Theorem).</b>
        3-SAT ist NP-vollständig. In anderen
        Worten: Sei $L$ ein beliebiges Entscheidgungsproblem aus NP.
        Dann gilt
        <span class="sc">
          $L \leq_p$ 3-SAT</span>.
      </p>
    </div>
    <p class="main-column">
      Wir führen das Zwischenproblem
      <span class="sc">Circuit-SAT</span>
      ein und zeigen
      (1) dass $L \leq_p$
      <span class="sc">Circuit-SAT</span>
      und (2)
      <span class="sc">Circuit-SAT $\leq_p$
        3-SAT</span>
      gilt.
    </p>
    <div class="well statement out">
      <p>
        <b>Problem 9.6.3</b>
        (<span class="sc">Circuit-SAT</span>). Gegeben ein Boolescher Schaltkreis $C$ mit
        $n$ Eingabevariablen. Gibt es ein $x \in \{0,1\}^n$ mit
        <span class="nowrap">$C(x) = 1$?</span>
      </p>
    </div>
    <p class="main-column">
      Offensichtlich gilt
      <span class="sc">CNF-Satisfiability $\leq_p$ Circuit-SAT</span>
      und
      <span class="sc">3-SAT $\leq_p$ Circuit-SAT</span>, da CNF-Formeln (und somit
      auch $3$ -CNF-Formeln) Spezialfälle Boolescher Schaltkreise sind.
    </p>
    <div class="well statement out">
      <p>
        <b>Lemma 9.6.4</b>
        Sei
        <span class="nowrap">$L \in {\rm NP}$.</span>
        Dann gilt
        <span class="sc">$L \leq_p$ Circuit-SAT</span>.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Wir können annehmen, dass
        <span class="nowrap">$L \subset \{0,1\}^*$,</span>
        da wir
        andernfalls eine geeignete Codierung
        $\Sigma \rightarrow \{0,1\}^*$ wählen können. Da $L \in {\rm NP}$
        ist, gibt es ein $k \in \N$ und eine Zertifikatmaschine $M$ mit
        Laufzeit
        <span class="nowrap">$t(n) = n^k$,</span>
        so dass
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        x \in L \Longleftrightarrow \exists z \in \{0,1\}^{t(|x|)}: M(x,z) = \texttt{accept}
        \end{align*}
        $$
      </div>
      <p>
        <span id="_49_hgi_"></span>besagt, dass wir eine Turingmaschine von Laufzeit $t(n)$ in
        einen Schaltkreis $C$ der Größe $O(t(n)^2)$ umformen können, so
        dass
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \forall x \in \{0,1\}^n: \quad x \in L \Longleftrightarrow C(x) = 1 \ .
        \end{align*}
        $$
      </div>
      <p>
        Diese Konstruktion funktioniert für jede Inputgröße
        <span class="nowrap">$n$,</span>
        aber
        wir müssen $n$ natürlich zum Zeitpunkt der Umformung kennen. Der
        gleiche Beweis lässt uns die Zertifikatmaschine
        <span class="nowrap">$M$,</span>
        die zwei
        Inputs $x$ und $z$ nimmt, in einen Schaltkreis $C$ von Größe
        $O(t(n)^2)$ mit $n + t(n)$ Eingabevariablen umformen, so dass
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \forall x \in \{0,1\}^n, z \in \{0,1\}^{t(n)}: \quad
        M(x,z) = \texttt{accept} \Longleftrightarrow C(x,z) = 1
        \end{align*}
        $$
      </div>
      <p>
        Somit gilt für jedes $x \in \{0,1\}^n$ mit
        <span class="nowrap">$t := t(n)$:</span>
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        x \in L \quad&amp;\Longleftrightarrow \exists z \in \{0,1\}^t: M(x,z) = \texttt{accept} \\
        &amp;
        \Longleftrightarrow \exists z \in \{0,1\}^t: C(x,z) = 1 \ . \\
        \end{align*}
        $$
      </div>
      <p>
        Unsere Reduktion von $L$ auf
        <span class="sc">Ciruit-SAT</span>
        geht nun wie
        folgt: Bei Eingabewort $x \in \{0,1\}^*$ setzen wir $n := |x|$
        und
        <span class="nowrap">$t := t(n)$.</span>
        Wir führen die Umformung von $M$ in einen
        Schaltkreis $C$ durch. Dieser $C$ hat $n + t$ Eingabevariablen,
        $n$ viele für das Eingabeband von $M$ und $t$ viele für das
        Zertifikatband. Da wir $x$ bereits kennen, verkabeln wir es fest
        in
        <span class="nowrap">$C$,</span>
        d.h. wir ersetzen die
        <span class="nowrap">$i$-te</span>
        Eingabevariable von $C$
        durch den Booleschen Wert $x_i$ (dies ist eine Konstante, keine
        Variable, da wir ein konkretes Eingabewort $x \in \{0,1\}^n$
        gegebenen haben) und erhalten einen Schaltkreis
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        D := C(x, \cdot)
        \end{align*}
        $$
      </div>
      <p>
        mit $t$ Eingabe-Gates. Nach Konstruktion gilt
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        x \in L&amp;\Longleftrightarrow \exists z \in \{0,1\}^t : D(z) = 1
        \end{align*}
        $$
      </div>
      <p>
        also genau dann, wenn
        <span class="sc">$D \in$ Circuit-SAT</span>.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Lemma 9.6.5</b>
        <span class="sc">Circuit-SAT</span>
        $\leq_p$
        <span class="sc">3-SAT</span>.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Wir haben also einen Schaltkreis $C$ mit $n$ Eingabe-Variablen
        und $m$ Gates gegeben. Unsere Aufgabe ist es, eine
        <span class="nowrap">$3$-CNF-Formel</span>
        $F$ zu bauen, so dass $F$ genau dann erfüllbar ist, wenn $C$
        erfüllbar ist. Wir demonstrieren die Umformung an einem Beispiel:
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:16em"
            src="img/09-complexity-theory/circuit-to-3-cnf/circuit-to-3-cnf-01-01.svg"
          >
        </figure>
      </div>
      <p>
        Ich will zuerst diskutieren, was
        <i>nicht</i>
        geht. Der obige
        Schaltkreis (so wie jeder) berechnet eine Funktion
        $f_C: \{0,1\}^n \rightarrow \{0,1\}$ . Das Problem
        <span class="sc">Circuit-SAT</span>
        fragt nun, ob $f_C$ nicht die konstante
        Nullfunktion ist. Wir können im Allgemeinen $f_C$
        <i>nicht</i>
        als $3$
        -CNF-Formel schreiben. Obigen Schaltkreis zum Beispiel nicht. Wir
        können $f_C$ allgemein als CNF-Formel schreiben mit der
        Wahrheitstabellenmethode. Hierfür brauchen wir aber $2^n$
        Schritte, und unsere Reduktion wäre nicht mehr polynomiell.
        Allerdings muss die $3$ -CNF-Formel
        <span class="nowrap">$F$,</span>
        also das Ergebnis der
        Reduktion, auch nicht äquivalent zu $C$ sein, sondern nur
        <span class="nowrap"><i>SAT-äquivalent</i>:</span>
        $F$ muss genau dann erfüllbar sein, wenn $C$
        erfüllbar ist. Wenden wir uns obigem Schaltkreis zu. Wir führen
        für jedes Gate eine Variable ein, die seinen Output darstellen
        soll. Hier sind das
        <span class="nowrap">$g_1, g_2, \dots, g_{11}$:</span>
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:16em"
            src="img/09-complexity-theory/circuit-to-3-cnf/circuit-to-3-cnf-01-02.svg"
          >
        </figure>
      </div>
      <p>
        Die Aussage
        <i>$g_4$ ist der Output des zweiten OR-Gates von
          links</i>
        können wir nun schreiben als
        <span class="nowrap">$g_4 \leftrightarrow (x \vee y)$.</span>
        Das $\leftrightarrow$ ist
        hierbei der Boolesche Operator, der Gleichheit testet. Wir tun
        dies für jedes Gate und erhalten folgende Formel:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        &amp;(g_1 \leftrightarrow (\neg x)) \quad \wedge \\
        &amp;(g_2 \leftrightarrow (\neg y)) \quad \wedge \\
        &amp;(g_3 \leftrightarrow (g_1 \vee g_2)) \quad \wedge \\
        &amp;(g_4 \leftrightarrow (x \vee y)) \quad \wedge \\
        &amp;(g_5 \leftrightarrow (g_3 \wedge g_4)) \quad \wedge \\
        &amp;(g_6 \leftrightarrow (\neg z)) \quad \wedge \\
        &amp;(g_7 \leftrightarrow (\neg w)) \quad \wedge \\
        &amp;(g_8 \leftrightarrow (g_6 \vee g_7)) \quad \wedge \\
        &amp;(g_9 \leftrightarrow (z \vee w)) \quad \wedge \\
        &amp;(g_{10} \leftrightarrow (g_8 \wedge g_9)) \quad \wedge \\
        &amp;(g_{11} \leftrightarrow (g_{5} \vee g_{10}))\\
        &amp;(g_{11})
        \end{align*}
        $$
      </div>
      <p>
        Die ersten 11 Teilausdrücke stellen sicher, dass jedes $g_i$ den
        "richtigen" Wert annimmt. Mit dem letzten Teilausdruck $(g_{11})$
        drücken wir aus, dass wir wollen, dass der Schaltkreis $1$
        ausgibt. Es gilt nun:
      </p>
      <ol>
        <li>
          <p>
            Wenn eine Belegung der Variablen
            $(x, y, z, w, g_1, \dots, g_{11})$ die Formel $F$ erfüllt,
            dann haben alle Variablen $g_i$ den Wert, den das
            entsprechende Gate ausgibt, und somit gilt
            <span class="nowrap">$C(x,y,z,w) = 1$.</span>
          </p>
        </li>
        <li>
          <p>
            Falls $C(x,y,z,w) = 1$ gilt, dann können wir $g_i$ auf den
            Output-Wert des
            <span class="nowrap">$i$-ten</span>
            Gates setzen und erhalten eine
            Belegung der Variablen
            <span class="nowrap">$(x, y, z, w, g_1, \dots, g_{11})$,</span>
            die $F$ erfüllt.
          </p>
        </li>
      </ol>
      <p>
        Im allgemeinen gilt also für jedes
        <span class="nowrap">$x \in \{0,1\}^n$:</span>
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        C(x) = 1 \Longleftrightarrow \exists g \in \{0,1\}^m: F(x,g) = 1 .
        \end{align*}
        $$
      </div>
      <p>
        Die obige Formel ist nicht in konjunktiver Normalform, da jeder
        Teilausdruck Operatoren wie $\leftrightarrow$ etc. enthält.
        Jeder Teilausdruck ist aber in sich eine Formel mit drei
        Variablen; somit können wir eine Wahrheitstabelle mit $8$ Zeilen
        anlegen und ihn in eine äquivalente 3-CNF-Formel mit maximal $8$
        Klauseln umformen. Die schlussendliche $3$ -CNF-Formel hat somit
        $n + m$ Variable (die Eingabevariablen von $C$ plus eine für
        jedes Gate) und maximal $8m + 1$ Klauseln, von denen jede
        höchstens drei Variable enthält.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <div id="end-of-page-elt">
    </div>
    <hr id="bottom-menu-hr">
    <div id="bottom-menu">
      <div id="bottom-menu-left">
        <a href="./9-5.html">&lt;&lt; Kapitel 9.5<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >Reduktionen</span></a>
      </div>
      <div id="bottom-menu-right">
        <a href="./9-7.html">Kapitel 9.7 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >Beschränkter Speicherplatz</span></a>
      </div>
    </div>
  </div>
</body>
</html>
