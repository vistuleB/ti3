<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 5.5 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="ti3.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./ti3.js"></script>
  <title>TI3 - Chapter 5, Section 5</title>
</head>
<body class="page-sub chapter-5 sub-5">
  <div
    path="./5-5.html"
    class="subchapter"
  >
    <div class="menu">
      <div class="menu-left">
        <a href="./index.html">Inhaltsverzeichnis</a><a
          href="./5-4.html"
          id="prev-page"
        >&lt;&lt; Kapitel 5.4</a>
      </div>
      <div class="menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          href="./5-6.html"
          id="next-page"
        >Kapitel 5.6  &gt;&gt;</a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        5.5 
        Reguläre Ausdrücke
      </p>
    </div>
    <p class="main-column">
      Wir werden nun eine weitere Weise finden, reguläre
      Sprachen zu beschreiben: neben regulären Grammatik (ob
      normal, erweitert, eingeschränkt), endlichen Automaten
      und nichtdeterministischen endlichen Automaten gibt es
      noch die
      <i>regulären Ausdrücke</i>. Dies wird wahrscheinlich
      von allen Beschreibungsweise die sein, mit der Sie in der
      Praxis am ehesten in Berührung kommen. Wir haben bereits
      in
      <a
        href="./5-1.html#_17_hgi_"
        class=""
      >Kapitel 5.1</a>
      das Baukastenprinzip
      kennengelernt:
    </p>
    <div class="main-column">
      <ol>
        <li>
          <p>
            Wenn $L_1$ und $L_2$ reguläre Sprachen sind, dann
            ist $L_1 \cup L_2$ auch regulär;
          </p>
        </li>
        <li>
          <p>
            dann ist auch die Konkatenation
          </p>
          <div class="math-block">
            $$
            \begin{align*}
            L_1 \circ L_2 := \{\alpha \beta \ | \alpha \in L_1, \beta \in L_2\}
            \end{align*}
            $$
          </div>
          <p>
            regulär;
          </p>
        </li>
        <li>
          <p>
            wenn $L$ regulär ist, dann ist auch ihre Kleenesche
            Hülle
          </p>
          <div class="math-block">
            $$
            \begin{align*}
            L^* := \{ \alpha_1 \dots \alpha_n \ | \ n \geq 0, \alpha_1,\dots,\alpha_n \in L\}
            \end{align*}
            $$
          </div>
          <p>
            regulär.
          </p>
        </li>
      </ol>
    </div>
    <p class="main-column">
      Darüberhinaus haben wir Techniken kennengelernt, um aus
      den gegebenen regulären Grammatiken eine neue Grammatik
      für
      <span class="nowrap">$L_1 \cup L_2$,</span>
      $L_1 \circ L_2$ und $L$ konstruieren
      zu können. Sie sollten sich jetzt folgende Frage stellen:
    </p>
    <div class="display main-column">
      <p>
        <b>Frage:</b>
        Können
        <i>alle</i>
        regulären Sprachen nach diesem
        Baukastenprinzip erstellt werden?
      </p>
    </div>
    <p class="main-column">
      Damit diese Frage überhaupt die Chance hat, mit
      <i>ja</i>
      beantwortet zu werden, müssen wir "Atome" zur Verfügung
      stellen, mit denen wir beginnen können. Daher:
    </p>
    <div class="main-column">
      <ul>
        <li>
          <p>
            Die Sprachen
            <span class="nowrap">$\emptyset$,</span>
            $\{\epsilon\}$ und $\{x\}$
            für jedes $x \in \Sigma$ sind regulär.
          </p>
        </li>
      </ul>
    </div>
    <p class="main-column">
      Aus diesen $|\Sigma|+2$ "Grundbausteinen" und den drei
      Kombinatoren
      <span class="nowrap">$\cup$,</span>
      $\circ$ und $^*$ können Sie jede
      reguläre Sprache zusammenbauen. Dieses Baukastenprinzip
      hat auch einen Namen: reguläre Ausdrücke. Definieren wir
      diese nun formal.
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>5.5.1</b>
        Sei $\Sigma$ einendliches Alphabet. Die regulären
        Audrücke über $\Sigma$ sind induktiv definiert wie
        folgt und beschreiben folgende Sprachen:
      </p>
      <ul>
        <li>
          <p>
            <b>Atome.</b>
            $\emptyset$ ist ein regulärer Ausdruck
            und beschreibt die Sprache
            <span class="nowrap">$\emptyset$.</span>
            $\epsilon$
            ist ein regulärer Ausdruck und beschreibt die
            Sprache
            <span class="nowrap">$\{\epsilon\}$.</span>
            Jedes einzelne Zeichen
            $x \in \Sigma$ ist ein regulärer Ausdruck und
            beschreibt die Sprache
            <span class="nowrap">$\{x\}$.</span>
          </p>
        </li>
        <li>
          <p>
            <b>Alternative.</b>
            Wenn $R_1, R_2$ reguläre Ausdrücke
            über $\Sigma$ sind und die Sprachen $L_1$ und $L_2$
            beschreiben, so ist $(R_1 | R_2)$ ein regulärer
            Ausdruck und beschreibt die Sprache $L_1 \cup L_2$
            (die regulär ist, wie wir in
            <a
              href="./5-1.html#_17_hgi_"
              class=""
            >Kapitel 5.1</a>
            gesehen haben).
          </p>
        </li>
        <li>
          <p>
            <b>Konkatenation.</b>
            $(R_1R_2)$ ist ein regulärer
            Ausdruck, der die Sprache $L_1 \circ L_2$
            beschreibt (die auch wiederum regulär ist). Der
            Deutlichkeit halber schreiben wir auch manchmal
            <span class="nowrap">$R_1 \circ R_2$.</span>
          </p>
        </li>
        <li>
          <p>
            <b>Kleenesche Hülle.</b>
            Wenn $R$ ein regulärer
            Ausdruck ist und die Sprache $L$ beschreibt, dann
            ist $(R^*)$ ein regulärer Ausdruck und beschreibt
            die Sprache
            <span class="nowrap">$L^*$.</span>
          </p>
        </li>
      </ul>
      <p>
        Weil in der Praxis neben
        <span class="nowrap">$L^*$,</span>
        also beliebig langen,
        möglicherweise leeren Folgen von $L$ -Wörtern wir oft
        <i>nichtleere</i>
        Folgen wollen, führen wir die Abkürzung
        $R^+$ für $R (R^*)$ ein und bezeichnen die
        beschriebene Sprache $L \circ L^*$ kurzerhand als
        <span class="nowrap">$L^+$.</span>
      </p>
    </div>
    <p class="main-column">
      In konkreten fällen lassen gerne die Klammerung weg,
      wenn keine Verwechslungsgefahr besteht. Auch gehen wir
      davon aus, dass die Operatoren die Präzedenz $^*$ vor
      $\circ$ vor $|$ haben (wie
      <i>hoch</i>
      vor
      <i>Punkt</i>
      vor
      <i>Strich</i>
      in der Arithmetik), sodass beispielsweise der
      Ausdruck $a^*b|c^*$ die Bedeutung von $(((a^*)b)(c^*))$
      hat, genauso wie wir in der Arithmetik $a^2 b + c^3$
      statt $(((a^2)b) + c^3)$ schreiben. Die von den atomaren
      Ausdrücken beschriebenen Sprachen sind alle regulär, da
      sie alle
      <i>endliche Sprachen</i>
      sind. Dank unserer Vorarbeit
      aus
      <a
        href="./5-1.html#_17_hgi_"
        class=""
      >Kapitel 5.1</a>
      wissen wir, dass Alterantive,
      Konkatenation und Kleenesche Hülle wiederum reguläre
      Sprachen erzeugen. Wir erhalten das folgende Ergebnis:
    </p>
    <div
      id="_24_hgi_"
      class="well statement out"
    >
      <p>
        <b>Lemma</b>
        <b>5.5.2</b>
        Die von einem regulären Ausdruck $R$ beschriebene
        Sprache $L(R)$ ist regulär.
      </p>
    </div>
    <p class="main-column">
      Es ist Zeit für ein paar Beispiele.
    </p>
    <div class="well statement out">
      <p>
        <b>Beispiel</b>
        <b>5.5.3</b>
        Nehmen wir die Sprache der Wörter der Form
        <code>bla:bla:blu.xyz-12-ab.b:x</code>
        aus dem letzten Kapitel.
        Sie erinnern sich: eine endliche Folge von
        <i>Labels</i>, wo
        ein Label eine nichtleere Folge von Blöcken ist, die
        entweder
        <code>:</code>
        oder durch
        <code>-</code>
        separiert sind, wobei
        innerhalb eines Labels immer nur ein Separatortyp
        vorkommen darf, und wobei ein Block eine nichtleere
        Folge von alphanumerischen Zeichen ist (wir haben uns
        dann auf den Buchstaben $a$ beschränkt). Sehen Sie,
        dass bereits unsere natürlichsprachliche Beschreibung
        von $L$ von dem Baukastenprinzip gebraucht macht. Wenn
        wir nun einen regulären Ausdruck für $L$ erstellen
        wollen, so können wir bequem Stück für Stück vorgehen.
        Ein Block ist eine nichtleere Folge von
        <span class="nowrap">$a$'s.</span>
        Der
        entsprechende reguläre Ausdruck $B$ für Blöcke ist
        also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        B : = a^+
        \end{align*}
        $$
      </div>
      <p>
        Für ein Label müssen wir uns entscheiden, ob wir die
        Blöcke mit
        <code>:</code>
        oder
        <code>-</code>
        separieren; wir erhalten den
        regulären Ausdruck $T$ für Labels ist also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        T := B ({:}B)^* | B (\text{-}B)^*
        \end{align*}
        $$
      </div>
      <p>
        Sehen Sie, dass wir in $T$ das erste $B$
        "ausfaktorisieren" können und statt dem obigen
        folgenden Ausdruck schreiben können:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        T' := B ( ({:}B)^* | (\text{-}B)^* )
        \end{align*}
        $$
      </div>
      <p>
        Beide Varianten sind äquivalent, d.h., sie beschreiben
        die gleiche Sprache; die erste Variante, also
        <span class="nowrap">$T$,</span>
        ähnelt mehr dem, was wir in unserer Grammatik bzw. dem
        nichtdeterministischen Automaten für $L$ getan haben,
        während $T'$ eher die Arbeitsweise des
        determinisitschen Automaten reflektiert (wir lesen erst
        einmal einen Block und erst, wenn wir zum ersten mal
        auf
        <code>:</code>
        oder
        <code>-</code>
        stoßen, entscheiden wir uns für den
        "Typ" des Labels). Schlussendlich ist ein Wort in der
        Sprache eine mit
        <code>.</code>
        separierte Folge von Labels, also:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        R := T ({.}T)^*
        \end{align*}
        $$
      </div>
      <p>
        Somit können wir nun den regulären Ausdruck für $L$ in
        seiner ganzen Pracht zeigen:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        R := (a^+ ({:}a^+)^* | a^+ (\text{-}a^+)^*) ({.}(a^+ ({:}a^+)^* | a^+ (\text{-}a^+)^*))^*
        \end{align*}
        $$
      </div>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 5.5.1</b>
        Laden Sie sich
        <a href="./code/regular-expressions/TestRegex.java">TextRegex.java</a>
        herunter, kompilieren und starten Sie es.
      </p>
<pre class="arbitrary-prompt-response">
<span class="terminal-prompt">user@home:~$</span><span class="arbitrary-response"> java TestRegex</span>
<span class="arbitrary-prompt">Please enter a regular expression: </span><span class="arbitrary-response">(a+)(:a+)*</span>
<span class="arbitrary-prompt">Enter words to be matched, one per line</span><span class="arbitrary-response"></span>
<span class="arbitrary-prompt"></span><span class="arbitrary-response">aaaaa:aa:aaaa:a</span>
<span class="arbitrary-prompt">true</span><span class="arbitrary-response"></span>
<span class="arbitrary-prompt"></span><span class="arbitrary-response">aaa:aa:</span>
<span class="arbitrary-prompt">false</span><span class="arbitrary-response"></span>
</pre>
      <p>
        Schreiben Sie nun einen regulären Ausdruck $R$ für die
        obige Sprache und testen Sie ihn mit dem Java-Programm.
      </p>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 5.5.2</b>
        In der Praxis gibt es bei reguläre Ausdrücken viele
        Abkürzung, so beschreibt
        <code>[a-z]</code>
        beispielsweise die
        Menge aller Kleinbuchstaben,
        <code>[aoeiuy]</code>
        beschreibt die
        Menge \{a,o,e,i,u,y\} etc. Der reguläre Ausdruck
        <code>[a-z]*[aeiuoy][a-z]*</code>
        beschreibt also die Menge aller
        Wörter, die mindesten einen Vokal enthalten. Lesen Sie
        hierfür unter Anderem
      </p>
      <div class="display">
        <p>
          <a href="https://www.w3schools.com/java/java_regex.asp">W3School</a>
        </p>
      </div>
      <p>
        und
      </p>
      <div class="display">
        <p>
          <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Patternl.html auf der
            Java-API</a>,
        </p>
      </div>
      <p>
        lassen sich aber bitte nicht von der Menge an Details
        erschlagen. Schreiben Sie nun in der Java-Regex-Syntax
        einen regulären Ausdruck für unsere obige Sprache
        <span class="nowrap">$L$,</span>
        wo Sie aber neben $a$ alle alphanumerischen Zeichen
        zulassen.
      </p>
    </div>
    <h1 class="main-column">
      Einen regulären Ausdruck für jede reguläre Sprache
    </h1>
    <p class="main-column">
      Wir beweisen nun das Gegenstück zu
      <a
        href="./5-5.html#_24_hgi_"
        class=""
      >Lemma 5.5.2</a>:
    </p>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>5.5.4</b>
        Sei $L$ eine reguläre Sprache. Dann gibt es einen
        regulären Ausdruck
        <span class="nowrap">$R$,</span>
        der $L$ beschreibt, also
        <span class="nowrap">$L(R) = R$.</span>
      </p>
    </div>
    <p class="main-column">
      Wir paraphrasieren hier den Beweis aus Michael Sipsers
      <i>Introduction to the Theory of Computation</i>.
    </p>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Zunächst skizzieren wir die Beweisidee. Da $L$ regulär
        ist, gibt es einen nichtdeterministischen endlichen
        Automaten
        <span class="nowrap">$M$,</span>
        die $L$ akzeptiert. Wir werden nun $M$
        Schritt für Schritt in einen regulären Ausdruck
        verwandeln. Kern der Idee ist, dass wir neben den
        üblichen Übergängen
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        q_1 \step{x} q_2
        \end{align*}
        $$
      </div>
      <p>
        komplexere Übergänge wie zum Beispiel
        $q_1 \step{xy} q_2$ zulassen. Die Bedeutung wäre hier
        beispielsweise, dass der Automat von $q_1$ nach $q_2$
        übergehen kann, wenn er die Eingabesymbole $xy$ liest.
        Wir lassen auch komplexere Übergänge wie
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        q_1 \step{x|yz^*} q_2
        \end{align*}
        $$
      </div>
      <p>
        zu, also "von $q_1$ kann der Automat nach $q_2$ gehen,
        wenn er ein $x$ liest oder ein
        <span class="nowrap">$y$,</span>
        gefolgt von
        beliebig vielen $z$ "; ganz allgemein lassen wir
        Übergänge der Form
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        q_1 \step{R} q_2 \ ,
        \end{align*}
        $$
      </div>
      <p>
        wobei $R$ ein regulärer Ausdruck ist. Insbesondere
        lassen wir Übergänge der Form $q_1 \step{\epsilon} q_2$
        zu. Dies bedeutet, dass der Automat von $q_1$ nach
        $q_2$ "springen" kann, ohne ein Eingabesymbol zu
        lesen. Des weiteren verlangen wir, dass es genau einen
        akzeptierenden Endzustand $q_{\rm end}$ mit
        <span class="nowrap">$\qstart \ne q_{\rm end}$,</span>
        und dass es keine Kanten
        gibt, die in $\qstart$ hineingehen, und keine, die aus
        $q_{\rm end}$ hinausgehen. All dies lässt sich leicht
        verwirklichen, wenn wir reguläre Ausdrücke als
        Kantenbeschriftung zulassen. Wir nennen so einen
        Automaten einen
        <i>verallgemeinerten
          nichtdeterministischen endlichen Automaten (VNEA)</i>.
      </p>
      <figure>
        <img
          loading="lazy"
          src="./img/finite-state-automata/to-regex/nea-to-vnea.svg"
          style="height:14em"
          class="constrained transition-all"
          onClick="onImgClick(event)"
        >
      </figure>
      <p>
        Definieren wir nun formal, was VNEAs sind und welche
        Sprache sie akzeptieren:
      </p>
      <div class="well statement">
        <p>
          <b>Definition</b>
          <b>5.5.5</b>
          <b>(Verallgemeinerter nichtdeterministischer endlicher
            Automat, VNEA).</b>
          Ein VNEA besteht aus einem Alphabet
          <span class="nowrap">$\Sigma$,</span>
          einer Zustandsmenge
          <span class="nowrap">$Q$,</span>
          einen
          Startzustand
          <span class="nowrap">$\qstart \in Q$,</span>
          einem akzeptierenden
          Zustand
          <span class="nowrap">$q_{\rm end} \in Q \setminus \{\qstart\}$,</span>
          einer Menge von gerichteten Kanten
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          E \subseteq (Q \setminus \{\qstart\}) \times (Q \setminus \{q_{\rm end}\}) \ .
          \end{align*}
          $$
        </div>
        <p>
          Jede Kante $(q_i, q_j) \in E$ ist mit einem
          regulären Ausdruck $\delta(q_i, q_j)$ beschriftet.
          Wenn $R = \delta(q_i, q_j)$ gilt, dann schreiben wir
          <span class="nowrap">$q_i \step{R} q_j$.</span>
          Wenn $\beta \in L(R)$ gilt,
          $\beta$ also ein Wort in der von $R$ beschriebenen
          Sprache ist, dann schreiben wir auch
          <span class="nowrap">$q_i \step{\beta \in R} q_j$.</span>
          Für $q, q' \in Q$ und
          $\alpha \in \Sigma^*$ schreiben wir
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          q \Step{\alpha} q'
          \end{align*}
          $$
        </div>
        <p>
          wenn man $\alpha$ zerlegen kann als
          $\alpha = \beta_1 \beta_2 \dots \beta_k$ gibt (wobei
          $\beta_i = \epsilon$ zulässig ist) und es eine
          Zustandsfolge $q = q_0, q_1, \dots, q_k = q'$ gibt,
          wobei $(q_{i-1}, q_i)\in E$ ist und mit einem
          regulären Ausdruck $R_i$ beschriftet ist und jedes
          $\beta_i$ in der von $R_i$ beschriebenen Sprache
          ist. Wenn also
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          q_0 \step{\beta_1 \in R_1} q_1 \step{\beta_2 \in R_2} q_2 \dots q_{k-1} \step{\beta_k
          \in R_k} p_k
          \end{align*}
          $$
        </div>
        <p>
          gilt.
        </p>
      </div>
      <p>
        Einen gegebenen NEA können wir leicht in einen VNEA
        transformieren, indem wir, soweit nötig, (1) einen
        neuen Startzustand kreieren (damit dieser keine
        eingehenden Kanten hat), (2) einen neuen Endzustand
        kreieren, (3) "parallele" Übergänge wie
        $(q_i, x, q_j), (q_i, y, q_j)$ zu einer Kante
        zusammenfassen, der dann mit dem regulären Ausdruck
        $x | y$ beschriftet ist. Wir haben den ganzen Aufwand
        betrieben, weil wir für einen VNEA sehr leicht Zustände
        eliminieren können. Wenn wir zum Beispiel
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        q_0 \step{R_1} q_1 \step{R_2} q_2
        \end{align*}
        $$
      </div>
      <p>
        haben, dann können wir ja ein Wort in $R_1 R_2$ lesen
        und direkt von $q_0$ nach $q_2$ übergehen; wir
        brauchen also $q_1$ gar nicht. Wir müssen nur
        aufpassen, das neue $R_1 R_2$ mit einem eventuell
        bereits bestehenden Übergang von $q_0$ nach $q_2$ zu
        kombinieren. Im allgemeinen:
      </p>
      <figure>
        <img
          loading="lazy"
          src="./img/finite-state-automata/to-regex/eliminate-B.svg"
          style="height:10em"
          class="constrained transition-all"
          onClick="onImgClick(event)"
        >
      </figure>
      <p>
        Falls die mit $R_2$ beschriftete Selbstschleife an
        Zustand $B$ nicht existieren sollte, dann schreiben
        wir einfach $R_1R_3$ anstatt
        <span class="nowrap">$R_1 R_2^* R_3$;</span>
        falls
        der Übergang $A \step{R_4} B$ nicht existieren sollte
        , lassen wir das $R_4 |$ im rechten Bild einfach weg.
        (Sipser führt hier den eleganten Formalismus ein, zu
        verlangen, dass
        <i>jedes</i>
        Paar durch eine Kante verbunden
        ist und würde fehlende Kanten einfach mit dem regulären
        Ausdruck $\emptyset$ beschriften.) Wir suchen uns also
        einen Zustand
        <span class="nowrap">$B \in Q \setminus \{\qstart, \qend\}$,</span>
        den wir eliminieren wollen, und führen die oben
        beschriebene
        <span class="nowrap">$B$-Umfahrung</span>
        parallel für alle Paare
        $A,C$ aus, für die es $A \step{} B \step{} C$ gibt.
        Wir erhalten einen VNEA mit einem Zustand weniger, der
        zu dem vorherigen VNEA äquivalent ist, also die gleiche
        Sprache akzeptiert. Wiederholen wir diesen Schritt, so
        erhalten wir am Ende einen Automat mit nur zwei
        Zuständen, nämlich
      </p>
      <figure>
        <img
          loading="lazy"
          src="./img/finite-state-automata/to-regex/nvea-final.svg"
          style="height:2.5em"
          class="constrained transition-all"
          onClick="onImgClick(event)"
        >
      </figure>
      <p>
        Dieser VNEA akzeptiert immer noch die gleiche Sprache
        $L$ wie der ursprüngliche NEA, mit dem wir begonnen
        haben. Welche Sprache ist das? Es ist die Sprache aller
        $\alpha \in \Sigma$ mit
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \qstart \Step{\alpha} \qend
        \end{align*}
        $$
      </div>
      <p>
        Da der Pfad von $\qstart$ nach $\qend$ nur eine Kante
        hat, muss $\alpha$ in der von $R$ beschriebenen
        Sprache liegen. $R$ ist der gesuchte reguläre
        Ausdruck: er beschreibt die Sprache
        <span class="nowrap">$L$.</span><span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p class="main-column">
      Hier sehen Sie den ganzen Ablauf an unserer
      <code>aaaa:a:aaa.aa-aa</code>-Sprache:
    </p>
    <div
      style="padding:1em 0 0.5em;"
      class="main-column"
    >
      <figure style="overflow-x:auto;margin:0 center;">
        <img
          src="./img/finite-state-automata/to-regex/nfsm-to-regex-carpet.svg"
          style="height:20em"
          class="constrained transition-all"
          onClick="onImgClick(event)"
        >
      </figure>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 5.5.3</b>
        Wandeln Sie nach dem eben beschriebenen Schema den
        Automaten
      </p>
      <figure>
        <img
          src="./img/finite-state-automata/nfsm-example-02.svg"
          style="height:10em"
          class="constrained transition-all"
          onClick="onImgClick(event)"
        >
      </figure>
      <p>
        in einen regulären Ausdruck um.
      </p>
    </div>
  </div>
</body>
</html>
