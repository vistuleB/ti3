<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 5.5 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 5, Section 5</title>
</head>
<body>
  <div class="body-wrapper">
    <div id="top-menu">
      <div class="top-menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./5-4.html"
        >&lt;&lt; Kapitel 5.4<span
            style="visibility:hidden"
            id="top-prev-page-tooltip"
          >Von einer regulären Grammatik zu einem endlichen Automaten an einem Beispiel</span></a>
      </div>
      <div class="top-menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./5-6.html"
        >Kapitel 5.6 &gt;&gt;<span
            style="visibility:hidden"
            id="top-next-page-tooltip"
          >Die Grenzen regulärer Sprachen</span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        5.5&ensp;Reguläre Ausdrücke
      </p>
    </div>
    <p class="main-column">
      Wir werden nun eine weitere Weise finden, reguläre Sprachen zu
      beschreiben: neben regulären Grammatik (ob normal, erweitert,
      eingeschränkt), endlichen Automaten und nichtdeterministischen
      endlichen Automaten gibt es noch die
      <span class="nowrap"><i>regulären Ausdrücke</i>.</span>
      Dies
      wird wahrscheinlich von allen Beschreibungsweise die sein, mit der
      Sie in der Praxis am ehesten in Berührung kommen. Wir haben bereits
      in
      <a
        href="./5-1.html#_17_hgi_"
        class=""
      >Kapitel
      </a>
      das Baukastenprinzip kennengelernt:
    </p>
    <div class="main-column">
      <ol>
        <li>
          <p>
            Wenn $L_1$ und $L_2$ reguläre Sprachen sind, dann ist
            $L_1 \cup L_2$ auch regulär;
          </p>
        </li>
        <li>
          <p>
            dann ist auch die Konkatenation
          </p>
          <div class="math-block">
            $$
            \begin{align*}
            L_1 \circ L_2 := \{\alpha \beta \ | \alpha \in L_1, \beta \in L_2\}
            \end{align*}
            $$
          </div>
          <p>
            regulär;
          </p>
        </li>
        <li>
          <p>
            wenn $L$ regulär ist, dann ist auch ihre Kleenesche Hülle
          </p>
          <div class="math-block">
            $$
            \begin{align*}
            L^* := \{ \alpha_1 \dots \alpha_n \ | \ n \geq 0, \alpha_1,\dots,\alpha_n \in L\}
            \end{align*}
            $$
          </div>
          <p>
            regulär.
          </p>
        </li>
      </ol>
    </div>
    <p class="main-column">
      Darüberhinaus haben wir Techniken kennengelernt, um aus den
      gegebenen regulären Grammatiken eine neue Grammatik für
      <span class="nowrap">$L_1 \cup L_2$,</span>
      $L_1 \circ L_2$ und $L$ konstruieren zu können.
      Sie sollten sich jetzt folgende Frage stellen:
    </p>
    <div class="display main-column">
      <p>
        <b>Frage:</b>
        Können
        <i>alle</i>
        regulären Sprachen nach diesem
        Baukastenprinzip erstellt werden?
      </p>
    </div>
    <p class="main-column">
      Damit diese Frage überhaupt die Chance hat, mit
      <i>ja</i>
      beantwortet
      zu werden, müssen wir "Atome" zur Verfügung stellen, mit denen wir
      beginnen können. Daher:
    </p>
    <div class="main-column">
      <ul>
        <li>
          <p>
            Die Sprachen
            <span class="nowrap">$\emptyset$,</span>
            $\{\epsilon\}$ und $\{x\}$ für jedes
            $x \in \Sigma$ sind regulär.
          </p>
        </li>
      </ul>
    </div>
    <p class="main-column">
      Aus diesen $|\Sigma|+2$ "Grundbausteinen" und den drei
      Kombinatoren
      <span class="nowrap">$\cup$,</span>
      $\circ$ und $^*$ können Sie jede reguläre
      Sprache zusammenbauen. Dieses Baukastenprinzip hat auch einen
      Namen: reguläre Ausdrücke. Definieren wir diese nun formal.
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>5.5.1</b>
        Sei $\Sigma$ einendliches Alphabet. Die regulären Audrücke über
        $\Sigma$ sind induktiv definiert wie folgt und beschreiben
        folgende Sprachen:
      </p>
      <ul>
        <li>
          <p>
            <b>Atome.</b>
            $\emptyset$ ist ein regulärer Ausdruck und
            beschreibt die Sprache
            <span class="nowrap">$\emptyset$.</span>
            $\epsilon$ ist ein
            regulärer Ausdruck und beschreibt die Sprache
            <span class="nowrap">$\{\epsilon\}$.</span>
            Jedes einzelne Zeichen $x \in \Sigma$ ist ein regulärer
            Ausdruck und beschreibt die Sprache
            <span class="nowrap">$\{x\}$.</span>
          </p>
        </li>
        <li>
          <p>
            <b>Alternative.</b>
            Wenn $R_1, R_2$ reguläre Ausdrücke über
            $\Sigma$ sind und die Sprachen $L_1$ und $L_2$ beschreiben,
            so ist $(R_1 | R_2)$ ein regulärer Ausdruck und beschreibt
            die Sprache $L_1 \cup L_2$ (die regulär ist, wie wir in
            <a
              href="./5-1.html#_17_hgi_"
              class=""
            >Kapitel
            </a>
            gesehen haben).
          </p>
        </li>
        <li>
          <p>
            <b>Konkatenation.</b>
            $(R_1R_2)$ ist ein regulärer Ausdruck, der
            die Sprache $L_1 \circ L_2$ beschreibt (die auch wiederum
            regulär ist). Der Deutlichkeit halber schreiben wir auch
            manchmal
            <span class="nowrap">$R_1 \circ R_2$.</span>
          </p>
        </li>
        <li>
          <p>
            <b>Kleenesche Hülle.</b>
            Wenn $R$ ein regulärer Ausdruck ist und
            die Sprache $L$ beschreibt, dann ist $(R^*)$ ein regulärer
            Ausdruck und beschreibt die Sprache
            <span class="nowrap">$L^*$.</span>
          </p>
        </li>
      </ul>
      <p>
        Weil in der Praxis neben
        <span class="nowrap">$L^*$,</span>
        also beliebig langen,
        möglicherweise leeren Folgen von $L$ -Wörtern wir oft
        <i>nichtleere</i>
        Folgen wollen, führen wir die Abkürzung $R^+$ für
        $R (R^*)$ ein und bezeichnen die beschriebene Sprache
        $L \circ L^*$ kurzerhand als
        <span class="nowrap">$L^+$.</span>
      </p>
    </div>
    <p class="main-column">
      In konkreten fällen lassen gerne die Klammerung weg, wenn keine
      Verwechslungsgefahr besteht. Auch gehen wir davon aus, dass die
      Operatoren die Präzedenz $^*$ vor $\circ$ vor $|$ haben (wie
      <i>hoch</i>
      vor
      <i>Punkt</i>
      vor
      <i>Strich</i>
      in der Arithmetik), sodass
      beispielsweise der Ausdruck $a^*b|c^*$ die Bedeutung von
      $(((a^*)b)(c^*))$ hat, genauso wie wir in der Arithmetik
      $a^2 b + c^3$ statt $(((a^2)b) + c^3)$ schreiben. Die von den
      atomaren Ausdrücken beschriebenen Sprachen sind alle regulär, da
      sie alle
      <i>endliche Sprachen</i>
      sind. Dank unserer Vorarbeit aus
      <a
        href="./5-1.html#_17_hgi_"
        class=""
      >Kapitel
      </a>
      wissen wir, dass Alterantive, Konkatenation und
      Kleenesche Hülle wiederum reguläre Sprachen erzeugen. Wir erhalten
      das folgende Ergebnis:
    </p>
    <div
      id="_24_hgi_"
      class="well statement out"
    >
      <p>
        <b>Lemma</b>
        <b>5.5.2</b>
        Die von einem regulären Ausdruck $R$ beschriebene Sprache $L(R)$
        ist regulär.
      </p>
    </div>
    <p class="main-column">
      Es ist Zeit für ein paar Beispiele.
    </p>
    <div class="well statement out">
      <p>
        <b>Beispiel</b>
        <b>5.5.3</b>
        Nehmen wir die Sprache der Wörter der Form
        <code>bla:bla:blu.xyz-12-ab.b:x</code>
        aus dem letzten Kapitel. Sie erinnern
        sich: eine endliche Folge von
        <span class="nowrap"><i>Labels</i>,</span>
        wo ein Label eine
        nichtleere Folge von Blöcken ist, die entweder
        <code>:</code>
        oder durch
        <code>-</code>
        separiert sind, wobei innerhalb eines Labels immer nur ein
        Separatortyp vorkommen darf, und wobei ein Block eine nichtleere
        Folge von alphanumerischen Zeichen ist (wir haben uns dann auf
        den Buchstaben $a$ beschränkt). Sehen Sie, dass bereits unsere
        natürlichsprachliche Beschreibung von $L$ von dem
        Baukastenprinzip gebraucht macht. Wenn wir nun einen regulären
        Ausdruck für $L$ erstellen wollen, so können wir bequem Stück
        für Stück vorgehen. Ein Block ist eine nichtleere Folge von
        <span class="nowrap">$a$'s.</span>
        Der entsprechende reguläre Ausdruck $B$ für Blöcke ist
        also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        B : = a^+
        \end{align*}
        $$
      </div>
      <p>
        Für ein Label müssen wir uns entscheiden, ob wir die Blöcke mit
        <code>:</code>
        oder
        <code>-</code>
        separieren; wir erhalten den regulären Ausdruck $T$
        für Labels ist also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        T := B ({:}B)^* | B (\text{-}B)^*
        \end{align*}
        $$
      </div>
      <p>
        Sehen Sie, dass wir in $T$ das erste $B$ "ausfaktorisieren"
        können und statt dem obigen folgenden Ausdruck schreiben können:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        T' := B ( ({:}B)^* | (\text{-}B)^* )
        \end{align*}
        $$
      </div>
      <p>
        Beide Varianten sind äquivalent, d.h., sie beschreiben die
        gleiche Sprache; die erste Variante, also
        <span class="nowrap">$T$,</span>
        ähnelt mehr dem,
        was wir in unserer Grammatik bzw. dem nichtdeterministischen
        Automaten für $L$ getan haben, während $T'$ eher die
        Arbeitsweise des determinisitschen Automaten reflektiert (wir
        lesen erst einmal einen Block und erst, wenn wir zum ersten mal
        auf
        <code>:</code>
        oder
        <code>-</code>
        stoßen, entscheiden wir uns für den "Typ" des
        Labels). Schlussendlich ist ein Wort in der Sprache eine mit
        <code>.</code>
        separierte Folge von Labels, also:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        R := T ({.}T)^*
        \end{align*}
        $$
      </div>
      <p>
        Somit können wir nun den regulären Ausdruck für $L$ in seiner
        ganzen Pracht zeigen:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        R := (a^+ ({:}a^+)^* | a^+ (\text{-}a^+)^*) ({.}(a^+ ({:}a^+)^* | a^+ (\text{-}a^+)^*))^*
        \end{align*}
        $$
      </div>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 5.5.1</b>
        Laden Sie sich
        <a href="./code/regular-expressions/TestRegex.java">TextRegex.java</a>
        herunter, kompilieren und starten Sie es.
      </p>
<pre language="arbitrary-prompt-response">
<p>
user@home:~$ java TestRegex
Please enter a regular expression: &lt;- (a+)(:a+)*
Enter words to be matched, one per line
&lt;- aaaaa:aa:aaaa:a
true
&lt;- aaa:aa:
false
</p>
</pre>
      <p>
        Schreiben Sie nun einen regulären Ausdruck $R$ für die obige
        Sprache und testen Sie ihn mit dem Java-Programm.
      </p>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 5.5.2</b>
        In der Praxis gibt es bei reguläre Ausdrücken viele Abkürzung,
        so beschreibt
        <code>[a-z]</code>
        beispielsweise die Menge aller
        Kleinbuchstaben,
        <code>[aoeiuy]</code>
        beschreibt die Menge \{a,o,e,i,u,y\}
        etc. Der reguläre Ausdruck
        <code>[a-z]*[aeiuoy][a-z]*</code>
        beschreibt also
        die Menge aller Wörter, die mindesten einen Vokal enthalten.
        Lesen Sie hierfür unter Anderem
      </p>
      <div class="display">
        <p>
          <a href="https://www.w3schools.com/java/java_regex.asp">W3School</a>
        </p>
      </div>
      <p>
        und
      </p>
      <div class="display">
        <p>
          <a href="https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html">Patternl.html auf der
            Java-API</a>,
        </p>
      </div>
      <p>
        lassen sich aber bitte nicht von der Menge an Details
        erschlagen. Schreiben Sie nun in der Java-Regex-Syntax einen
        regulären Ausdruck für unsere obige Sprache
        <span class="nowrap">$L$,</span>
        wo Sie aber
        neben $a$ alle alphanumerischen Zeichen zulassen.
      </p>
    </div>
    <h2 class="main-column topic-announcement">
      Einen regulären Ausdruck für jede reguläre Sprache
    </h2>
    <p class="main-column">
      Wir beweisen nun das Gegenstück zu
      <a
        href="./5-5.html#_24_hgi_"
        class=""
      >Lemma 5.5.2</a>:
    </p>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>5.5.4</b>
        Sei $L$ eine reguläre Sprache. Dann gibt es einen regulären
        Ausdruck
        <span class="nowrap">$R$,</span>
        der $L$ beschreibt, also
        <span class="nowrap">$L(R) = R$.</span>
      </p>
    </div>
    <p class="main-column">
      Wir paraphrasieren hier den Beweis aus Michael Sipsers
      <span class="nowrap"><i>Introduction to the Theory of Computation</i>.</span>
    </p>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Zunächst skizzieren wir die Beweisidee. Da $L$ regulär ist, gibt
        es einen nichtdeterministischen endlichen Automaten
        <span class="nowrap">$M$,</span>
        die $L$
        akzeptiert. Wir werden nun $M$ Schritt für Schritt in einen
        regulären Ausdruck verwandeln. Kern der Idee ist, dass wir neben
        den üblichen Übergängen
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        q_1 \step{x} q_2
        \end{align*}
        $$
      </div>
      <p>
        komplexere Übergänge wie zum Beispiel $q_1 \step{xy} q_2$
        zulassen. Die Bedeutung wäre hier beispielsweise, dass der
        Automat von $q_1$ nach $q_2$ übergehen kann, wenn er die
        Eingabesymbole $xy$ liest. Wir lassen auch komplexere Übergänge
        wie
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        q_1 \step{x|yz^*} q_2
        \end{align*}
        $$
      </div>
      <p>
        zu, also "von $q_1$ kann der Automat nach $q_2$ gehen, wenn er
        ein $x$ liest oder ein
        <span class="nowrap">$y$,</span>
        gefolgt von beliebig vielen $z$ ";
        ganz allgemein lassen wir Übergänge der Form
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        q_1 \step{R} q_2 \ ,
        \end{align*}
        $$
      </div>
      <p>
        wobei $R$ ein regulärer Ausdruck ist. Insbesondere lassen wir
        Übergänge der Form $q_1 \step{\epsilon} q_2$ zu. Dies bedeutet,
        dass der Automat von $q_1$ nach $q_2$ "springen" kann, ohne ein
        Eingabesymbol zu lesen. Des weiteren verlangen wir, dass es genau
        einen akzeptierenden Endzustand $q_{\rm end}$ mit
        <span class="nowrap">$\qstart \ne q_{\rm end}$,</span>
        und dass es keine Kanten gibt, die in
        $\qstart$ hineingehen, und keine, die aus $q_{\rm end}$
        hinausgehen. All dies lässt sich leicht verwirklichen, wenn wir
        reguläre Ausdrücke als Kantenbeschriftung zulassen. Wir nennen so
        einen Automaten einen
        <span class="nowrap"><i>verallgemeinerten nichtdeterministischen
            endlichen Automaten (VNEA)</i>.</span>
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:14em"
            src="./img/finite-state-automata/to-regex/nea-to-vnea.svg"
          >
        </figure>
      </div>
      <p>
        Definieren wir nun formal, was VNEAs sind und welche Sprache sie
        akzeptieren:
      </p>
      <div class="well statement">
        <p>
          <b>Definition</b>
          <b>5.5.5</b>
          <b>(Verallgemeinerter nichtdeterministischer endlicher Automat,
            VNEA).</b>
          Ein VNEA besteht aus einem Alphabet
          <span class="nowrap">$\Sigma$,</span>
          einer
          Zustandsmenge
          <span class="nowrap">$Q$,</span>
          einen Startzustand
          <span class="nowrap">$\qstart \in Q$,</span>
          einem
          akzeptierenden Zustand
          <span class="nowrap">$q_{\rm end} \in Q \setminus \{\qstart\}$,</span>
          einer Menge von
          gerichteten Kanten
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          E \subseteq (Q \setminus \{\qstart\}) \times (Q \setminus \{q_{\rm end}\}) \ .
          \end{align*}
          $$
        </div>
        <p>
          Jede Kante $(q_i, q_j) \in E$ ist mit einem regulären Ausdruck
          $\delta(q_i, q_j)$ beschriftet. Wenn $R = \delta(q_i, q_j)$
          gilt, dann schreiben wir
          <span class="nowrap">$q_i \step{R} q_j$.</span>
          Wenn
          $\beta \in L(R)$ gilt, $\beta$ also ein Wort in der von $R$
          beschriebenen Sprache ist, dann schreiben wir auch
          <span class="nowrap">$q_i \step{\beta \in R} q_j$.</span>
          Für $q, q' \in Q$ und
          $\alpha \in \Sigma^*$ schreiben wir
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          q \Step{\alpha} q'
          \end{align*}
          $$
        </div>
        <p>
          wenn man $\alpha$ zerlegen kann als
          $\alpha = \beta_1 \beta_2 \dots \beta_k$ gibt (wobei
          $\beta_i = \epsilon$ zulässig ist) und es eine Zustandsfolge
          $q = q_0, q_1, \dots, q_k = q'$ gibt, wobei
          $(q_{i-1}, q_i)\in E$ ist und mit einem regulären Ausdruck
          $R_i$ beschriftet ist und jedes $\beta_i$ in der von $R_i$
          beschriebenen Sprache ist. Wenn also
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          q_0 \step{\beta_1 \in R_1} q_1 \step{\beta_2 \in R_2} q_2 \dots q_{k-1} \step{\beta_k
          \in R_k} p_k
          \end{align*}
          $$
        </div>
        <p>
          gilt.
        </p>
      </div>
      <p>
        Einen gegebenen NEA können wir leicht in einen VNEA
        transformieren, indem wir, soweit nötig, (1) einen neuen
        Startzustand kreieren (damit dieser keine eingehenden Kanten
        hat), (2) einen neuen Endzustand kreieren, (3) "parallele"
        Übergänge wie $(q_i, x, q_j), (q_i, y, q_j)$ zu einer Kante
        zusammenfassen, der dann mit dem regulären Ausdruck $x | y$
        beschriftet ist. Wir haben den ganzen Aufwand betrieben, weil wir
        für einen VNEA sehr leicht Zustände eliminieren können. Wenn wir
        zum Beispiel
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        q_0 \step{R_1} q_1 \step{R_2} q_2
        \end{align*}
        $$
      </div>
      <p>
        haben, dann können wir ja ein Wort in $R_1 R_2$ lesen und direkt
        von $q_0$ nach $q_2$ übergehen; wir brauchen also $q_1$ gar
        nicht. Wir müssen nur aufpassen, das neue $R_1 R_2$ mit einem
        eventuell bereits bestehenden Übergang von $q_0$ nach $q_2$ zu
        kombinieren. Im allgemeinen:
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:10em"
            src="./img/finite-state-automata/to-regex/eliminate-B.svg"
          >
        </figure>
      </div>
      <p>
        Falls die mit $R_2$ beschriftete Selbstschleife an Zustand $B$
        nicht existieren sollte, dann schreiben wir einfach $R_1R_3$
        anstatt
        <span class="nowrap">$R_1 R_2^* R_3$;</span>
        falls der Übergang $A \step{R_4} B$
        nicht existieren sollte , lassen wir das $R_4 |$ im rechten Bild
        einfach weg. (Sipser führt hier den eleganten Formalismus ein, zu
        verlangen, dass
        <i>jedes</i>
        Paar durch eine Kante verbunden ist und
        würde fehlende Kanten einfach mit dem regulären Ausdruck
        $\emptyset$ beschriften.) Wir suchen uns also einen Zustand
        <span class="nowrap">$B \in Q \setminus \{\qstart, \qend\}$,</span>
        den wir eliminieren
        wollen, und führen die oben beschriebene
        <span class="nowrap">$B$-Umfahrung</span>
        parallel
        für alle Paare $A,C$ aus, für die es $A \step{} B \step{} C$
        gibt. Wir erhalten einen VNEA mit einem Zustand weniger, der zu
        dem vorherigen VNEA äquivalent ist, also die gleiche Sprache
        akzeptiert. Wiederholen wir diesen Schritt, so erhalten wir am
        Ende einen Automat mit nur zwei Zuständen, nämlich
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:2.5em"
            src="./img/finite-state-automata/to-regex/nvea-final.svg"
          >
        </figure>
      </div>
      <p>
        Dieser VNEA akzeptiert immer noch die gleiche Sprache $L$ wie
        der ursprüngliche NEA, mit dem wir begonnen haben. Welche Sprache
        ist das? Es ist die Sprache aller $\alpha \in \Sigma$ mit
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \qstart \Step{\alpha} \qend
        \end{align*}
        $$
      </div>
      <p>
        Da der Pfad von $\qstart$ nach $\qend$ nur eine Kante hat, muss
        $\alpha$ in der von $R$ beschriebenen Sprache liegen. $R$ ist
        der gesuchte reguläre Ausdruck: er beschreibt die Sprache
        <span class="nowrap">$L$.</span><span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p class="main-column">
      Hier sehen Sie den ganzen Ablauf an unserer
      <span class="nowrap"><code>aaaa:a:aaa.aa-aa</code>-Sprache:</span>
    </p>
    <div class="pseudowell">
      <figure style="overflow-x:auto;margin:0 center;">
        <img
          style="height:20em"
          src="./img/finite-state-automata/to-regex/nfsm-to-regex-carpet.svg"
        >
      </figure>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 5.5.3</b>
        Wandeln Sie nach dem eben beschriebenen Schema den Automaten
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:10em"
            src="./img/finite-state-automata/nfsm-example-02.svg"
          >
        </figure>
      </div>
      <p>
        in einen regulären Ausdruck um.
      </p>
    </div>
    <div id="end-of-page-elt">
    </div>
    <div id="bottom-menu">
      <div class="bottom-menu-left">
        <a href="./5-4.html">&lt;&lt; Kapitel 5.4<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >Von einer regulären Grammatik zu einem endlichen Automaten an einem Beispiel</span></a>
      </div>
      <div class="bottom-menu-right">
        <a href="./5-6.html">Kapitel 5.6 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >Die Grenzen regulärer Sprachen</span></a>
      </div>
    </div>
  </div>
</body>
</html>
