<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Chapter 4 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 4</title>
</head>
<body>
  <div class="body-wrapper">
    <div id="menu">
      <div class="menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./3-6.html"
        >&lt;&lt; Kapitel 3.6<span
            style="visibility:hidden"
            id="prev-page-tooltip"
          >
            <p>
              Der Trichotomiesatz
            </p>
          </span></a>
      </div>
      <div class="menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./4-1.html"
        >Kapitel 4.1 &gt;&gt;<span
            style="visibility:hidden"
            id="next-page-tooltip"
          >
            <p>
              Primitive Rekursion: Motivation und Definitionen
            </p>
          </span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        4.&ensp;Berechenbarkeit und natürliche Zahlen
      </p>
    </div>
    <p class="main-column">
      Mit den Booleschen Schaltkreisen haben wir ein Modell
      kennengelernt, dass die Berechnung von Booleschen Funkionen
      $f: \{0,1\}^n \rightarrow \{0,1\}$ beschreibt. Wir haben mehrere
      Beweisen gesehen, dass es für jede Boolesche Funktion einen
      Schaltkreis gibt. Unsere Zielsetzung war durchweg
      <span class="nowrap"><i>komplexitätstheoretisch</i>:</span>
      wir wollten möglichst kleine
      Schaltkreise von möglichst geringer Tiefe entwerfen. Würden wir
      tiefer in die Schaltkreiskomplexität einsteigen, so würden wir uns
      fast ausschließlich mit
      <i>negativen</i>
      Zielen beschäftigen: zu zeigen,
      dass es zu bestimmten Funktionen eben nicht Schaltkreise mit $S$
      Gates und in Tiefe $d$ gibt; wir würden uns zum Großteil mit
      <i>unteren Schranken</i>
      beschäftigen. Boolesche Funktionen sind immer
      <i>endliche</i>
      Objekte. In der Berechenbarkeitstheorie geht es im
      Grunde um die Frage: welche
      <i>unendlichen</i>
      Funktionen können wir
      überhaupt berechnen? Und was gilt denn überhaupt als zulässiges
      Modell für Berechenbarkeit? Wenn wir nun also über Funktionen
      $f: X \rightarrow Y$ auf unendlichen Mengen sprechen und uns
      fragen, welche durch eine
      <i>endliche Rechenvorschrift</i>
      beschrieben
      werden können, dann müssen wir erst einmal entscheiden, mit welcher
      unendlichen Menge wir uns beschäftigen. Eine Bedingung sollte zum
      Beispiel sein, dass wir Input und Output vollständig hinschreiben
      können. (Denn wenn der Input bereits unendlich groß wäre, wie
      sollten wir überhaupt über Berechenbarkeit sprechen?) Für uns als
      Informatiker wäre doch folgende Menge am naheliegendsten:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \{0,1\}^* \ ,
      \end{align*}
      $$
    </div>
    <p class="main-column">
      also die Menge aller beliebig langen aber endlichen Bit-Strings.
      Wir können alle möglichen Dinge (Wörter, Programme, Dateien,
      natürliche Zahlen, rationale Zahlen) als solche Bit-Strings
      codieren. Die ersten Wissenschaftler, die sich mit Berechenbarkeit
      beschäftigten, kamen allerdings aus der Mathematik und Logik, und
      ganz allgemeinen entstand die Berechenbarkeitstheorie
      <i>bevor</i>
      die
      ersten Rechner gebaut wurden. Daher beschäftigten sich die ersten
      Forscher auch mit einer anderen, uns sehr vertrauten Menge:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \mathbb{N} \ ,
      \end{align*}
      $$
    </div>
    <p class="main-column">
      den natürlichen Zahlen. Im letzten Kapitel haben wir ja unter
      anderen bewiesen, dass diese gleichmächtig sind:
      $\{0,1\}^* \cong \N$ und haben auch eine Bijektion kennengelernt,
      beispielsweise
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      f : \{0,1\}^*&amp;\rightarrow \N \\
      (x_1, \dots, x_n)&amp;\mapsto (1 x_1\dots x_n)_2 - 1\ ,
      \end{align*}
      $$
    </div>
    <p class="main-column">
      wir stellen also dem Bitstring $x_1,\dots,x_n$ eine 1 voran und
      interpretieren das Ergebnis als natürliche Zahl; dann ziehen wir 1
      ab. Es ist also für die Entwicklung eines Berechenbarkeitsbegriffs
      mehr oder weniger egal, ob wir mit $\N$ oder $\{0,1\}^*$ arbeiten
      - sofern die obige Bijektion $f$ selbst "berechenbar" ist. Wir
      werden in diesem Kapitel mehrere Berechenbarkeitsmodelle für
      Funktionen $f: \N \rightarrow \N$ kennenlernen. Die beste
      Einstellung Ihrerseits ist, diese Modelle als primitive, sehr
      reduzierte Programmiersprachen zu betrachten.
    </p>
  </div>
  <div id="end-of-page-elt">
  </div>
  <div id="bottom-menu">
    <div class="bottom-menu-left">
      <a href="./3-6.html">&lt;&lt; Kapitel 3.6<span
          style="visibility:hidden"
          id="bottom-prev-page-tooltip"
        >
          <p>
            Der Trichotomiesatz
          </p>
        </span></a>
    </div>
    <div class="bottom-menu-right">
      <a href="./4-1.html">Kapitel 4.1 &gt;&gt;<span
          style="visibility:hidden"
          id="bottom-next-page-tooltip"
        >
          <p>
            Primitive Rekursion: Motivation und Definitionen
          </p>
        </span></a>
    </div>
  </div>
</body>
</html>
