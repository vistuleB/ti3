<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Chapter 4 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 4</title>
</head>
<body class="page-chapter chapter-4">
  <div class="menu">
    <div class="menu-left">
      <a href="./index.html">Inhaltsverzeichnis</a><a
        href="./3-6.html"
        id="prev-page"
      >&lt;&lt; Kapitel 3.6</a>
    </div>
    <div class="menu-right">
      <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
        href="./4-1.html"
        id="next-page"
      >Kapitel 4.1  &gt;&gt;</a>
    </div>
  </div>
  <div class="main-column page-title">
    <p>
      4. 
      Berechenbarkeit und natürliche Zahlen
    </p>
  </div>
  <p class="main-column">
    Mit den Booleschen Schaltkreisen haben wir ein Modell
    kennengelernt, dass die Berechnung von Booleschen Funkionen
    $f: \{0,1\}^n \rightarrow \{0,1\}$ beschreibt. Wir haben mehrere
    Beweisen gesehen, dass es für jede Boolesche Funktion einen
    Schaltkreis gibt. Unsere Zielsetzung war durchweg
    <span class="nowrap"><i>komplexitätstheoretisch</i>:</span>
    wir wollten möglichst kleine
    Schaltkreise von möglichst geringer Tiefe entwerfen. Würden wir
    tiefer in die Schaltkreiskomplexität einsteigen, so würden wir uns
    fast ausschließlich mit
    <i>negativen</i>
    Zielen beschäftigen: zu zeigen,
    dass es zu bestimmten Funktionen eben nicht Schaltkreise mit $S$
    Gates und in Tiefe $d$ gibt; wir würden uns zum Großteil mit
    <i>unteren Schranken</i>
    beschäftigen. Boolesche Funktionen sind immer
    <i>endliche</i>
    Objekte. In der Berechenbarkeitstheorie geht es im
    Grunde um die Frage: welche
    <i>unendlichen</i>
    Funktionen können wir
    überhaupt berechnen? Und was gilt denn überhaupt als zulässiges
    Modell für Berechenbarkeit? Wenn wir nun also über Funktionen
    $f: X \rightarrow Y$ auf unendlichen Mengen sprechen und uns
    fragen, welche durch eine
    <i>endliche Rechenvorschrift</i>
    beschrieben
    werden können, dann müssen wir erst einmal entscheiden, mit welcher
    unendlichen Menge wir uns beschäftigen. Eine Bedingung sollte zum
    Beispiel sein, dass wir Input und Output vollständig hinschreiben
    können. (Denn wenn der Input bereits unendlich groß wäre, wie
    sollten wir überhaupt über Berechenbarkeit sprechen?) Für uns als
    Informatiker wäre doch folgende Menge am naheliegendsten:
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \{0,1\}^* \ ,
    \end{align*}
    $$
  </div>
  <p class="main-column">
    also die Menge aller beliebig langen aber endlichen Bit-Strings.
    Wir können alle möglichen Dinge (Wörter, Programme, Dateien,
    natürliche Zahlen, rationale Zahlen) als solche Bit-Strings
    codieren. Die ersten Wissenschaftler, die sich mit Berechenbarkeit
    beschäftigten, kamen allerdings aus der Mathematik und Logik, und
    ganz allgemeinen entstand die Berechenbarkeitstheorie
    <i>bevor</i>
    die
    ersten Rechner gebaut wurden. Daher beschäftigten sich die ersten
    Forscher auch mit einer anderen, uns sehr vertrauten Menge:
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    \mathbb{N} \ ,
    \end{align*}
    $$
  </div>
  <p class="main-column">
    den natürlichen Zahlen. Im letzten Kapitel haben wir ja unter
    anderen bewiesen, dass diese gleichmächtig sind:
    $\{0,1\}^* \cong \N$ und haben auch eine Bijektion kennengelernt,
    beispielsweise
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    f : \{0,1\}^*&amp;\rightarrow \N \\
    (x_1, \dots, x_n)&amp;\mapsto (1 x_1\dots x_n)_2 - 1\ ,
    \end{align*}
    $$
  </div>
  <p class="main-column">
    wir stellen also dem Bitstring $x_1,\dots,x_n$ eine 1 voran und
    interpretieren das Ergebnis als natürliche Zahl; dann ziehen wir 1
    ab. Es ist also für die Entwicklung eines Berechenbarkeitsbegriffs
    mehr oder weniger egal, ob wir mit $\N$ oder $\{0,1\}^*$ arbeiten
    - sofern die obige Bijektion $f$ selbst "berechenbar" ist. Wir
    werden in diesem Kapitel mehrere Berechenbarkeitsmodelle für
    Funktionen $f: \N \rightarrow \N$ kennenlernen. Die beste
    Einstellung Ihrerseits ist, diese Modelle als primitive, sehr
    reduzierte Programmiersprachen zu betrachten.
  </p>
</body>
</html>
