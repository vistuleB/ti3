<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=1"
    />
    <meta
      name="description"
      content="Section 2.5 of TI3 - Theoretische Informatik 2"
    />
    <link rel="stylesheet" type="text/css" href="ti3.css" />
    <script type="text/javascript" src="./mathjax_setup.js"></script>
    <script
      type="text/javascript"
      id="MathJax-script"
      async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"
    ></script>
    <script type="text/javascript" src="./app.js"></script>
    <title>TI3 - Chapter 2, Section 5</title>
  </head>
  <body class="page-sub chapter-2 sub-5">
    <div class="subchapter">
      <div class="menu">
        <div class="menu-left">
          <a href="./index.html">Inhaltsverzeichnis</a
          ><a href="./2-4.html">&lt;&lt; Kapitel 2.4</a>
        </div>
        <div class="menu-right">
          <a
            href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en"
            >zür Kursübersicht</a
          >
        </div>
      </div>
      <div class="main-column page-title">2.5 Majority</div>
      <p class="main-column">
        Unser Ziel in diesem Teilkapitel ist es, Schaltkreise für die
        Majority-Funktion zu bauen:
      </p>
      <figure class="main-column">
        <img
          style="height: 10em"
          src="./img/circuits/majority.svg"
          loading="lazy"
          onClick="onImgClick(event)"
          class="constrained transition-all"
        />
      </figure>
      <p class="main-column">
        Diese nimmt $n$ Bits als Input und gibt 1 aus, wenn mehr als $n/2$ davon
        1 sind. Für $n=3$ heißt dass, das mindestens zwei Input-Bits 1 sein
        müssen. Als Formel kann man das so schreiben: $$ \maj_3(x,y,z) = (x
        \wedge y) \vee (x \wedge z) \vee (y \wedge z) $$ und als Schaltkreis so:
      </p>
      <figure class="main-column">
        <img
          style="height: 8em"
          src="./img/circuits/maj3.svg"
          loading="lazy"
          onClick="onImgClick(event)"
          class="constrained transition-all"
        />
      </figure>
      <p class="main-column">
        Wie können wir das sinnvoll verallgemeinern für größere
        <span class="nowrap">$n$?</span>
        Was geschieht, wenn wir einfach die Wahrheitstabellen-Methode anwenden?
        Falls $n$ ungerade ist, dann sieht man leicht, dass die Wahrheitstabelle
        in genau $2^{n-1}$ vielen Zeilen eine 1 stehen hat und in ebenso vielen
        eine 0.
      </p>
      <div class="well exercise out">
        <p>
          <b>Übungsaufgabe 2.5.1</b>
          Sei $n$ eine ungerade Zahl. Zeigen Sie, dass $\maj_n$ für genau die
          Hälfte aller $2^n$ möglichen Eingaben eine 1 ausgibt (und für die
          andere Hälfte eine 0).
        </p>
      </div>
      <p class="main-column">
        Wir erhielten also eine DNF mit $2^{n-1}$ vielen AND-Gates. Das ist sehr
        groß, gemessen daran, dass Zählen und mit $n/2$ vergleichen ja nicht
        besonders schwierig klingt. Hier ist eine kleine Verbesserung,
        demonstriert am Beispiel
        <span class="nowrap">$n=7$.</span>
        Wenn wir für $n=7$ mit Hilfe einer Wahrheitstabelle eine DNF
        konstruieren, erhalten wir ja unter Anderem den Term $$ T := x_1
        \bar{x}_2 x_3 x_4 \bar{x}_5 x_6 x_7 \ , $$ da der Input $\maj_7(1011011)
        = 1$ ist. Schauen wir uns nun den Term $T'$ an, den wir erhalten, wenn
        wir alle negativen Literale aus $T$ löschen: $$ T' := x_1 x_3 x_4 x_6
        x_7 \ . $$ Wenn dieser Term 1 wird, dann sind $x_1 = x_3 = x_4 = x_6 =
        x_7$ sein, also insgesamt fünf Input-Bits 1, und $\maj_7$ gibt 1 aus.
        Hier ist also eine Vereinfachung: wir folgen der
        Wahrheitstabellen-Methode, lassen aber alle negativen Literale weg. Das
        Ergebnis ist etwas kleiner und immer noch korrekt. Schauen Sie sich nun
        den Term $$ x_1 \bar{x}_2 \bar{x}_3 x_4 \bar{x}_5 x_6 x_7 $$ an. Auch
        dieser kommt in der Wahrheitstabelle vor, da $\maj_7(1001011)=1$ gilt.
        In unserer neuen Konstruktion wird dieser zu $x_1 x_4 x_6 x_7$
        vereinfacht. Nun schauen Sie: wenn $T'$ den Wert 1 ausgibt, dann gibt
        $x_1 x_4 x_6 x_7$ auf jeden Fall 1 aus, und $\maj_7$ wird 1; $T'$ ist
        also redundant. Irgendwie ist das ja auch klar: zu verlangen, dass die
        fünf Variablen $x_1, x_3, x_4 x_6, x_7$ alle mit 1 abstimmen, ist zwar
        hinreichend, aber eben schon mehr als nötig. Es reicht also, sich auf
        alle Terme mit genau 4 Variablen zu beschränken. Im allgemeinen sei
        <span class="nowrap">$k = \ceil{\frac{k+1}{2}}$.</span>
        Dann gilt $$\begin{align} \maj_n (x_1,\dots,x_n) = \bigvee_{\substack{I
        \subseteq [n] \\ |I| = k}} \bigwedge_{i \in I} x_i .
        \label{johns-equation} \end{align}$$
      </p>
      <p class="main-column">
        Diese Konstruktion hat nun ${n \choose k}$ Terme, von denen jeder aus
        $k$ Variablen besteht. Ist das nun gut oder schlecht?
      </p>
      <div class="well lemma out">
        <p>
          <b>Lemma 2.5.1</b>
          Es gilt $$ {n \choose {\ceil{n/2}}} \geq \frac{2^n}{n+1} \ . $$
        </p>
      </div>
      <div class="well highlight out">
        <p>
          <b>Beweis.</b>
          Sei
          <span class="nowrap">$k \in \{1,\dots,n\}$.</span>
          Vergleichen wir ${n \choose k}$ mit
          <span class="nowrap">${n \choose k-1}$:</span>
          $$\begin{align*} \frac{{n \choose k}}{{n \choose k-1}} &amp; = \frac{
          \frac{n!}{k! (n-k)!}}{\frac{n!}{ (k-1)! (n-k+1)!}} = \frac{n-k+1}{k}
          \end{align*}$$ und somit
        </p>
        <p>
          $$\begin{align*} {n \choose k} &amp; \geq {n \choose k-1} \quad
          \Longleftrightarrow \\ n-k+1 &amp; \geq k \quad \Longleftrightarrow \\
          2k &amp; \leq n+1 \quad \Longleftrightarrow \\ k &amp; \leq
          \frac{n+1}{2} \quad \Longleftrightarrow \\ k &amp; \leq \floor{
          \frac{n+1}{2}} = \ceil{\frac{n}{2}} \ . \end{align*}$$
        </p>
        <p>
          Aus der letzten Zeile folgt nun, dass ${n \choose k}$ durch $k :=
          \ceil{\frac{n}{2}}$ maximiert wird, also ${n \choose k} \leq {n
          \choose \ceil{\frac{n}{2}}}$ gilt.
        </p>
        <p>
          Als nächstes müssen wir uns die Definition von ${n \choose k}$ ins
          Gedächtnis rufen. Nein, $\frac{n!}{k!(n-k)!}$ ist nicht die
          Definition, sondern eine Formel dafür. Die Definition ist: ${n \choose
          k}$ ist die Menge der Teilmengen von
          <span class="nowrap">$\{1,\dots,n\}$,</span>
          die Größe $k$ haben. Wieviele Teilmenge (jeglicher Größe) gibt es
          insgesamt? Genau $2^n$ viele: Sie müssen für jede Zahl $i \in
          \{1,\dots,n\}$ die Entscheidung treffen, ob $i$ in die Menge soll oder
          nicht, haben also insgesamt $2^n$ Wahlmöglichkeiten. Daher gilt: $$
          \sum_{k=0}^n {n \choose k} = 2^n \ . $$ Intuitiv gesprochen heißt das:
          diese Summe hat $n+1$ Terme
          <span class="nowrap">($k$</span>
          wandert von 0 bis
          <span class="nowrap">$n$,</span>
          also muss der größte Term mindestens ein
          <span class="nowrap">$(n+1)$-tel</span>
          des Gesamtbetrages sein. Formal: $$ 2^n = \sum_{k=0}^n {n \choose k}
          \leq \sum_{k=0}^n {n \choose \ceil{\frac{n}{2}}} = (n+1) \cdot {n
          \choose \ceil{\frac{n}{2}}} $$ und somit $$ {n \choose
          \ceil{\frac{n}{2}}} \geq \frac{2^n} {n+1} \ , $$ wie behauptet.<span
            class="qed"
            >$\square$</span
          >
        </p>
      </div>
      <p class="main-column">
        Unsere neue, bessere Konstruktion benötigt also immer noch mindestens
        $\frac{2^n}{n+1}$ Terme, was bereits für moderate Werte wie $n=30$ nicht
        vertretbar ist.
      </p>
      <h3 class="main-column">
        Majority Top-Down mit
        <code>if-then-else</code>-Gates
      </h3>
      <p class="main-column">
        Wenden wir nun statt Wahrheitstabelle die Top-Down-Methode an,
        modifiziert für monotone Funktionen wie in den<a
          href="../sub-pages/01-monotone.html"
          >Lösungen zu den Übungsaufgaben</a
        >
        dargestellt. Insbesondere definieren wir Verallgemeinerungen von
        $\maj_n$ wie folgt: $$\begin{align*} \theta^n_k (x_1,\dots,x_n) &amp; :=
        \begin{cases} 1 &amp; \textnormal{ falls $x_1 + \dots + x_n \geq k$} \\
        0 &amp; \textnormal{ sonst.} \end{cases} \end{align*}$$ Die Funktion
        $\maj_n$ ist also ein Speziallfall $\theta^n_k$ für
        <span class="nowrap">$k = \ceil{\frac{n+1}{2}}$.</span>
        Wir können $\theta^n_k$ rekursiv zerlegen wie folgt: $$ \theta^n_k
        (x_1,\dots,x_n) = (x_n \wedge \theta^{n-1}_{k-1} (x_1,\dots,x_{n-1}))
        \vee \theta^{n-1}_{k} (x_1,\dots,x_{n-1}) \ $$ und somit $\theta^n_k$
        aus $\theta^{n-1}_{k-1}$ und $\theta^{n-1}_k$ berechnen. Rekursiv
        fortgefühtr sieht das dann so aus:
      </p>
      <figure class="main-column">
        <img
          style="height: 15em"
          src="./img/circuits/majority-theta-recursive.svg"
          loading="lazy"
          onClick="onImgClick(event)"
          class="constrained transition-all"
        />
      </figure>
      <p class="main-column">
        Die Konstruktion endet mit
        <span class="nowrap">$\theta^m_0$,</span>
        was immer $1$ ausgibt, und mit
        <span class="nowrap">$\theta^m_{m}$,</span>
        was $x_1 \wedge \dots \wedge x_m$ ist. Die Konstruktion ist leider auch
        nicht effizient; wenn man mit $C^n_k$ die Anzahl der $\theta^m_m$ und
        $\theta^m_0$ in diesem Baum zählt, dann sieht man, dass
      </p>
      <p class="main-column">
        $$\begin{align*} C^n_k &amp; = C^{n-1}_{k-1} + C^{n-1}_k \\ C^n_n &amp;
        = 1 \\ C^n_0 &amp; = 1 \end{align*}$$
      </p>
      <p class="main-column">
        gilt; sie erfüllt also die gleiche Rekursionsgleichung wie der
        Binomialkoeffizient
        <span class="nowrap">${n \choose k}$,</span>
        also gilt
        <span class="nowrap">$C^n_k = {n \choose k}$.</span>
        Die Konstruktion ist asymptotisch auch nicht besser als die, aus der
        Wahrheitstabelle direkt eine monotone DNF zu basteln.
      </p>
      <p class="main-column">
        Allerdings können wir die obige Konstruktion offensichtlich effizienter
        machen, indem wir mehrfach verwendete Zwischenergebnisse wie
        $\theta^{n-1}_{k-1}$ nicht doppelt berechnen, also statt dem obigen Baum
        einen Schaltkreis nach folgendem Pyramidenschema bauen:
      </p>
      <figure class="main-column">
        <img
          style="height: 18em"
          src="./img/circuits/majority-theta-dp.svg"
          loading="lazy"
          onClick="onImgClick(event)"
          class="constrained transition-all"
        />
      </figure>
      <p class="main-column">
        Um eine Analogie mit der Programmierpraxis zu bemühen: der Unterschied
        zwischen den beiden Konstruktionen für $\theta^n_k$ per Baum versus per
        Pyramidenschema entspricht dem Unterschied zwischen dem rekursiven Code
        für
        <span class="nowrap">${n \choose k}$,</span>
      </p>
      <div class="well highlight out">
        <pre class="listing numbered-pre">
def binomial(n,k):
   if k == 0 or k == n:
       return 1
   else:
       return binomial(n-1,k-1) + binomial(n-1,k)
</pre
        >
      </div>
      <p class="main-column">
        der exponentielle Laufzeit aufweist, und der effizienten Implementierung
        mittels
        <i>Dynamic Programming</i>, bei welchem wir uns die Zwischenergebnisse
        merken.
      </p>
      <p class="main-column">
        Um Größe und Tiefe des Schaltkreises zu analysieren, machen wir eine
        grobe Abschätzung. Für jedes
        <span class="nowrap">$\theta^m_l$,</span>
        das in unserer Pyramide vorkommt, brauchen wir 2 Gates; $m$ kann die
        Werte $0, \dots, n$ annehmen und $l$ die Werte
        <span class="nowrap">$0,\dots,k$,</span>
        also bekommen wir insgesamt höchstens $(n+1)(k+1)$ graue Kästchen und
        $O(n^2)$ Gates. Die Tiefe ist
        <span class="nowrap">$O(n)$,</span>
        da in jedem Schritt von grauem Kasten zu dem nächsttieferen der Wert von
        $m$ abnimmt. Insgesamt also haben wir gezeigt:
      </p>
      <div class="well theorem out">
        <p>
          <b>Theorem 2.5.2</b>
          Die Funktion $\maj_n (x_1,\dots,x_n)$ kann mit einem Schaltkreis der
          Größe
          <span class="nowrap">$O(n^2)$,</span>
          Tiefe $O(n)$ und Fan-in 2 berechnet werden.
        </p>
      </div>
      <h3 class="main-column">Majority durch Zählen</h3>
      <p class="main-column">
        $\maj_n(x_1,\dots,x_n)$ zu bestimmen sollte doch einfach sein: wir
        zählen die Anzahl der 1en und vergleichen sie mit
        <span class="nowrap">$\ceil{n}{2}$.</span>
        Wie aber sollen wir zählen? Ganz einfach: mit einem Binäraddierer! Sei
        $d = \ceil{\log_2(n+1)}$ die Anzahl der Bits in der Binärdarstellung von
        <span class="nowrap">$n$.</span>
        Wir interpretieren jede Input-Variable $x_i$ als
        <span class="nowrap">$d$-stellige</span>
        Binärzahl, wobei $x_i = 1$ der Zahl
        <span class="nowrap">$000\dots 001$,</span>
        also 1 entspricht, und $x_i = 0$ der Zahl
        <span class="nowrap">$000\dots 0$,</span>
        also 0, und addieren die dann auf:
      </p>
      <figure class="main-column">
        <img
          style="height: 12em"
          src="./img/circuits/majority-by-adding.svg"
          loading="lazy"
          onClick="onImgClick(event)"
          class="constrained transition-all"
        />
      </figure>
      <div class="well exercise out">
        <p>
          <b>Übungsaufgabe 2.5.2</b>
          Bestimmen Sie asymptotisch die Größe und die Tiefe dieses
          Schaltkreises. Achten Sie besonders bei der Berechnung der Größe
          darauf, dass die untersten Add-Gadgets ja 1-stellige oder dann
          2-stellige Zahlen addieren müssen und erst die weniger obersten
          Gadgets Zahlen mit $\Theta(\log n)$ Bits als Input bekommen.
        </p>
      </div>
      <h3 class="main-column">$O(\log n)$ Tiefe mit 2-for-3-Addierern.</h3>
      <p class="main-column">
        Die vorherige Konstruktion mit den Addierern war schon deutlich
        effizienter als unsere pyramidenartige
        <span class="nowrap">$\theta^m_l$-Konstruktion,</span>
        allerdings wurde das Ziel, eine Tiefe von $O (\log n)$ zu erreichen,
        wieder verfehlt, wenn auch knapp. Die Idee, die eine Tiefe von $O (\log
        n)$ erreichen wird, ist ebenso einfach wie genial.
      </p>
      <div test="test" class="well lemma out">
        <p>
          <b>Lemma 2.5.3</b>
          <b>(2-for-3 Adder)</b>
          Es gibt einen Schaltkreis mit $O(n)$ Gates, Tiefe 2 und Fan-In 2, der
          als Input drei
          <span class="nowrap">$n$-stellige</span>
          Binärzahlen $x,y,z$ nimmt und zwei
          <span class="nowrap">$n+1$-stellige</span>
          Binärzahlen $u, v$ ausgibt, so dass $$ x + y + z = u + v $$ gilt.
        </p>
      </div>
      <div class="well highlight out">
        <p>
          <b>Beweis.</b>
          Ich demonstriere das Beweisprinzip erst einmal mit drei Zahlen in
          Basis 10:
        </p>
        <figure>
          <img
            style="height: 10em"
            src="./img/circuits/2-for-3-adder-example.svg"
            loading="lazy"
            onClick="onImgClick(event)"
            class="constrained transition-all"
          />
        </figure>
        <p>
          Wir addieren also pro Stelle drei (einstellige) Zahlen, führen den
          Übertrag (das Carry) aber nicht der weiter links stehenden Stelle zu,
          sondern sammeln alle Überträge und bilden daraus die
          <span class="nowrap">$n+1$-stellige</span>
          Zahl
          <span class="nowrap">$u$.</span>
          Für Binärzahlen ist das natürlich noch einfacher:
        </p>
        <figure>
          <img
            style="height: 15em"
            src="./img/circuits/2-for-3-adder-binary.svg"
            loading="lazy"
            onClick="onImgClick(event)"
            class="constrained transition-all"
          />
        </figure>
        <p>
          Dieser Schaltkreis hat insgesamt $O(n)$ Gates und Tiefe 2 (wobei wir
          die NOT-Gates im
          <span class="nowrap">$\oplus$-Gate</span>
          nicht mitzählen).<span class="qed">$\square$</span>
        </p>
      </div>
      <p class="main-column">
        Wir interpretieren nun die $n$ Inputs $x_1,\dots,x_n$ von Majoroty als
        einstellige Binärzahlen, sortieren sie in Dreiergruppen und machen per
        2-for-3-Addierer daraus $ \ceil{\frac{2n}{3}}$ Zahlen. Dann machen wir
        (mit den mittlerweile 2-stelligen Zahlen) weiter und bekommen circa $
        \ceil{\frac{4n}{9}}$ Zahlen. Auf jeder Ebene schrumpft die Anzahl der
        Zahlen um einen Faktor von
        <span class="nowrap">$\frac{2}{3}$;</span>
        nach $ \log_{3/2} n $ Ebenen haben wir schließlich noch zwei
        mittlerweile
        <span class="nowrap">($\log n$)-stellige</span>
        Zahlen, die wir mit einem "normalen" Binäraddierer addieren. Das
        Ergebnis vergleichen wir mit dem
        <span class="nowrap">$\geq$-Schaltkreis</span>
        mit
        <span class="nowrap">$\frac{k+1}{2}$.</span>
        Was ist die Tiefe des Gesamtschaltkreises? Es ist $$\begin{align*}
        &amp;\log_{3/2} n \times \depth(\textnormal{2-for-3 adder}) \\ +&amp;
        \depth(\textnormal{Binäraddierer für ($\log n$)-stellige Zahlen}) \\
        +&amp; \depth(\textnormal{$\geq$-Schaltkreis für ($\log n$)-stellige
        Zahlen} \\ =&amp; O(\log n) + O(\log \log n) + O(\log \log n) = O(\log
        n) \ . \end{align*}$$ Die Größe des Schaltkreises wird dominiert von den
        2-for-3-Addierern. Wir haben $O(n)$ viele davon, allerdings hat jeder
        bis zu $O(\log n)$ viele Gates, da wir ja
        <span class="nowrap">($\log n$)-stellige</span>
        Zahlen addieren müssen; wir haben insgesamt also $O (n \log n)$ viele
        Gates.
      </p>
      <div class="well theorem out">
        <p>
          <b>Theorem 2.5.4</b>
          Die Konstruktion mit 2-for-3-Addierern gibt uns einen Schaltkreis für
          Majority mit Fan-in 2, Tiefe $O(\log n)$ und Größe $O (n \log n)$
        </p>
      </div>
      <div class="well exercise out">
        <p>
          <b>Übungsaufgabe 2.5.3</b>
          Führen Sie eine genauere Abschätzung der Größe durch. Untersuchen Sie
          insbesondere:
        </p>
        <ol>
          <li>
            <p>Wieviele 2-for-3-Addierer haben Sie in Ebene $i$ des Baumes?</p>
          </li>
          <li>
            <p>
              Wieviel Bits haben die Zahlen auf Ebene
              <span class="nowrap">$i$,</span>
              und wie groß muss daher der 2-for-3-Addierer sein?
            </p>
          </li>
          <li>
            <p>Was ergibt sich insgesamt in Summe?</p>
          </li>
        </ol>
      </div>
      <p class="main-column">
        Wir haben nun also fast alle unserer Ziele erreicht. Allerdings hat die
        Konstruktion mit 2-for-3-Addierern einen Schönheitsfehler: sie ist nicht
        monoton. Warum sollten wir das wollen? Nun ja, Majority ist eine
        monotone Funktion, also ist es ja irgendwie verständlich, dass wir auch
        einen monotonen Schaltkreis wollen. Unser Pyramidenschema, in dem wir
        alle $\theta^m_k$ berechnen, ist monoton, hat allerdings leider Tiefe
        <span class="nowrap">$\Omega(n)$.</span>
      </p>
      <h3 class="main-column">
        Monoton und polylogarithmische Tiefe durch Halbierung und Aufzählung.
      </h3>
      <p class="main-column">
        Die Idee ist, dass wir, anstatt $\theta^n_k$ aus
        <span class="nowrap">$x_n$,</span>
        $\theta^{n-1}_{k-1}$ und $\theta^{n-1}_{k}$ zu berechnen, versuchen,
        irgendwie von $n$ auf $n/2$ runterzukommen. Dann könnten wir rekursiv
        weitermachen und müssten uns nur durch logarithmisch viele Werte von $n$
        wühlen. Wir sehen, dass wir $k$ auf $k+1$ Weisen als Summe zweier
        nichtnegativer Zahlen $a+b = k$ schreiben können. Des weiteren zerlegen
        wir $\mathbf{x} \in \{0,1\}^n$ in $\mathbf{y} = (x_1, \dots, x_{n/2})$
        und $\mathbf{z} = (x_{n/2+1}, \dots, x_n)$ und sehen, dass
        $$\begin{align*} \sum_i x_i&amp;\geq k \quad \Longleftrightarrow \\
        \sum_i y_i&amp;\geq a \wedge \sum_j z_j \geq b \textnormal{ für Werte
        $a,b \geq 0$ mit $a + b = k$} \end{align*}$$ und somit $$\begin{align*}
        \theta^n_k(\mathbf{x})&amp;= \bigvee_{a=0}^k ( \theta^{n/2}_a
        (\mathbf{y}) \wedge \theta^{n/2}_{k-a} (\mathbf{z}) ) \end{align*}$$
        Wenn wir diese Konstruktion rekursiv fortsetzen, erhalten wir $\log n$
        Ebenen und somit auf den ersten Blick logarithmische Tiefe. Auf den
        zweiten Blick erkennen wir, dass wir etwas geschummelt haben: die
        <span class="nowrap">$\bigvee$-Gates</span>
        haben sehr großen Fan-in, nämlich bis zu
        <span class="nowrap">$n$.</span>
        Um Fan-in 2 zu erreichen, müssen wir jedes
        <span class="nowrap">$\bigvee$-Gate</span>
        durch einen Binärbaum aus normalen
        <span class="nowrap">$\vee$-Gates</span>
        von Fan-in 2 ersetzen. Dies gibt uns zusätzlich Tiefe $O(\log n)$
        <i>pro <span class="nowrap">$\bigvee$-Gate</span></i
        >; wir erhalten also insgesamt eine Tiefe von
        <span class="nowrap">$O(\log^2 n)$.</span>
      </p>
      <div class="well exercise out">
        <p>
          <b>Übungsaufgabe 2.5.4</b>
          dass polynomiell viele (in diesem Falle: $O(n^2)$ viele) Gates
          ausreichen. Zeigen Sie, wie die gerade skizzierte Konstruktion so
          ausgeführt werden kann,
        </p>
      </div>
      <h3 class="main-column">
        Monoton und logarithmische Tiefe: Valiants probabilitische Konstruktion
      </h3>
      <div class="well theorem out">
        <p>
          <b>Theorem 2.5.5</b>
          Es gibt einen monotonen Schaltkreis mit Fan-in 2, Tiefe $O(\log n)$
          und Größe
          <span class="nowrap">$\poly(n)$,</span>
          der $\maj_n$ berechnet.
        </p>
      </div>
      <div class="well highlight out">
        <p>
          <b>Beweis.</b>
          Die Beweismethode, die wir verwenden, ist womöglich neu für Sie. Wir
          verwenden bei der Konstruktion des Schaltkreises
          <i>Zufall</i>; am Ende werden wir zeigen, dass dieser zufällige
          Schaltkreis mit hoher Wahrscheinlichkeit $\maj_n$ auf allen möglichen
          $2^n$ Inputs korrekt berechnen, und folgern daraus, das etwas, was mit
          hoher Wahrscheinlichkeit eintritt, auch existieren muss. Die Existenz
          folgt also schlussendlich aus einer Wahrscheinlichkeitsrechnung. Das
          heißt auch, dass ich Ihnen für konkretes
          <span class="nowrap">$n$,</span>
          sagen wir
          <span class="nowrap">$n = 99$,</span>
          nicht hinschreiben könnte, wie ein korrekter Schaltkreis aussähe; ich
          könnte die randomisierte Konstruktion durchführen und Ihnen erklären,
          das der resultierende Schaltkreis höchstwahrscheinlich korrekt ist.
        </p>
        <p>
          Während des ganzen Beweises müssen Sie sich vor Augen halten, dass wir
          bei der Konstruktion des Schaltkreises $C$ Zufall verwenden; wir
          nehmen nicht an, dass die Inputs $x \in \{0,1\}^n $ in irgendeiner
          Weise zufällig sind. Wir verwenden also
          <i>Wahrscheinlichkeitsverteilungen über Schaltkreisen</i>, nicht von
          über Inputs. Zuerst definieren wir die
          <i>Signalstärke</i>
          von Verteilungen über Schaltkreise.
        </p>
        <div class="well definition">
          <p>
            <b>Definition 2.5.6</b>
            Sei $\mathcal{C}$ eine Verteilung über Schaltkreise mit
            Input-Variablen
            <span class="nowrap">$x_1,\dots,x_n$.</span>
            Wir sagen, dass $\mathcal{C}$
            <i>Signalstärke mindestens $\delta$</i>
            hat, wenn $$ \forall x \in \{0,1\}: \quad \Pr_{C \in \mathcal{C}}
            [C(x) = \maj_n(x)] \geq \frac{1 + \delta}{2} $$ gilt.
          </p>
        </div>
        <p>
          In Worten, wenn der zufällig ausgewählte Schaltkreis $C$ den Wert
          $\maj_n(x)$ besser als ein Münzwurf vorhersagt, und zwar um $\delta/2$
          besser. Wir können einen ganz einfachen (zufälligen Schaltkreis)
          bauen, der ein schwache aber positive Signalstärke hat.
        </p>
        <div class="well lemma">
          <p>
            <b>Lemma 2.5.7</b>
            Es gibt eine Wahrscheinlichkeitsverteilung $\mathcal{C}_0$ über
            monotone Schaltkreise der Größe 1, die Signalstärke $\frac{1}{n}$
            hat. Genauer gesagt gilt für jeden Input
            <span class="nowrap">$x \in \{0,1\}^n$:</span>
            ein nach dieser Verteilung zufällig ausgewählter Schaltkreis $C \sim
            \mathcal{C}_0$ ist mit Wahrscheinlichkeit mindestens $\frac{1}{2} +
            \frac{1}{2n}$ korrekt ist. Formal ausgedrückt: $$ \forall \x \in
            \cube^n: \quad \Pr_{C \sim \mathcal{C}_0} [C(\x) = \maj_n(\x)] =
            \frac{1}{2} + \frac{1}{2n} \ . $$
          </p>
        </div>
        <div class="well subtheorem">
          <p>
            <b>Beweis.</b>
            Der Schaltkreis bzw. die Wahrscheinlichkeitsverteilung ist extrem
            einfach. Wir wählen zufällig einen Index $I \in \{1,\dots,n\}$ und
            geben $x_I$ als unseren Schaltkreis $C$ (bestehend aus einem
            einzigen Input-Gate, das gleichzeitig das Output-Gate ist) aus.
            Dieser Schaltkreis ist natürlich monoton.
          </p>
          <p>
            Beachten Sie, dass ich den Index groß geschrieben mit $I$ bezeichne,
            nicht
            <span class="nowrap">$i$;</span>
            das ist Konvention, weil $I$ eine Zufallsvariable ist. Sei nun ein
            festes $\x \in \{0,1\}$ gegeben. Mit welcher Wahrscheinlichkeit ist
            unser (recht primitiver) Schaltkreis korrekt? $$\begin{align*}
            C(\x)&amp;= \maj_n (\x) \quad \Longleftrightarrow \\ x_I&amp;=
            \maj_n (\x) \ . \end{align*}$$ Wir unterscheiden nun zwei Fälle.
            Wenn $\maj_n(\x) = 1$ ist, dann gibt es mindestens $k+1$ Indizes $i$
            mit
            <span class="nowrap">$x_i = 1$.</span>
            Wenn wir mit $I$ einen solchen ausgewählt haben, dann sind wir
            erfolgreich. Die Wahrscheinlichkeit hierfür ist $$\begin{align*}
            \Pr_{C \sim \mathcal{C}_0} [C(\x) = 1] = \Pr_{I \in [n]} [x_I =
            1]&amp;= \frac{| \{i \in [n]\ | x_i = 1\}}{n} \geq \frac{k+1}{n} \\
            &amp;= \frac{k+1}{2k+1} = \frac{k + \frac{1}{2} + \frac{1}{2}}{2k+1}
            \\ &amp;= \frac{1}{2} + \frac{1}{2n} \ . \end{align*}$$ Wenn nun
            $\maj_n(\x) = 0$ ist, dann gibt es mindestens $k+1$ Stellen $i$ mit
            <span class="nowrap">$x_i = 0$,</span>
            und somit ist $C(\x)$ auch wieder mit Wahrscheinlichkeit mindestens
            $\frac{k+1}{n+1}$ korrekt.<span class="qed">$\square$</span>
          </p>
        </div>
        <p>
          Um eine Analogie aus dem Alltag zu bemühen: wenn Sie für eine
          Wahlprognose
          <i>einen</i>
          zufällig ausgewählten Bürger befragen, so ist das Ergebnis zwar nicht
          wirklich repräsentativ, aber immerhin leicht besser, als wenn Sie
          einfach raten würden. Unser zufälliger Schaltkreis sendet uns also ein
          schwaches aber positives Signal in die richtige Richtung. Die
          Signalstärke ist
          <span class="nowrap">$\frac{1}{n}$.</span>
        </p>
        <p>
          Die zweite Zutat ist nun ein "Signalverstäker". Angenommen, eine
          Verteilung $\mathcal{C}$ hat Signalstärke
          <span class="nowrap">$\delta$,</span>
          also $$ \forall \x \in \{0,1\}^n : \quad \Pr_{C \sim \mathcal{C}}
          [C(\x) = \maj_n(\x)] \geq \frac{1+\delta}{2} \ . $$ Dann können wir
          <i>drei</i>
          Schaltkreise $C_1, C_2, C_3 \sim \mathcal{C}$ unabhängig voneinander
          samplen und einen neuen Schaltkreis bauen:
          <span class="nowrap"
            >$C'(\x) := \maj_3 (C_1(\x), C_2(\x), C_3(\x))$.</span
          >
          Dies gibt uns wiederum eine Verteilung über Schaltkreise, die wir
          $\mathcal{C}^{\otimes 3}$ nennen. Diese hat eine höhere Signalstärke:
        </p>
        <div class="well lemma">
          <p>
            <b>Lemma 2.5.8</b>
            Falls $\mathcal{C}$ eine Verteilung über Schaltkreise der Tiefe $d$
            und Größe $s$ ist und $\mathcal{C}$ Signalstärke $\delta$ hat, dann
            gilt:
          </p>
          <ol>
            <li>
              <p>
                alle Schaltkreise in $\mathcal{C}^{\otimes 3}$ haben Tiefe
                <span class="nowrap">$d+2$;</span>
              </p>
            </li>
            <li>
              <p>
                alle Schaltkreise in $\mathcal{C}^{\otimes 3}$ haben Größe
                <span class="nowrap">$3s+4$;</span>
              </p>
            </li>
            <li>
              <p>
                die Signalstärke von $\mathcal{C}^{\otimes 3}$ ist
                <span class="nowrap"
                  >$\frac{3}{2} \delta - \frac{1}{2}\delta^3$.</span
                >
              </p>
            </li>
          </ol>
        </div>
        <div class="well highlight">
          <p>
            <b>Beweis.</b>
            Wir betrachten ein festes $\x \in \cube^n$ mit
            <span class="nowrap">$\maj_n(\x) = 1$;</span>
            der Fall $\maj_n(\x) = 0$ ist analog. Wir definieren nun
            <span class="nowrap">$U := C_1(\x)$,</span>
            $V := C_2(\x)$ und
            <span class="nowrap">$W := C_3(\x)$.</span>
            Da $C_1, C_2, C_3 \sim \mathcal{C}$ zufällige Schaltkreise sind,
            sind $U, V, W$ Zufallsvariable über
            <span class="nowrap">$\cube$,</span>
            und zwar
            <i>unabhängig</i>, weil wir $C_1, C_2, C-3$ auch unabhängig
            gesampelt haben. Wir wissen:
            <span class="nowrap"
              >$\Pr[U=1] = \Pr[V=1] = \Pr[W=1] \geq \frac{1+\delta}{2} =:
              p$.</span
            >
            Was ist nun
            <span class="nowrap">$\Pr[\maj_3(U,V,W) = 1]$?</span>
            $$\begin{align*} \Pr[\maj_3(U,V,W)=1]&amp;= \Pr[U=V=W=1] +
            \Pr[\textnormal{genau zwei von $\{U,V,W\}$ sind 1}] \\ &amp;= p^3 +
            3p^2 (1-p) = \pfrac{1 + \delta}{2}^3 + 3 \pfrac{1 + \delta}{2}^2
            \frac{1 - \delta}{2} \\ &amp;= \frac{1}{8} (4 + 6 \delta - 2
            \delta^3) \\ &amp;= \frac{1}{2} \left( 1 + \frac{3}{2} \delta -
            \frac{1}{2}\delta^3 \right) \ . \end{align*}$$
          </p>
          <p>
            Die Signalstärke von $\mathcal{C}^{\otimes 3}$ ist also mindestens
            <span class="nowrap"
              >$\frac{3}{2} \delta - \frac{1}{2} \delta^3$.</span
            ><span class="qed">$\square$</span>
          </p>
        </div>
        <p>
          Wir beginnen nun mit der Verteilung $\mathcal{C}_0$ über Schaltkreise
          der Größe 1 und definieren $$\begin{align*} \mathcal{C}_{i+1} :=
          (\mathcal{C}_i)^{\oplus 3} \ . \end{align*}$$
        </p>
        <p>
          Zur Wiederholung: um $C \sim \mathcal{C}_{i+1}$ zu sampeln, sampeln
          wir unabhängig drei Schaltkreise $\sim \mathcal{C}_i$ und verknüpfen
          deren Output-Gates mit einem
          <span class="nowrap">$\maj_3$-Gadget.</span>
          Wenn $\mathcal{C}_i$ die Signalstärke $\delta_i$ hat, dann hat
          $\mathcal{C}_{i+1}$ Signalstärke
          <span class="nowrap"
            >$\frac{3}{2} \delta_i - \frac{1}{2} \delta_i^3$.</span
          >
          Wenn $\delta_i \leq 1/2$ sein sollte, dann ist das mindestens
          <span class="nowrap">$\frac{5}{4} \delta_i$.</span>
          Daraus folgt, dass nach höchstens $i^* := \log_{5/4} n$
          Rekursionsstufen eine Signalstärke von mindestens $1/2$ erreicht ist:
          $\mathcal{C}_{i^*}$ hat Signalstärke mindestens
          <span class="nowrap">$1/2$.</span>
        </p>
        <p>
          Wenn wir jetzt die rekursive Konstruktion fortsetzen, steigt die
          Signalstärke weiter an und konvergiert gegen
          <span class="nowrap">$1$:</span>
          <span class="nowrap"
            >$\lim_{i \rightarrow \infty} \delta_i = 1$.</span
          >
          Die Frage ist nur, wie schnell konvergiert es? Da wir nun nicht mehr
          an Wahrscheinlichkeiten interessiert sind, die knapp über $1/2$
          liegen, sondern an solchen, die knapp unter $1$ liegen, führen wir
          einen Parameterwechsel durch: eine Verteilung $\mathcal{C}$ von
          Schaltkreisen mit Inputs $x_1,\dots,x_n$ hat
          <i>Fehlerwahrscheinlichkeit $\epsilon$</i>, wenn $$\begin{align*}
          \forall \x \in \cube^n: \Pr_{C \sim \mathcal{C}}[ C(\x) = \maj_n(\x)]
          \geq 1 - \epsilon \ . \end{align*}$$
        </p>
        <p>
          Eine Signalstärke von $\delta$ entspricht einer
          Fehlerwahrscheinlichkeit von
          <span class="nowrap">$\frac{1-\delta}{2}$.</span>
          Die Verteilung $\mathcal{C}_{i^*}$ hat also eine
          Fehlerwahrscheinlichkeit von höchstens
          <span class="nowrap">$\frac{1 - 1/2}{2} = 1/4$.</span>
          Das obige Lemma, nun aus der Sicht der Fehlerwahrscheinlichkeit, liest
          sich so:
        </p>
        <div class="well behauptung">
          <p>
            <b>Behauptung 2.5.9</b>
            Wenn $\mathcal{C}$ Fehlerwahrscheinlichkeit $\epsilon$ hat, dann hat
            $\mathcal{C}^{\otimes 3}$ Fehlerwahrscheinlichkeit $3 \epsilon^2$
          </p>
        </div>
        <div class="well highlight">
          <p>
            <b>Beweis.</b>
            Wie im Beweis vom Lemma setzen wir $p := \frac{1+p}{2} = 1-\epsilon$
            und erhalten $$\begin{align*} \Pr[\maj_3(U,V,W) = 1]&amp;= p^3 + 3
            p^2 (1-p) = (1 - \epsilon^3) + 3 (1- \epsilon)^2 \epsilon = 1 - 3
            \epsilon^2 \ . \end{align*}$$
          </p>
          <p>
            Somit hat $\mathcal{C}^{\otimes 3}$ Fehlerwahrscheinlichkeit
            <span class="nowrap">$3 \epsilon^2$.</span
            ><span class="qed">$\square$</span>
          </p>
        </div>
        <p>
          Für $i^* := \log_{5/4} n$ hat $\mathcal{C}_{i^*}$ eine
          Fehlerwahrscheinlichkeit von höchstens
          <span class="nowrap">$1/4$.</span>
          Für $i^* + 1$ wird das zu $3 \pfrac{1}{4}^2 = \frac{3}{16}$ und für
          $i^* + 2$ zu
          <span class="nowrap"
            >$3 \pfrac{3}{16}^2 = \frac{27}{256} \leq \frac{1}{9}$.</span
          >
          Wenn nun $\epsilon \leq \frac{1}{9}$ ist, dann gilt
          <span class="nowrap">$3 \epsilon^2 \leq \epsilon^{3/2}$.</span>
          Wir definieren
          <span class="nowrap">$\epsilon_i := \frac{1 - \delta_i}{2}$,</span>
          also die Fehlerwahrscheinlichkeit von
          <span class="nowrap">$\mathcal{C}_i$.</span>
          Es gilt also $\epsilon_{i+1} \leq (\epsilon_i)^{3/2}$ für alle $i \geq
          i^*+2$ und somit $$\begin{align*} \epsilon_{i^*+2 + j} \leq
          \left(\epsilon_{i^*}\right)^{\pfrac{3}{2}^j} \leq
          \pfrac{1}{4}^{\pfrac{3}{2}^j} \ . \end{align*}$$
        </p>
        <p>
          Qualitativ sehen wir: solange $\delta_i \leq 1/2$ gilt, wächst die
          Signalstärke exponentiell an. Dieses exponentielle Wachstum kann
          natürlich nicht beliebig weitergehen. Jenseits $\delta_i \leq 1/2$
          hört das auf, dafür
          <i>fällt</i>
          nun die Fehlerwahrscheinlichkeit
          <i>doppelt exponentiell</i>. Für $j^* := \log_{3/2} n$ gilt dann
          $$\begin{align*} \epsilon_{i^* + 2 + j^*} \leq \pfrac{1}{4}^{n} \lt
          2^{-n} \ . \end{align*}$$
        </p>
        <p>In Bildern:</p>
        <figure>
          <img
            style="height: 18em"
            src="./img/circuits/majority-probability-labeled.svg"
            onClick="onImgClick(event)"
            class="constrained transition-all"
          />
          <br />
          <p>Graph der Funktion $p \mapsto p^3 + 3 p^2 (1-p)$</p>
        </figure>
        <hr />
        <figure>
          <img
            style="height: 18em"
            src="./img/circuits/majority-probability-close-to-half-labeled.svg"
            onClick="onImgClick(event)"
            class="constrained transition-all"
          />
          <br />
          <p>
            Signalstärke $\delta$ wächst für $p \in [1/2, 3/4]$ exponentiell.
          </p>
        </figure>
        <hr />
        <figure>
          <img
            style="height: 18em"
            src="./img/circuits/majority-probability-close-to-one-labeled.svg"
            onClick="onImgClick(event)"
            class="constrained transition-all"
          />
          <br />
          <p>
            Fehlerwahrscheinlichkeit $\epsilon$ fällt für $p \in [3/4, 1/2]$
            doppelt exponentiell.
          </p>
        </figure>
        <hr />
        <p>
          Wir setzen nun $k := i^* + 2 + j^* = \log_{5/4} n + 2 + \log_{3/2} n =
          O(\log n)$ und sehen, dass $\mathcal{C}_k$ eine Verteilung über
          Schaltkreise mit Tiefe $O(\log n)$ und Fehlerwahrscheinlichkeit
          kleiner als $2^{-n}$ ist. Was nun kommt, ist ein absolutes
          Standardargument in probabilitischen Beweisen: ein Union Bound. Das
          geht ungefähr so: wenn für jedes feste $\b \in \cube^n$ ein
          Schaltkreis $C \mathcal{C}_k$ mit Wahrscheinlichkeit $\epsilon_k$
          irrt, dann ist die Wahrscheinlichkeit, dass $C$ sich für irgendein $\x
          \in \cube^n$ irrt, höchstens
          <span class="nowrap">$2^n \epsilon_k$.</span>
          Formal: für jedes $\b \in \cube^n$ definieren wir $E_{\b}$ als die
          Menge der Schaltkreise mit Input-Variablen
          <span class="nowrap">$x_1,\dots,x_n$,</span>
          die sich auf $\b$ irren, also $$\begin{align*} E_{\b} :=
          \{\textnormal{Schaltkreise } C \textnormal{ über } x_1, \dots, x_n \ |
          \ C(\b) \ne \maj_n(\b) \} \ . \end{align*}$$
        </p>
        <p>
          Die Verteilung $\mathcal{C}_k$ existiert ja im Wahrscheinlichkeitsraum
          aller Boolescher Schaltkreise mit Inputs
          <span class="nowrap">$x_1,\dots, x_n$.</span>
          Die Menge $E_{\b}$ ist somit ein
          <i>Ereignis</i>
          in diesem Raum. Ein extrem unwahrscheinliches Ereignis:
          $$\begin{align*} \forall \b \in \cube^n: \Pr_{C \sim \mathcal{C}_k} [
          C \in E_{\b} ] = \epsilon_k \lt 2^{n-} \ . \end{align*}$$
        </p>
        <p>
          Oder kompakt ausgedrückt:
          <span class="nowrap">$\Pr_{\mathcal{C}_k} [E_{\b}] \lt 2^n$.</span>
          Wir haben nun ein Ereignis $E_{\b}$ für jedes $\b \in \cube^n$ und
          definieren $$\begin{align*} E := \bigcup_{\b \in \cube^n} E_{\b} \ .
          \end{align*}$$
        </p>
        <p>
          Was ist
          <span class="nowrap">$E$?</span>
          Es ist die Menge der Schaltkreise, die sich auf mindestens einem $\b
          \in \cube^n$ irren. Was ist das Komplement
          <span class="nowrap">$\bar{E}$?</span>
          Das ist die Menge der Schaltkreise, die sich auf keinem $\b \in
          \cube^n$ irren, also die Menge der Schaltkreise, die $\maj_n$ korrekt
          berechnen. Es gilt nun $$\begin{align*} \Pr_{\mathcal{C}_k}[E]&amp;=
          \Pr_{\mathcal{C}_k} \left[\bigcup_{\b \in \cube^n} E_{\b} \right] \\
          &amp;\leq \sum_{\b \in \cube^n} \Pr_{\mathcal{C}_k} [E_{\b}] \\ &amp;=
          \sum_{b \in \cube^n} \epsilon_k\\ &amp;\lt \sum_{b \in \cube^n} 2^{-n}
          = 2^n 2^{-n} = 1 \ . \end{align*}$$
        </p>
        <p>
          Also $\Pr_{\mathcal{C}_k}[E] \lt 1$ und somit
          <span class="nowrap">$\Pr_{\mathcal{C}_k}[\bar{E}] \gt 0$.</span>
          Das bedeutet, dass ein zufälliger Schaltkreis $C \sim \mathcal{C}_K$
          mit positiver Wahrscheinlichkeit die Funktion $\maj_n$ korrekt
          berechnet. Jeder Schaltkreis, der unter $\mathcal{C}_k$ gesampelt
          werden kann, hat Tiefe
          <span class="nowrap">$O(\log n)$,</span>
          Fan-in 2 und ist monoton, und somit schließen wir: es gibt einen
          monotonen Schaltkreis $C$ mit Fan-in 2 und Tiefe
          <span class="nowrap">$O(\log n)$,</span>
          der $\maj_n$ berechnet.
        </p>
        <p>
          Es bleibt die Frage, wie groß dieser Schaltkreis $C$ ist. Seien wir
          hier bequem: ein Schaltkreis mit Fan-in 2 und einem Output-Gate hat
          höchstens $2^i$ Gates, die Abstand $i$ vom Output-Gate haben. Somit
          hat ein Schaltkreis mit Fan-in 2 und Tiefe $d$ höchstens
          $$\begin{align*} 1 + 2 + 4 + \dots + 2^d = 2^{d+1}-1 \end{align*}$$
        </p>
        <p>
          Gates. Ein Schaltkreis mit Fan-in 2 und Tiefe $c \log_2 n$ hat also
          insgesamt höchstens $2^{c \log n + 1 } - 1 = O(n^c) = O(\poly(n))$
          Gates.<span class="qed">$\square$</span>
        </p>
      </div>
      <div class="well exercise out">
        <p>
          <b>Übungsaufgabe 2.5.5</b>
          Präzisieren Sie die Größe von Valiants Schaltkreis und bestimmen ein
          <span class="nowrap">$c \in \R$,</span>
          so dass er die Größe $\Theta(n^c)$ hat.
        </p>
      </div>
      <p class="main-column">
        Wir könnten nun noch ehrgeiziger sein und einen monotonen Schaltkreis
        mit Fan-in 2, Tiefe $O(\log n)$ und
        <i>linearer</i>
        Größe $O(n)$ anstreben.
      </p>
    </div>
  </body>
</html>
