<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 9.2 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 9, Section 2</title>
</head>
<body class="page-sub chapter-9 sub-2">
  <div id="menu">
    <div class="menu-left">
      <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
        </span>Inhaltsverzeichnis</a><a
        id="prev-page"
        href="./9-1.html"
      >&lt;&lt; Kapitel 9.1<span
          style="visibility:hidden"
          id="prev-page-tooltip"
        >Das Zeithierarchietheorem</span></a>
    </div>
    <div class="menu-right">
      <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
        id="next-page"
        href="./9-3.html"
      >Kapitel 9.3 &gt;&gt;<span
          style="visibility:hidden"
          id="next-page-tooltip"
        >Nichtdeterministische Zeit</span></a>
    </div>
  </div>
  <div class="main-column page-title">
    <p>
      9.2&ensp;Turing-Maschinen zu Schaltkreisen!
    </p>
  </div>
  <p class="main-column">
    Sei $L \subseteq \{0,1\}^*$ eine Sprache und $M$ eine
    Turing-Maschine, die $L$ in Zeit $t(n)$ entscheidet. Das heißt,
    für jedes $x \in \{0,1\}^*$ erreicht $M$ nach maximal $t(|x|)$
    Schritten einen Endzustand, und $M(x) = \texttt{accept}$ genau
    dann, wenn $x \in L$ ist. Für jedes $n \in \N$ sei $f_{L,n}$ die
    Boolesche Funktion
  </p>
  <div class="math-block main-column">
    $$
    \begin{align*}
    f_{L,n} : \{0,1\}^n&amp;\rightarrow \{0,1\} \\
    x&amp;\mapsto [M(x) = \texttt{accept}]
    \end{align*}
    $$
  </div>
  <p class="main-column">
    Also $f(x)=1$ falls $M$ die Eingabe $x$ akzeptiert und $f(x)=0$
    falls $M$ die Eingabe ablehnt (falls $L$ und $n$ aus dem Kontext
    hervorgehen, schreiben wir einfach
    <span class="nowrap">$f$).</span>
  </p>
  <div class="well statement out">
    <p>
      <b>Theorem</b>
      <b>9.2.1</b>
      Wenn $L$ in Zeit $t(n)$ entscheidbar ist und $t(n) \geq n$ gilt,
      dann gibt es einen Booleschen Schaltkreis $C$ mit $O(t(n)^2)$
      Gates, der $f_{L,n}$ berechnet.
    </p>
  </div>
  <div class="well highlight out">
    <p>
      <b>Beweisidee.</b>
      Die
      <span class="nowrap">$k$-Band-Turingmaschine</span>
      <span class="nowrap">$M$,</span>
      die $L$
      entscheidet, macht auf Eingabe $x$ höchstens $T = t(|x|)$
      Schritte. Es gibt also einen Bereich von insgesamt $2Tk$ Zellen
      <span class="nowrap">($2t$</span>
      pro Band), den sie nie verlässt. Das heißt, jede
      Konfiguration besteht aus $O(t)$ Zeichen. Die Funktion
      <span class="nowrap">$\hat{\delta}_M$,</span>
      die für jede Konfiguration $C$ die
      Nachfolgekonfiguration $C' := \hat{\delta}_M(C)$ berechnet, ist
      sehr lokal und sehr einfach; die
      <span class="nowrap">$i$-te</span>
      Stelle von Konfiguration
      $C$ hat nur auf die Stellen
      <span class="nowrap">$i-2$,</span>
      <span class="nowrap">$i-1$,</span>
      $i$ und $i+1$ von $C'$
      Einfluss. Somit können wir bei geeigneter binärer Codierung einen
      effizienten Schaltkreis bauen, der $\hat{\delta}_{M}$ berechnet.
      Da wir wissen, dass $M$ höchstens $T$ Schritte macht, wissen
      wir, dass $\hat{\delta}^*(x) = \hat{\delta}^{(T)}(x)$ gilt; wir
      können nun einfach $T$ Schaltkreise hintereinanderschalten, um
      $\hat{\delta}^*(x)$ und somit die Endkonfiguration zu berechnen;
      mit einem weiteren einfachen Schaltkreis können wir nun den
      erreichten Endzustand auslesen und entsprechen 0 oder 1 ausgeben.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
    </p>
  </div>
  <div class="well highlight out">
    <p>
      <b>Beweis.</b>
      Wir zeigen den Beweis schematisch anhand von $1$
      -Band-Turingmaschinen. Für $k$ -Bandmaschinen geht es fast genau
      so. Erinnern Sie sich an die Definition der
      <i>Konfiguration</i>
      einer
      Turing-Maschine (<span
        data-ref="def-TM-configuration"
        class="reference"
      ></span>). Formal war das ein Wort
      <span class="nowrap">$C \in \Gamma^* \times Q \times \Gamma^*$.</span>
      Ich zeige hier
      schematisch, wie aus einer Konfiguration per $\hat{\delta}$ die
      Folgekonfiguration wird:
    </p>
    <div class="figure__container">
      <figure>
        <img
          style="height:10em"
          src="img/09-complexity-theory/to-circuits/to-circuits-01-01.svg"
        >
      </figure>
    </div>
    <p>
      Wenn also das Kopfsymbol an Stelle $i$ der Konfiguration steht,
      dann können sich in der Folgekonfiguration nur die Stellen
      <span class="nowrap">$i-1$,</span>
      $i$ und $i+1$ ändern. Allerdings hat bei einer Linksbewegung das
      gelesene Zeichen (an Stelle
      <span class="nowrap">$i+1$)</span>
      auch Einfluss auf den
      zukünftigen Inhalt von Zelle
      <span class="nowrap">$i-1$;</span>
      Zelle $j$ kann also Zellen
      $j-2, j-1, j, j+1$ im nächsten Schritt beeinflussen. Lege wir
      zuerst eine globale Indizierung der Stellen der Konfiguration
      fest. Der Schreib-Lese-Kopf startet an Zelle $0$ des Bandes; das
      Eingabewort belegt also die Zellen
      <span class="nowrap">$0, 1, \dots, n-1$.</span>
      Da die
      Turingmaschine maximal $T$ Schritte läuft, ist der Kopf immer
      auf einer Zelle in
      <span class="nowrap">$\{-T, \dots, T\}$.</span>
      Wir können also jede
      Konfiguration mit $2T+1$ Zeichen darstellen - nein, mit
      $S := 2T+2$ Zeichen, da der Kopf selbst ja auch eine Stelle der
      Konfiguration belegt. Somit ist also
      <span class="nowrap">$C \in (Q \cup \Gamma)^{s}$.</span>
      Unbenutzte Zellen links und rechts füllen wir mit $\Box$ auf, so
      dass immer eine Länge von $s$ benutzt wird. Sei
      $C^{(t)} = \hat{\delta}^{(t)}(\qstart, x)$ die Konfiguration
      nach $t$ Schritten. Sei $C^{(t)}_i$ das
      <span class="nowrap">$i$-te</span>
      Zeichen darin.
      Den Wert von $C^{(t+1)}_i$ können wir bestimmen allein mit
      Kenntnis von
      <span class="nowrap">$C^{(t)}_{i-1}$,</span>
      <span class="nowrap">$C^{(t)}_{i}$,</span>
    </p>
    <p>
      $C^{(t)}_{i+1}$ und
      <span class="nowrap">$C^{(t)}_{i+2}$.</span>
      Es gibt also eine Funktion
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \tilde{\delta} : (Q \cup \Gamma)^4 \rightarrow (Q \cup \Gamma)
      \end{align*}
      $$
    </div>
    <p>
      die dies beschreibt, also mit
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      C^{(t+1)}_i&amp;= \tilde{\delta}
      \left(C^{(t)}_{i-1}, C^{(t)}_{i}, C^{(t)}_{i+1},C^{(t)}_{i+2}\right) \ .
      \end{align*}
      $$
    </div>
    <p>
      Im Detail ist die Arbeitsweise von $\tilde{\delta}$ wie folgt:
    </p>
    <div class="math-block">
      $$
      \begin{align*}
      \tilde{\delta}(a,x,y,*)&amp;=
      x \quad \textnormal{falls $a, x, y \in \Gamma$}\\
      \tilde{\delta}(a,x,q,y)&amp;= \begin{cases}
      r&amp;\textnormal{falls $\delta(q,y) = (r,*,L)$} \\
      x&amp;\textnormal{sonst.}
      \end{cases}\\
      \tilde{\delta}(x,q,y,*)&amp;=
      \begin{cases}
      x&amp;\textnormal{ falls $\delta(q,y) = (*, *, L)$ } \\
      r&amp;\textnormal{ falls $\delta(q,y) = (r, *, S)$ } \\
      z&amp;\textnormal{ falls $\delta(q,y) = (*, z, R)$ } \
      \end{cases}\\
      \tilde{\delta}(q,y,*,*)&amp;=
      \begin{cases}
      r&amp;\textnormal{ falls $\delta(q,y) = (r, *, R)$} \\
      z&amp;\textnormal{ falls $\delta(q,y) = (*, z, S)$} \\
      z&amp;\textnormal{ falls $\delta(q,y) = (*, z, L)$} \\
      \end{cases}
      \end{align*}
      $$
    </div>
    <p>
      Wenn wir $Q \cup \Gamma$ binär codieren mit
      $l := \ceil{\log_2 |Q \cup \Gamma|}$ Bits, so wird
      $\tilde{\delta}$ zu einer Booleschen Funktion
      <span class="nowrap">$\tilde{\delta} : \{0,1\}^{4l} \rightarrow \{0,1\}^l$.</span>
      Wir
      können dafür einen Schaltkreis der Größe
      $O(2^l) = O(|\Gamma \cup Q|^4)$ bauen: per Wahrheitstabelle wird
      er etwas größer; mit der Lupanov-Schranke (<span
        data-ref="theorem-lupanov"
        class="reference"
      ></span>) kriegen Sie
      <span class="nowrap">$O(2^l)$.</span>
      Wir haben nun also einen Schaltkreis
      <span class="nowrap">$\Delta$,</span>
      der $\tilde{\delta}$ berechnet. Seine Größe ist
      <span class="nowrap">$O(|\Gamma \cup Q|^4)$.</span>
      Da wir $|Q|$ und $|\Gamma|$ als konstant
      betrachten, da es nicht von der Eingabegröße $n=|x|$ abhängt,
      können wir sogar behaupten: die Größe von $\Delta$ ist
      <span class="nowrap">$O(1)$.</span>
      Wir schalten jetzt $S$ Kopien von $\Delta$ parallel, um
      $\hat{\delta}: \mathcal{C} \rightarrow \mathcal{C}$ zu
      berechnen, also aus einer gegebenen Konfiguration die
      Folgekonfiguration:
    </p>
    <div class="figure__container">
      <figure>
        <img
          style="height:10em"
          src="img/09-complexity-theory/to-circuits/to-circuits-02-01.svg"
        >
      </figure>
    </div>
    <p>
      Jeder Pfeil steht hierbei für $l$ Boolesche Kabel. Dies ergibt
      <i>einen</i>
      Schaltkreis
      <span class="nowrap">$\Delta^S$,</span>
      der
      $\hat{\delta}: \mathcal{C} \rightarrow \mathcal{C}$ berechnet
      (bzw. die Boolesche Codierung dieser Funktion) und Größe
      $O(S) = O(t(n))$ hat:
    </p>
    <div class="figure__container">
      <figure>
        <img
          style="height:10em"
          src="img/09-complexity-theory/to-circuits/to-circuits-03-01.svg"
        >
      </figure>
    </div>
    <p>
      Die Inputs, die Zellen außerhalb des Bereichs lesen, setzen wir
      einfach auf $\Box$ (Blank) bzw. dessen binäre Codierung, weil
      wir ja wissen, dass der Schreib-Lese-Kopf niemals dorthin
      gelangen wird. Jetzt schalten wir $T$ Kopien von $\Delta^{S}$
      hintereinander, um aus der Startkonfiguration $C^{(0)}$ die
      Endkonfiguration $C^{(T)}$ zu berechnen:
    </p>
    <div class="figure__container">
      <figure>
        <img
          style="height:30em"
          src="img/09-complexity-theory/to-circuits/to-circuits-04-01.svg"
        >
      </figure>
    </div>
    <p>
      Ganz zum Schluss bauen wir uns noch einen Schaltkreis, der an
      jede Stelle von $C{^(T)}$ schaut und, falls dort der Endzustand
      steht, liest, ob das
      <code>accept</code>
      oder
      <code>reject</code>
      ist und je nachdem
      $1$ oder $0$ ausgibt.
    </p>
    <div class="figure__container">
      <figure>
        <img
          style="height:13em"
          src="img/09-complexity-theory/to-circuits/to-circuits-05-01.svg"
        >
      </figure>
    </div>
    <p>
      Dieser endgültige Schaltkreis besteht im Wesentlichen aus $T$
      Kopien von $\Delta^S$ und hat somit Größe
      <span class="nowrap">$O(t(n)^2)$.</span><span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
    </p>
  </div>
  <p class="main-column">
    <BottomMenu id="bottom-menu">
      <div class="bottom-menu-left">
        <a href="./9-1.html">&lt;&lt; Kapitel 9.1<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >Das Zeithierarchietheorem</span></a>
      </div>
      <div class="bottom-menu-right">
        <a href="./9-3.html">Kapitel 9.3 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >Nichtdeterministische Zeit</span></a>
      </div>
    </BottomMenu>
  </p>
</body>
</html>
