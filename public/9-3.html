<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 9.3 of TI-2 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI-2 - Chapter 9, Section 3</title>
</head>
<body>
  <div class="body-wrapper">
    <div id="top-menu">
      <div id="top-menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./9-2.html"
        >&lt;&lt; Kapitel 9.2<span
            style="visibility:hidden"
            id="top-prev-page-tooltip"
          >Turing-Maschinen zu Schaltkreisen!</span></a>
      </div>
      <div id="top-menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./9-4.html"
        >Kapitel 9.4 &gt;&gt;<span
            style="visibility:hidden"
            id="top-next-page-tooltip"
          >Viele Beispiele aus NP</span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        9.3&ensp;Nichtdeterministische Zeit
      </p>
    </div>
    <p class="main-column">
      In
      <span
        data-ref="nondet-tm-to-det"
        class="reference"
      ></span>
      haben wir gesehen, dass jede nichtdeterministische
      Turing-Maschine durch eine deterministische simuliert werden kann,
      wobei der Zeit-Overhead exponentiell ist. Hier werden wir formal
      nicht-deterministische Zeitklassen definieren und eine leicht
      andere, zugänglichere Definition einführen.
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>9.3.1</b>
        Sei
        <span class="nowrap">$t: \N \rightarrow \N$.</span>
        Eine nicht-deterministische
        Turingmaschinen $M$
        <i>entscheidet</i>
        eine Sprache
        $L \subseteq \Sigma^*$ in Zeit $t$ wenn
      </p>
      <ul>
        <li>
          <p>
            $x \in L$ genau dann, wenn es eine Folge von Konfigurationen
          </p>
          <div class="math-block">
            $$
            \begin{align*}
            \qstart x \Rightarrow C_1 \Rightarrow \dots \Rightarrow C_m
            \end{align*}
            $$
          </div>
          <p>
            gibt, so dass $C_m$ eine akzeptierende Endkonfiguration ist
            und
          </p>
        </li>
        <li>
          <p>
            jede Folge von Konfigurationen, ausgehend mit der
            Startkonfiguration, nach höchstens $O(t)$ Schritten
            terminiert. Formal, wenn es Konstanten $a, b \in \N$ gibt,
            so dass für jede Folge
          </p>
          <div class="math-block">
            $$
            \begin{align*}
            \qstart x = C_0 \Rightarrow C_1 \Rightarrow C_2 \Rightarrow \dots \Rightarrow
            C_{at(|x|)+b}
            \end{align*}
            $$
          </div>
          <p>
            die Konfiguration $C_{at(|x|)+b}$ eine Endkonfiguration ist.
          </p>
        </li>
      </ul>
      <p>
        Die Konstanten $a, b$ dürfen von $L$ abhängen, aber natürlich
        nicht vom Eingabewort
        <span class="nowrap">$x$.</span>
        Wir definieren nun
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \NTIME_k(t) := \{L \subseteq \Sigma^* \ | \
        \textnormal{es gibt eine nichtdeterministische $k$-Band-TM $M$, die $L$ in Zeit $t$
        entscheidet}\}
        \end{align*}
        $$
      </div>
      <p>
        und schließlich
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \NTIME(t) := \bigcup_{k \geq 1} \NTIME_k(t) \ .
        \end{align*}
        $$
      </div>
    </div>
    <p class="main-column">
      Analog zur Komplexitätsklasse P (polynomielle Zeit) definieren wir
      NP (nichtdeterministisch polynomielle Zeit):
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>9.3.2</b>
        Wir definieren
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \textnormal{NP} := \bigcup_{k=1}^{\infty} \NTIME(n^k) \ ,
        \end{align*}
        $$
      </div>
      <p>
        also die Klasse aller Probleme (formal: Sprachen), die man in
        nichtdeterministisch polynomieller Zeit entscheiden kann.
      </p>
    </div>
    <h3 class="main-column subtopic-announcement">
      Zertifikatmaschinen
    </h3>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>9.3.3</b>
        <b>(Zertifikatmaschine).</b>
        Eine Zertifikatmaschine ist eine
        deterministische Turingmaschine mit $k$ Bändern. Band 1 ist das
        Eingabeband und Band 2 das
        <i>Zertifikatband.</i>
        Seien
        <span class="nowrap">$x, z \in \Sigma^*$.</span>
        Mit
        $f_M(x,z) \in \{\texttt{accept}, \texttt{reject},
        \texttt{undefined}\}$
        bezeichnen wir den Endzustand, den $M$ erreicht, wenn wir sie
        mit $x$ auf Band 1 und $z$ auf Band 2 starten, bzw.
        $\texttt{undefined}$ wenn $M$ gar nicht terminiert. Die von $M$
        akzeptierte Sprache ist
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        L(M) := \{x \in \Sigma^* \ | \ \exists z \in \Sigma^*: M(x,z) = \texttt{accept}\} \ .
        \end{align*}
        $$
      </div>
      <p>
        Wenn $L(M) = L$ und $M$ für jede Eingabe $x, z$ terminiert, dann
        <i>entscheidet</i>
        $M$ die Sprache $L$ . Sei
        <span class="nowrap">$t: \N \rightarrow \N$.</span>
        $M$ entscheidet $L$
        <i>in Zeit $t$</i>
        wenn für alle
        $x, z \in \Sigma^*$ die Berechnung $M(x,z)$ in maximal
        $O(t(|x|))$ Schritten terminiert. Die Konstante in der $O$
        -Notation darf von $M$ abhängen, aber nicht von $x$ oder
        <span class="nowrap">$z$.</span>
      </p>
    </div>
    <p class="main-column">
      Wir zeigen nun, dass Zertifikatmaschinen und nichtdeterministische
      Turingmaschinen sich gegenseitig effizient simulieren können und
      somit zwei äquivalente Sichtweisen auf das gleiche Konzept
      darstellen.
    </p>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>9.3.4</b>
        <b>(NDTM simulieren Zertifikatmaschinen).</b>
        Sei
        $t: \N \rightarrow \N$ zeitkonstruierbar. Sei $M$ eine
        Zertifikatmaschine, die die Sprache $L$ in Zeit $t$ entscheidet.
        Dann gibt es eine nichtdeterministische Turingmaschine
        <span class="nowrap">$M'$,</span>
        die
        $L$ in Zeit $t$ entscheidet.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Die Maschine $M'$ hat so viele Bänder wie
        <span class="nowrap">$M$,</span>
        wobei
        zu Beginn der Berechnung allerdings das zweite Band leer ist. Die
        Funktionsweise von $M'$ ist nun wie folgt: In Phase 1 berechnet
        sie in $O(t(|x|))$ Schritten die Zahl $T:= t(|x|)$ , das heißt,
        sie schreibt das Wort $1^{T}$ auf dem zweiten Band. Dann
        wechselt sie in den Zustand
        <code>guessCertificate</code>
        und beginnt Phase
        2. Hier ersetzt sie jede $1$ auf dem zweiten Band durch ein
        beliebiges Zeichen in
        <span class="nowrap">$\Sigma$.</span>
        Formal setzen wir für jedes
        <span class="nowrap">$x \in \Sigma$:</span>
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \delta_{M'}(\texttt{guessCertificate}, x, 1, \Box, \dots, \Box) =
        \{(\texttt{guessCertificate}, x, y, \Box, \dots, \Box), (S, R, S, \dots, S) \ | \ y \in \Sigma
        \} \ .
        \end{align*}
        $$
      </div>
      <p>
        Nun geht $M'$ auf dem zweiten Band wieder zum linken Rand und
        wechselt in wechselt in
        <span class="nowrap">$\qstart$,</span>
        den Startzustand von
        <span class="nowrap">$M$.</span>
        Nun
        beginnt Phase 3, in der sie genau so arbeitet wie $M$ . Wir
        müssen nun zeigen, dass für alle Eingabewörter $w \in \Sigma^*$
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        w \in L(M) \Longleftrightarrow w \in L(M') \ .
        \end{align*}
        $$
      </div>
      <p>
        Sei
        <span class="nowrap">$w \in L(M)$.</span>
        Nach Definition von Zertifikatmaschinen heißt
        das, dass es ein Zertifikat $z$ gibt, so dass
        $M(x,z) = \texttt{accept}$ und dass diese Berechnung höchstens
        $t$ Schritte benötigt. Wir können also annehmen, dass
        <span class="nowrap">$z \in \Sigma^{t}$,</span>
        denn mehr wird $M$ eh nicht lesen. Nun gibt
        es für $M'$ eine Folge von Konfigurationen, in der $M'$ nach
        Berechnung von $t(|x|)$ auf das zweite Band genau die
        Zeichenfolge $z$ schreibt. Danach startet sie
        <span class="nowrap">$M$,</span>
        die dann nach
        weiteren $t$ Schritten
        <code>accept</code>
        ausgibt. Es gilt also
        <span class="nowrap">$w \in L(M')$,</span>
        und somit gilt
        <span class="nowrap">$w \in L(M) \Longrightarrow w \in L(M')$.</span>
        Sei nun andererseits
        <span class="nowrap">$w \in L(M')$.</span>
        Betrachten wir die Konfigurationsfolge, die zu
        einem
        <code>accept</code>
        führt. Sei $z \in \Sigma^t$ das Wort, dass $M'$
        in Phase 2 auf das Band schreibt. In Phase 3 wird ja $M$
        simuliert, und $M$ gibt offensichtlich
        <code>accept</code>
        aus. Also gibt
        <span class="nowrap">$M$,</span>
        wenn wir es mit $x$ auf dem ersten Band und $z$ auf dem
        zweiten Band starten, auch
        <code>accept</code>
        aus, und somit gilt
        <span class="nowrap">$x \in L(M)$.</span><span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 9.3.1</b>
        Der obige Beweis enthält einige kleine Fehler. So tätigt nach
        Annahme die Berechnung von $M(x,z)$ ja maximal $O(t(|x|))$
        Schritte, formal also maximal
        <span class="nowrap">$a t(|x|) + b$,</span>
        nicht maximal
        $T = t(|x|)$ . Es kann also durchaus sein, dass mehr als
        $T = t(|x|)$ Zeichen von $z$ gelesen werden. Der zweite Fehler
        ist, dass eventuell das einzige $z$ , dass $M(x,z)$ zum
        akzeptieren bringt, die Länge $|z| = k \lt t(|x|)$ hat, und $M$
        wirklich überprüft, ob nach $k+1$ Zeichen auf ein Band ein $\Box$
        steht, und andernfalls ablehnt. Dann würde unser $M'$ oben immer
        ablehnen, weil sie in Phase 2 ja wirklich
        <i>genau</i>
        $T$ Zeichen
        schreibt. Flicken Sie diese beiden Fehler!
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>9.3.5</b>
        <b>(Zertifikatmaschinen simulieren NDTM).</b>
        Sei
        $t: \N \rightarrow \N$ zeitkonstruierbar. Sei $M$ eine
        nichtdeterministische Turingmaschine, die die Sprache $L$ in
        Zeit $t$ entscheidet. Dann gibt es eine Zertifikatmaschine
        <span class="nowrap">$M'$,</span>
        die $L$ in Zeit $t$ entscheidet.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Da $M$ nichtdeterministisch ist, ist
        $\delta \subseteq (Q \times \Gamma^k) \times (Q \times
        \Gamma^k \times \{L,S,R\}^k)$
        eine Relation, keine Funktion. Wir können es aber als Funktion in
        die Potenzmenge betrachten, also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \delta: Q \times \Gamma^k \rightarrow \mathcal{P} (Q \times \Gamma^k \times \{L,S,R\}^k)
        \end{align*}
        $$
      </div>
      <p>
        Nun bezeichnet $\delta(q, x_1, \dots, x_k)$ also die
        <i>Menge</i>
        der
        Aktionen, die die Turingmaschine nun ausführen könnte. Wie im
        Beweis von
        <span
          data-ref="nondet-tm-to-det"
          class="reference"
        ></span>können wir $M$ so umprogrammieren, dass sie die selbe Sprache
        entscheidet, aber $|\delta(q,x_1,x_2,\dots,x_k)| = 2$ gilt,
        außer für
        <span class="nowrap">$q \in \{\texttt{accept}, \texttt{reject}\}$.</span>
        Wir
        wählen uns zwei beliebige Symbole in $\Sigma$ und geben ihnen in
        diesem Beweis die Spitznamen $1$ und
        <span class="nowrap">$2$.</span>
        Der Zertifikatmaschine
        $M'$ geben wir zusätzlich zu den Bändern von $M$ ein weiteres
        Zertifikatband (das wir nun als das
        <i>zweite</i>
        Band bezeichnen).
        Sie verfährt nun wie folgt:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \delta(q, x_1, i, x_2, \dots, x_k) =
        \begin{cases}
        \textnormal{das $i$-te Element aus $\delta(q, x_1, x_2, \dots x_k)$}&amp;
        \textnormal{ falls $i \in \{1,2\}$} \\
        \texttt{reject}&amp;\textnormal{ ansonsten.}
        \end{cases}
        \end{align*}
        $$
      </div>
      <p>
        Falls nun $x \in L(M')$ ist, dann gibt es also einen Bandinhalt
        $z \in \Sigma^*$ für das zweite Band, so dass $M'(x,z)$
        akzeptiert. Wenn wir die Konfigurationsfolge von $M'$
        betrachten, aber das zweite Band ignorieren, dann ist das genau
        eine Konfigurationsfolge von
        <span class="nowrap">$M(x)$,</span>
        die zu
        <code>accept</code>
        führt.
        Somit gilt auch
        <span class="nowrap">$x \in L(M)$.</span>
        Falls umgekehrt $x \in L(M)$ ist,
        dann gibt es eine Konfigurationsfolge, die zu
        <code>accept</code>
        führt. In
        jedem Schritt wird dabei entweder das erste oder das zweite
        Element aus $\delta(q,x_1,\dots,x_k)$ genommen. Wir schreiben
        diese Folge als $z \in \{1,2\}^{T}$ auf. Es gilt
        <span class="nowrap">$T \in O(|t(x)|)$,</span>
        da $M$ ja Laufzeit $t$ hat. Wenn wir nun der
        Maschine $M'$ das Wort $z$ auf ihr zweites Band schreiben, dann
        wird sie genau die Konfigurationsfolge von $M$ reproduzieren und
        zu
        <code>accept</code>
        gelangen. Also
        <span class="nowrap">$x \in L(M')$.</span><span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p class="main-column">
      Im obigen Beweis nehmen wir stillschweigend ann, dass $\Sigma$
      mindestens zwei Zeichen enthält (die wir als $1$ und $2$ verwenden
      können). Wenn nun $|\Sigma| = 1$ wäre, dann müssten wir unserer
      Zertifikatmaschine erlauben, auf Band 2 ein separates
      <i>Zertifikatalphabet</i>
      zu verwenden; ansonsten würde die Simulation
      nicht funktionieren.
    </p>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 9.3.2</b>
        Sei $M$ eine Zertifikatmaschine und $\Sigma$ ein unäres
        Alphabet, also
        <span class="nowrap">$|\Sigma|=1$.</span>
        Wir nehmen an, dass $M$
        <i>kein</i>
        separates Zertifikatalphabet hat. Zeigen Sie: wenn $M$ die
        Sprache $L$ in Zeit $t(n)$ entscheidet, dann gibt es eine
        <i>deterministische</i>
        Turingmaschine, die $L$ in Zeit $t^2(n)$
        entscheidet.
      </p>
    </div>
    <h3 class="main-column subtopic-announcement">
      NP als Klasse der Probleme mit effizienten Zertifikaten
    </h3>
    <p class="main-column">
      Nach Definition ist eine Sprache $L$ ist in NP, wenn es eine
      nichtdeterministische Turingmaschine mit polynomieller Laufzeit
      $t(n) = n^k$ gibt, die $L$ entscheidet. Nach
      <span
        data-ref="theorem-certificate-simulates-nondet"
        class="reference"
      ></span>also, wenn es eine Zertifikatmaschine $M$ gibt, die $L$ in Zeit $t$
      entscheidet. Wenn also
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      x \in L \Longleftrightarrow \exists z \in \Sigma^*: M(x,z) = \texttt{accept}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Da $M$ nur $T = |x|^k$ Schritte tätigt, können wir annehmen, dass
      $|z| \leq T$ ist. Weiterhin können wir $x,z$ als
      <i>ein</i>
      Wort mit
      dem Trennzeichen "," auffassen. $M$ wird somit zu einer
      handelsüblichen deterministischen Turingmaschine, die die Sprache
      $\{x,z \ | \ M(x,z) = \texttt{accept}\}$ entscheidet und auch
      Laufzeit $t$ hat. Somit können wir die Sprache NP wie folgt
      charakterisieren:
    </p>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>9.3.6</b>
        Eine Sprache $L$ ist genau dann in NP, wenn es ein $k \in \N$
        und eine Sprache $L' \in \textnormal{P}$ gibt mit
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        x \in L \Longleftrightarrow \exists z \in \Sigma^*: |z| \leq |x|^k \textnormal{ und } (x,z) \in
        L'
        \end{align*}
        $$
      </div>
    </div>
    <div id="end-of-page-elt">
    </div>
    <div id="bottom-menu">
      <div id="bottom-menu-left">
        <a href="./9-2.html">&lt;&lt; Kapitel 9.2<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >Turing-Maschinen zu Schaltkreisen!</span></a>
      </div>
      <div id="bottom-menu-right">
        <a href="./9-4.html">Kapitel 9.4 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >Viele Beispiele aus NP</span></a>
      </div>
    </div>
  </div>
</body>
</html>
