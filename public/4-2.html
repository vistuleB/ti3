<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 4.2 of TI-2 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <link rel="icon" type="image/x-icon" href="./img/favicon.svg">
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <script type="text/javascript" src="./group.js"></script>
  <title>TI2—Kapitel 4.2</title>
</head>
<body>
  <div id="body-wrapper">
    <div id="top-menu">
      <div id="top-menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./4-1.html"
        >&lt;&lt; Kapitel 4.1<span
            style="visibility:hidden"
            id="top-prev-page-tooltip"
          >Primitive Rekursion: Motivation und Definitionen</span></a>
      </div>
      <div id="top-menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./4-3.html"
        >Kapitel 4.3 &gt;&gt;<span
            style="visibility:hidden"
            id="top-next-page-tooltip"
          >Primitive Rekursion kann nicht alles: die Péter-Ackermann-Funktion</span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        4.2&ensp;Primitive Rekursion: Konstruktionen und Tricks
      </p>
    </div>
    <p class="main-column">
      Ich beginne dieses Teilkapitel, manche der
      primitiv-rekursive Implementierungen in
      <a href="code/primitive-recursion/stockpile.py"><span class="codelink">stockpile.py</span></a>
      zu erklären und werde dann weitere, weniger
      offensichtliche Konstruktionen diskutieren.
    </p>
    <h2 class="main-column topic-announcement">
      Arithmetische Operationen
    </h2>
    <p class="main-column">
      Wir haben bereits gesehen, dass wir die Addition per
      ${\rm add} = \primrec (\pi_0, \comp(\succ, \pi_0))$
      schreiben können. Beachten Sie, dass ich hier die
      Indizierung immer bei 0 beginnen lasse, im Python-Code
      sowie im Mathematik-Modus (in der Vorlesung hatte ich
      an der Tafel das oft bei 1 beginnen lassen,
      entschuldigen Sie die Inkonsistenz). Multiplikation
      geht nach dem gleichen Schema. Wir schreiben
      <code>mult</code>
      in
      der Schleifenform, wie sie die primitive Rekursion
      zulässt, und schreiben in Orange auch gleich die
      Funktionen $g$ und $h$ dazu:
    </p>
    <div class="main-column">
<pre class="blue orange-comments">
def mult(t,x):
    temp = 0 <span class="actual-orange-comment">= zero(x)</span>
    for i in range(t):
        temp = add(temp,x) <span class="actual-orange-comment">= Comp(add, p_0, p2) (temp,i,x)</span>
    return temp
</pre>
    </div>
    <p class="main-column">
      erinnern Sie sich daran: $h$ muss immer eine Funktion
      in der lokalen Variable temp, der Laufvariable $i$
      und $\vec{x}$ sein. Daher:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm mult} = \primrec(\zero, \comp({\rm add}, \pi_0, \pi_2))
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Genauso erhalten wir
      <span class="nowrap">$x^t$,</span>
      indem wir statt bei 0 bei
      1 beginnen und statt $x$ draufzuzählen, es
      draufmultiplizieren:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm expReverse} = \primrec({\rm one}, \comp({\rm mult}, \pi_0, \pi_2))
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Allerdings gibt uns das
      <span class="nowrap">$(t,x) \mapsto x^t$.</span>
      Für
      ${\rm exp}(a,b) = a^b$ müssen wir die Argumente
      umdrehen:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm exp} = \comp({\rm expReverse}, \pi_1, \pi_0)
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Die Fakultätsfunktion $t!$ ist konzeptuell ähnlich,
      allerdings etwas interessanter, weil wir hier auf das
      Zwischenergebnis und die Laufvariable zugreifen
      müssen:
    </p>
    <div class="main-column">
<pre class="orange-comments">
def factorial(t):
    temp = 1 <span class="actual-orange-comment">= one()</span>
for i in range(t):
    temp = mult(temp,i+1) <span class="actual-orange-comment">= Comp(mult, p_0, Comp(succ, p_1)) (temp,i)</span>
    return temp
</pre>
    </div>
    <p class="main-column">
      Wir können nicht einfach $i+1$ schreiben! Wir müssen
      dies via $\comp(\succ,\pi_1)$ konstruieren. Denn: die
      Funktion $h$ bekommt ${\rm temp}, i, \vec{x}$ als
      Input; $\pi_1$ gibt uns davon das $i$ zurück und
      $\comp(\succ, \pi_1)$ gibt uns
      <span class="nowrap">$i+1$.</span>
      Operationen wie
      $\pred: t \mapsto t-1$ und ${\rm minus}$ sind
      konzeptuell nur ein bisschen anders. Das liegt auch
      daran, dass wir keine negativen Zahlen haben. Was ist
      <span class="nowrap">$\pred(0)$?</span>
      Wir definieren das als 0. So können wir
      pred implementieren:
    </p>
    <div class="main-column">
<pre class="orange-comments">
def pred(t):
    temp = 0 <span class="actual-orange-comment">= zero()</span>
    for i in range(t):
        temp = i <span class="actual-orange-comment">= p1 (temp,i)</span>
    return temp
</pre>
    </div>
    <p class="main-column">
      In Worten: wenn
      <span class="nowrap">$t=0$,</span>
      dann geben wir einfach
      $\zero()$ zurück, also
      <span class="nowrap">$0$.</span>
      Ansonsten durchlaufen wir
      die Schleife $t$ mal; der letzte Schleifenindex ist
      <span class="nowrap">$t-1$,</span>
      und das ist dann auch der Wert von temp, der
      zurückgegeben wird. Daher:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \pred = \primrec(\zero, \pi_1)
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Für minus schreiben wir uns erst mal
      <span class="nowrap">${\rm subtractFrom}: (t,x) \mapsto x-t$.</span>
      Hierfür
      wenden wir einfach pred $t$ mal auf $x$ an:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm subtractFrom}&amp;= \primrec(\pi_0, \comp(\pred, \pi_0)) \\
      {\rm minus}&amp;= \comp({\rm subtractFrom}, \pi_1, \pi_0)
      \end{align*}
      $$
    </div>
    <h2 class="main-column topic-announcement">
      Boolesche Werte
    </h2>
    <p class="main-column">
      Die primitive Rekursion stellt uns als "Datentyp" nur
      die natürlichen Zahlen zur Verfügung. Alles andere
      müssen wir als natürliche Zahlen nach einem von uns
      selbst gewählten Schema codieren. Für Boolesche Werte
      ist das recht naheliegend. Wir codieren
      <code>True</code>
      als 1
      und
      <code>False</code>
      als 0. Unser erstes Prädikat, also
      Funktion mit Booleschem Ausgabewert, ist
      <span class="nowrap"><code>isPositive</code>:</span>
    </p>
    <div class="main-column">
<pre class="orange-comments">
def pred(t):
    temp = 0 <span class="actual-orange-comment">= zero()</span>
    for i in range(t):
        temp = 1 <span class="actual-orange-comment">= one</span>
    return temp
</pre>
    </div>
    <p class="main-column">
      und somit
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm isPositive} = \primrec(\zero, {\rm one})
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Auf ähnliche Weise können wir uns nun lessThan,
      lessEqual, and, or, not, ifThenElse konstruieren.
    </p>
    <h2 class="main-column topic-announcement">
      Wurzel und Suchen im Allgemeinen
    </h2>
    <p class="main-column">
      Eine größere Herausforderung stellt die ganzzahlige
      Wurzel $x \mapsto \floor{\sqrt{x}}$ dar. Hierfür
      haben wir keine Formel mit
      <span class="nowrap">$+, *, -$,</span>
      auch keine
      schöne rekursive Formel zur Hand. Es handelt sich um
      ein Suchproblem: $\floor{\sqrt{x}}$ ist die größte
      natürliche Zahl $i$ mit
      <span class="nowrap">$i^2 \leq x$.</span>
      Wir können auch
      den Suchraum begrenzen: da $\sqrt{x} \leq x$ für alle
      natürlichen Zahlen, so gilt: $\floor{\sqrt{x}}$ ist
      die größte natürliche Zahl $i \in \{0,1,\dots,x\}$
      mit
      <span class="nowrap">$i^2 \leq x$.</span>
      Das Prädikat
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm iSquareLessEqualX } (i,x)&amp;= [ i^2 \leq x ]
      \end{align*}
      $$
    </div>
    <p class="main-column">
      ist primitiv rekursiv:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm iSquareLessEqualX } = \comp({\rm lessEqual}, \comp({\rm mult}, \pi_0, \pi_0), \pi_1)
      \end{align*}
      $$
    </div>
    <p class="main-column">
      und damit können wir die ganzzahlige Wurzel schreiben
      als
    </p>
    <div class="main-column">
<pre class="orange-comments">
def largestIbelowTwithISquareLessEqualX(t,x):
    temp = 0 <span class="actual-orange-comment">= zero(x)</span>
    for i in range(t):
        temp = ifThenElse(iSquareLessEqualX(i,x), i, temp) <span class="actual-orange-comment">= Comp(ifThenElse, Comp(iSquareLessEqual, p_1, p_2), p_1, p_0) (temp,i,x)</span>
    return temp
</pre>
    </div>
    <p class="main-column">
      Was geht hier vor? Wenn
      ${\rm iSquareLessEqualX}(i,x))$ True ist, dann
      ersetzen wir temp durch
      <span class="nowrap">$i$.</span>
      Ansonsten belassen wir
      es beim alten Wert; der endgültige Wert von temp ist
      also das letzte
      <span class="nowrap">$i$,</span>
      für das das Prädikat True wahr.
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm largestIbelowTwithISquareLessEqualX = \primrec(zero,
      \comp(ifThenElse, \comp(iSquareLessEqual, \pi_1, \pi_2), \pi_1, \pi_0))}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Und schließlich ist
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm sqrt} = \comp({\rm largestIbelowTwithISquareLessEqualX}, \pi_0, \pi_0)
      \end{align*}
      $$
    </div>
    <p class="main-column">
      da wir zum Suchen der Wurzel von $t$ gleich $t$ als
      Obergrenze des Suchraumes angeben können. Ganz
      allgemein können wir für ein Prädikat
      ${\rm predicate}(i,x)$ das größte
      $i \in \{0,\dots,t\}$ finden, für das
      ${\rm predicate}(i,x)$ True ergibt. Da wir wissen,
      wie wir das primitiv rekursiv machen können, erlauben
      wir uns, einen neuen Kombinator zu definieren, anstatt
      diese Konstruktion jedes Mal "von Hand" durchzuführen:
    </p>
    <div class="main-column">
<pre>
def LargestLessThan(upperBound, predicate):
        def new_function(*x):
                temp = 0
                for i in range(upperBound(*x)):
                        if (predicate(i,*x)):
                                temp = i
                return temp
        return new_function
</pre>
    </div>
    <p class="main-column">
      und somit können wir sqrt schreiben als
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm sqrt} = {\rm LargestLessThan} (\pi_0, {\rm iSquareLessEqual})
      \end{align*}
      $$
    </div>
    <h2 class="main-column topic-announcement">
      Paare und Listen
    </h2>
    <p class="main-column">
      Eine recht stark anmutende Beschränkung primitiv
      rekursiver Funktionen ist die Tatsache, dass wir in
      der Schleife nur
      <i>eine</i>
      lokale Variable führen dürfen,
      hier meistens
      <code>temp</code>
      genannt. Manche Funktionen
      scheinen inhärent mindestens zwei zu benötigen.
      Betrachten wir den Fall der Fibonacci-Zahlen:
    </p>
    <div class="main-column">
<pre>
def fibIterative(t):
    a = 0
    b = 1
    for i in range(t):
        c = a+b
        a = b
        b = c
    return a
</pre>
    </div>
    <p class="main-column">
      Wir führen hier zwei lokale Variable, $a$ und
      <span class="nowrap">$b$.</span>
      Das $c$ könnten wir mit diesem schönen Trick
      eliminieren:
    </p>
    <div class="main-column">
<pre>
b = a+b
a = b-a
</pre>
    </div>
    <p class="main-column">
      Doch selbst dann hätten wir immer noch zwei lokale
      Variable. Die Fibonacci-Zahlen rekursiv per
      <code>return
        F(n-1)+F(n-2)</code>
      scheint noch weiter weg zu sein vom
      Paradigma der primitiven Rekursion; primitive
      Rekursion verzweigt sich nie. Dennoch ist es möglich,
      <code>fib</code>
      primitiv rekursiv zu implementieren. Hauptzutat
      hierbei ist es, dass wir
      <i>Paare</i>
      als neue
      Datenstruktur verwenden. Erinnern Sie sich: die
      primitive Rekursion stellt uns als Datentyp von Haus
      aus nur die natürlichen Zahlen zur Verfügung. Alles
      andere müssen wir nach einem selbst gewählten Schema
      codieren. Bei Booleschen Werten war es einfach. Wie
      steht es mit
      <i>Paaren</i>
      von natürlichen Zahlen? In
      <a href="./3-0.html">Kapitel 2: Unendliche Mengen</a>
      haben
      wir die bijektive Funktion
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \pair : \N^2&amp;\rightarrow \N \\
      (x,y)&amp;\mapsto {x + y + 1 \choose 2} + x
      \end{align*}
      $$
    </div>
    <p class="main-column">
      kennengelernt. Diese Funktion ist primitiv rekursiv:
      es gilt ${n \choose 2} = 1 + 2 + \cdots + (n-1)$ und
      somit
    </p>
    <div class="main-column">
<pre class="orange-comments">
def choose2(t):
    temp = 0 <span class="actual-orange-comment">= zero()</span>
    for i in range(t):
        temp = add(temp,i) <span class="actual-orange-comment">= Comp(add, p0, p1)</span>
</pre>
    </div>
    <p class="main-column">
      und somit
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm choose2}&amp;= \primrec(\zero, \comp({\rm add},\pi_0,\pi_1)) \\
      \pair&amp;= \comp({\rm add}, \comp({\rm choose2}, \comp({\rm add}, \pi_0, \comp(\succ, \pi_1)), \pi_0)
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Um die Umkehrfunktionen $\first, \second$ zu
      implementieren, die uns aus $\pair(x,y)$ wieder $x$
      und $y$ berechnen, bestimmen wir erst den Wert von
      <span class="nowrap">$x+y$.</span>
      Wenn $\pair(x,y) = n$ gilt und $x+y=i)$ ist,
      dann ist
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      n = \pair(x,y) = {i + 1 \choose 2} + x \geq
      {i+1 \choose 2} + 0 = \pair(0,i) \ ,
      \end{align*}
      $$
    </div>
    <p class="main-column">
      und somit ist $x+y$ der größte Wert von
      <span class="nowrap">$i$,</span>
      so dass
      $n \geq \pair(0,i)$ ist. Aus $x+y$ und
      ${x+y+1 \choose 2} + x$ können wir dann leicht $x$
      und $y$ berechnen:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm getXplusY}&amp;= {\rm LargestLessThan}(\pi_0, \comp({\rm greaterEqual}, \pi_1, \comp(\pair,
      \zero, \pi_0)))\\
      \first&amp;= \comp({\rm minus}, \pi_0, \comp(\pair, \zero, {\rm getXplusY}))\\
      \second&amp;= \comp({\rm minus}, {\rm getXplusY}, \first)
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Listen können wir implementieren, indem wir Paare
      verschachtelt zusammenhängen, z.B. $[5,7,9]$ wird zu
      <span style="color:red">$\pair(5, \pair(7, 9))$</span>. Das ist natürlich inkorrekt:
    </p>
    <div class="main-column">
<pre class="python-prompt">
<span class="python-prompt-carets">&gt;&gt;&gt;</span><span class="python-prompt-content"> pair(5,pair(7,9))</span>
<span class="python-prompt-ok-response">11031</span>
<span class="python-prompt-carets">&gt;&gt;&gt;</span><span class="python-prompt-content"> pair(7,9)</span>
<span class="python-prompt-ok-response">143</span>
<span class="python-prompt-carets">&gt;&gt;&gt;</span><span class="python-prompt-content"> pair(5,143)</span>
<span class="python-prompt-ok-response">11031</span>
</pre>
    </div>
    <p class="main-column">
      Das Problem ist, dass wir das Ende der Liste nicht
      kennen. Wir lösen das Problem, indem wir die leere
      Liste mit $0$ codieren und dann aber beim Davorhängen
      eines Elements 1 draufaddieren müssen, also
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      {\rm push} (x, {\rm restlist})&amp;= 1 + \pair(x, {\rm restlist}) \\
      {\rm head} ({\rm list})&amp;= \first({\rm list} - 1)\\
      {\rm second} ({\rm list})&amp;= \second({\rm list} - 1)
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Jetzt klappt alles wunderbar:
    </p>
    <div class="main-column">
<pre class="python-prompt">
<span class="python-prompt-carets">&gt;&gt;&gt;</span><span class="python-prompt-content"> push(11, push(7, push(5, 0)))</span>
<span class="python-prompt-ok-response">90537</span>
<span class="python-prompt-carets">&gt;&gt;&gt;</span><span class="python-prompt-content"> head(90537)</span>
<span class="python-prompt-ok-response">11</span>
<span class="python-prompt-carets">&gt;&gt;&gt;</span><span class="python-prompt-content"> head(tail(90537))</span>
<span class="python-prompt-ok-response">7</span>
<span class="python-prompt-carets">&gt;&gt;&gt;</span><span class="python-prompt-content"> head(tail(tail(90537)))</span>
<span class="python-prompt-ok-response">5</span>
</pre>
    </div>
    <p class="main-column">
      <b>Native Implementierung.</b>
      Die primitive Rekursion ist
      ein theoretischer Berechenbarkeitsbegriff für
      Funktionen auf natürlichen Zahlen. Es ist definitiv
      keine ernstzunehmende Programmiersprache. Ich finde
      allerdings, dass es hilfreich ist, sie als
      Programmiersprache zu begreifen und zu verwenden, rein
      experimentell. Leider ist sie extrem ineffizient:
      selbst Subtraktion hat quadratische Komplexität.
      Längere Listen wie die gerade werden Sie in
      vertretbarer Zeit nicht behandeln können. Bei meinen
      eigenen Experimenten mit meinem Python-Framework bin
      ich daher dazu übergegangen, dass ich, sobald ich
      gezeigt habe, dass eine Funktion $f$ primitiv
      rekursiv ist, sie
      <i>nativ</i>
      in Python zu implementieren,
      also beispielsweise in meiner Datei
      <span class="nowrap"><code>stockpile.py</code>:</span>
    </p>
    <div class="main-column">
<pre language="class=listing">
def pair(x,y):
    return int(((x+y+1) * (x+y)) / 2 + x )
</pre>
    </div>
    <div id="end-of-page-elt">
    </div>
    <hr id="bottom-menu-hr">
    <div id="bottom-menu">
      <div id="bottom-menu-left">
        <a href="./4-1.html">&lt;&lt; Kapitel 4.1<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >Primitive Rekursion: Motivation und Definitionen</span></a>
      </div>
      <div id="bottom-menu-right">
        <a href="./4-3.html">Kapitel 4.3 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >Primitive Rekursion kann nicht alles: die Péter-Ackermann-Funktion</span></a>
      </div>
    </div>
  </div>
</body>
</html>
