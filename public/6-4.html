<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 6.4 of TI-2 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <link rel="icon" type="image/x-icon" href="./img/favicon.svg">
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI2—Kapitel 6.4</title>
</head>
<body>
  <div id="body-wrapper">
    <div id="top-menu">
      <div id="top-menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./6-3.html"
        >&lt;&lt; Kapitel 6.3<span
            style="visibility:hidden"
            id="top-prev-page-tooltip"
          >Rechnerübung: Gute kontextfreie Grammatiken entwerfen</span></a>
      </div>
      <div id="top-menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./6-5.html"
        >Kapitel 6.5 &gt;&gt;<span
            style="visibility:hidden"
            id="top-next-page-tooltip"
          >LR-Parser per Hand entwerfen</span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        <span class="nowrap">6.4&ensp;LL($k$)-Grammatiken</span>
        (nicht im Sommersemester 2025)
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Definition 6.4.1 Grenzform</b>
        Sei $G = (\Sigma, N, S, P)$ eine
        kontextfreie Grammatik. Eine Wortform $A \alpha$ -
        also eine Wortform, die mit einem Nichtterminal
        beginnt - heißt
        <span class="nowrap"><i>Grenzform</i>,</span>
        wenn es ein
        $w \in \Sigma^*$ gibt, so dass es eine Linksableitung
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S \Step{}^* w A \alpha
        \end{align*}
        $$
      </div>
      <p>
        gibt. In anderen Worten: eine Grenzform ist das, was
        bei einem Kellerautomaten auf dem Stack liegt, wenn
        ein Nichtterminal ganz oben liegt.
      </p>
    </div>
    <p class="main-column">
      Grenzformen sind also diejenigen Wortformen, bei
      denen der Kellerautomat eine Entscheidung treffen
      muss, weil er eventuell mehrere Produktionen
      $A \rightarrow \beta$ zur Auswahl hat. In diesem
      Teilkapitel wollen wir herausarbeiten, unter welchen
      Umständen wir die richtige Auswahl treffen können,
      auch wenn wir nur wenige weitere Zeichen unseres
      Inputwortes lesen dürfen.
    </p>
    <div class="well statement out">
      <p>
        <b>Definition 6.4.2</b>
        Für ein Wort $w \in \Sigma^*$ und eine natürliche
        Zahl $k \in \N$ sei $\first_k(w)$ wie folgt
        definiert:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \first_k(w) := \begin{cases}
        w&amp;\textnormal{ wenn $|w| \lt k$} \\
        u&amp;\textnormal{ wenn $w = uv$ und $|u| = k$}
        \end{cases}
        \end{align*}
        $$
      </div>
      <p>
        In Worten: $\first_{k}(w)$ besteht aus den ersten $k$
        Zeichen von $w$ (oder aus ganz
        <span class="nowrap">$w$,</span>
        falls es weniger
        als $k$ lang ist).
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Definition 6.4.3
          <span class="nowrap">LL($k$)-Grammatiken</span></b>
        Eine kontextfreie Grammatik
        $G = (\Sigma, N, S, P)$ ist eine
        <span class="nowrap">LL($k$</span>
        )-Grammatik,
        wenn für jede Grenzform $A \alpha$ und für jedes Paar
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        A&amp;\step{1} \beta \\
        A&amp;\step{2} \gamma
        \end{align*}
        $$
      </div>
      <p>
        verschiedener Produktionen (also
        <span class="nowrap">$\beta \ne \gamma$)</span>
        folgendes gilt: wenn
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        A\alpha&amp;\Step{1} \beta \alpha \Step{}^* x \\
        A\alpha&amp;\Step{2} \gamma \alpha \Step{}^* y \\
        \end{align*}
        $$
      </div>
      <p>
        dann müssen sich $x$ und $y$ in den ersten $k$
        Zeichen unterscheiden, also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \first_k(x) \ne \first_k(y) \ .
        \end{align*}
        $$
      </div>
    </div>
    <p class="main-column">
      Intuitiv gesprochen: wenn wir bereits eine ersten
      Teil $w$ unseres Zielwortes abgeleitet haben, dann
      können wir die nächste anzuwendende Produktion
      eindeutig bestimmen, indem wir die nächsten $k$
      Zeichen des Zielwortes lesen.
    </p>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 6.4.1</b>
        Negieren Sie die Definition, d.h., schreiben Sie eine
        Aussage der Form
        <i>Wenn $G$ nicht
          <span class="nowrap">LL($k$)</span>
          ist, dann
          gibt es...</i>
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Beispiel 6.4.4</b>
        Die Klammern-Grammatik
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\step{1} \epsilon \\
        S&amp;\step{2} (S)S
        \end{align*}
        $$
      </div>
      <p>
        ist LL(1).
      </p>
      <div class="well highlight">
        <p>
          <b>Beweis.</b>
          Folgen wir der Definition von LL(1): für jedes Paar
          verschiedener Regeln muss etwas gelten. Wir haben hier
          keine Auswahl, denn es gibt ja nur ein Paar. Also
          müssen wir zeigen, dass, falls
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          S \Step{}^* wS\alpha&amp;\Step{1} w \alpha \Step{}^* w x \\
          S \Step{}^* wS\alpha&amp;\Step{2} w \texttt{(}S\texttt{)}S \alpha \Step{}^* w y \\
          \end{align*}
          $$
        </div>
        <p>
          gilt, dann auch $\first_1(x) \ne \first_2(y)$ gilt.
          Offensichtlich ist $\first_2(y) =$ "
          <span class="nowrap">$\texttt{(}$".</span>
          Was kann $\first_k(x)$ sein?
        </p>
        <p>
          <b>Behauptung.</b>
          Wenn
          <span class="nowrap">$S \rightarrow \delta \in (\Sigma \cup N)^*$,</span>
          dann
          steht jedes $S$ in $\delta$ entweder am Ende von
          $\delta$ oder unmittelbar vor einem "
          <span class="nowrap">$\texttt{)}$".</span>
          Das folgt per Induktion über die Länge der Ableitung.
          Wenn es also für $\delta$ gilt und wir die Produktion
          $S \rightarrow (S)S$ auf $\delta$ anwenden, dann gilt
          es für jedes "alte" $S$ und auch für die beiden neu
          erzeugten; wenn wir $S \rightarrow \epsilon$
          anwenden, dann verschwindet ein
          <span class="nowrap">$S$,</span>
          die Behauptung
          gilt aber nach wie vor für alle anderen $S$ in
          <span class="nowrap">$\delta$.</span><span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>Wir folgern also, dass für das $\alpha$ den beiden
          obigne Herleitungen
          $\first_k(\alpha) \in \{\epsilon, \texttt{)}\}$ gilt.
          Keines davon ist ein Nichtterminal, und so muss auch
          $\first_k(\alpha) = \first_k(x)$ gelten.
          Zusammenfassend gesagt:
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          \first_k(x)&amp;\in \{\epsilon, \texttt{)}\} \\
          \first_y(y)&amp;= \texttt{(} \ ,
          \end{align*}
          $$
        </div>
        <p>
          und somit sind sie verschieden. Wir folgern, dass $G$
          eine LL(1)-Grammatik ist.
        </p>
      </div>
    </div>
    <p class="main-column">
      Sehen Sie, dass die
      <span class="nowrap">LL($k$)-Bedingung</span>
      der Aussage
      "der Backtrack-Baum hat keine langen Sackgassen"
      ähnelt (aber nicht völlig äquivalent dazu ist). Wenn
      $G$ eine LL(
      <span class="nowrap">$k$)-Grammatik</span>
      ist und wir den
      Backtrack-Baum für ein Wort bauen, dann gilt: sobald
      wir in einer Sackgasse $k$ neue Terminalsymbole am
      "Terminalpräfix" der Wortform hergeleitet haben,
      merken wir, dass wir in einer Sackgasse sind. Mit
      Terminalpräfix meine ich den längsten Präfix einer
      Wortform, der ausschließlich aus Terminalen besteht.
      Allerdings muss nicht jeder Ableitungsschritt den
      Terminalpräfix wachsen lassen (Regeln wie
      $X \rightarrow YbZ$ zum Beispiel ersetzen einfach das
      erste Nichtterminal), aber "moralisch" geschieht etwas
      ähnliches). Wenn umgekehrt eine Grammatik
      <i>nicht</i>
      LL(
      <span class="nowrap">$k$)</span>
      ist, dann muss der Backtrack-Baum beiden
      Ableitungen
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      w A \alpha&amp;\Rightarrow w \beta \alpha \\
      w A \alpha&amp;\Rightarrow w \gamma \alpha \\
      \end{align*}
      $$
    </div>
    <p class="main-column">
      mindestens so lange weiterverfolgen, bis der
      Terminalpräfix $k$ weitere Zeichen dazugewonnen hat.
      Der Baum bekommt also dementsprechend lange
      Sackgassen.
    </p>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 6.4.2</b>
        (Beispiel 5.3 aus
        <i>The Theory of Parsing,
          Translation, and Compiling</i>
        von Alfred V. Aho und
        Jeffrey D. Ullman). Betrachten wir die Grammatik
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\step{1} \epsilon \\
        S&amp;\step{2} ab A \\
        A&amp;\step{3} Saa \\
        A&amp;\step{4} b
        \end{align*}
        $$
      </div>
      <p>
        Zeigen Sie, dass diese Grammatik LL(2) ist, aber
        nicht LL(1).
        <b>Tip.</b>
        Leiten Sie erst einmal ein Dutzend
        verschiedene Wörter ab und finden dann eine
        "normalsprachliche" Beschreibung dieser Sprache.
        Beschreiben Sie dann alle möglichen Wortformen
        $\alpha$ mit
        <span class="nowrap">$S \Step{}^* \alpha$.</span>
      </p>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 6.4.3</b>
        Schreiben Sie eine äquivalente Grammatik zu der
        vorherigen Sprache, die LL(1) ist. (Warnung: Ich weiß
        nicht, ob das überhaupt geht).
      </p>
    </div>
    <div
      id="_27_hgi_"
      class="well exercise out"
    >
      <p>
        <b>Übungsaufgabe 6.4.4</b>
        Betrachten wir die Grammatik
        <span class="nowrap">$G$:</span>
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\step{1} a S b \\
        S&amp;\step{2} a S \\
        S&amp;\step{3} \epsilon
        \end{align*}
        $$
      </div>
      <p>
        Sie erzeugt die Sprache
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        L(G) := \{ a^{m+k} b^m \ | \ m, k \in \N \} \ ,
        \end{align*}
        $$
      </div>
      <p>
        also Wörter, wo auf beliebig viele
        <span class="nowrap">$a$'s</span>
        eine Folge
        von
        <i>höchstens</i>
        so vielen
        <span class="nowrap">$b$'s</span>
        folgt. Geben Sie
        diese Grammatik in den
        <a href="href=https://www.tu-chemnitz.de/informatik/theoretische-informatik/demos/drawManualGrammar.html">Parser-Simulator</a>
        ein und finden Wörter mit langen Sackgassen. Zeigen
        Sie, dass diese Grammatik nicht
        <span class="nowrap">LL$(k)$</span>
        ist, für kein
        <span class="nowrap">$k \in \N$.</span>
      </p>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 6.4.5</b>
        Sei $t \in \N$ eine feste, im Voraus bekannte Zahl.
        Betrachten wir die Sprache
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        L_t := \{a^{m + l} b^m \ | \ m \geq 0, l \leq t\} \ ,
        \end{align*}
        $$
      </div>
      <p>
        also die Wörter der Form $a^m b^n$ mit
        <span class="nowrap">$n \leq m \leq n+t$.</span>
        Schreiben Sie für $L_3$ eine
        Grammatik, geben Sie diese im
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/demos/drawManualGrammar.html">Parser-Simulator</a>
        ein und schauen, wie lang die Sackgassen werden
        können. Zeigen Sie, dass $L_3$ eine
        <span class="nowrap">LL$(k)$</span>
        -Grammatik ist. Für welchen Wert von
        <span class="nowrap">$k$?</span>
        Ist $L_t$
        (für im Voraus bekanntes $t$ ) eine
        <span class="nowrap">LL$(k)$</span>
        -Grammatik? Für welchen Wert von
        <span class="nowrap">$k$?</span>
      </p>
    </div>
    <h2 class="main-column topic-announcement">
      <span class="nowrap">LL$(k)$-Grammatiken</span>
      parsen
    </h2>
    <p class="main-column">
      Wir wollen nun erarbeiten, wie wir für eine LL $(k)$
      -Grammatik einen Parser, also im Prinzip einen
      deterministischen Pushdown-Automaten schreiben können.
      Wir tasten uns langsam voran. Wir beginnen mit einer
      Verallgemeinerung von $\first_k$ von Wörtern auf
      <i>Wortformen</i>
      (die also Nichtterminale beinhalten
      können).
    </p>
    <div class="well statement out">
      <p>
        <b>Definition 6.4.5</b>
        Sei eine kontextfreie Grammatik
        $G = (\Sigma, N, S, P)$ und eine Wortform
        $\alpha \in (\Sigma \cup N)^*$ gegeben. Wir
        definieren
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k(\alpha) := \{ \first_k(w) \ | \ w \in \Sigma^*, \alpha \Step{}^* w\}
        \end{align*}
        $$
      </div>
    </div>
    <p class="main-column">
      Wir können nun die
      <span class="nowrap">LL$(k)$-Bedingung</span>
      äquivalent
      formulieren:
    </p>
    <div class="well statement out">
      <p>
        <b>Definition / Beobachtung 6.4.6</b>
        Eine Grammatik $G$ ist
        <span class="nowrap">LL$(k)$</span>
        genau dann, wenn für
        alle Grenzformen $A \alpha$ und alle Produktionen mit
        $A$ auf der linken Seite, also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        A&amp;\rightarrow \beta_1 \\
        A&amp;\rightarrow \beta_2 \\
        &amp;\vdots\\
        A&amp;\rightarrow \beta_l
        \end{align*}
        $$
      </div>
      <p>
        die Mengen $\First(\beta_i \alpha)$ paarweise
        disjunkt sind (wenn also keine zwei dieser Mengen ein
        gemeinsames Element enthalten).
      </p>
    </div>
    <p class="main-column">
      Nehmen wir eine Momentaufnahme unseres
      Kellerautomaten. Er hat den Präfix $x$ des
      Eingabewortes $xy$ gelesen und eine Linksableitung
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      S \Rightarrow^*{} x \alpha
      \end{align*}
      $$
    </div>
    <p class="main-column">
      durchgeführt. Die Wortform $\alpha$ ist genau das,
      was im Moment auf dem Stack des Automaten liegt (um
      ganz genau zu sein: \(\alpha\texttt{\$}\) liegt auf
      dem Stack). Wenn $\alpha$ mit einem Terminalsymbol $c$
      beginnt, so ist klar, was wir machen müssen: wir
      schauen, ob $y$ mit $c$ beginnt. Wenn ja, lesen wir
      $c$ und poppen es vom Stack. Der schwierige Fall ist,
      wenn $\alpha$ mit einem Nichtterminal beginnt.
      Nochmal von vorn: im schwierigen Fall liegt auf dem
      Stack (oberhalb vom
      <span class="nowrap">\(\$\))</span>
      eine Wortform, die mit
      einem Nichtterminal beginnt, also
      <span class="nowrap">$A \alpha$.</span>
      Das
      bedeutet, dass der Automat per Linksableitung bis
      jetzt
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      S \Step{}^* x A \alpha
      \end{align*}
      $$
    </div>
    <p class="main-column">
      hergeleitet hat. Der Automat muss sich nun zwischen
      allen Regeln für $A$ entscheiden:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      A&amp;\rightarrow \beta_1 \\
      A&amp;\rightarrow \beta_2 \\
      &amp;\vdots\\
      A&amp;\rightarrow \beta_l \ .
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Der Automat betrachtet nun die nächsten $k$
      Eingabesymbole, also $\first_k(y)$ (wir gehen mal
      davon aus, dass er das kann; programmieren könnten wir
      das auf jeden Fall; ob man es im strengen Framework
      des Kellerautomaten hinkriegt, werden wir später
      sehen). Wenn $G$ eine
      <span class="nowrap">LL$(k)$-Grammatik</span>
      ist, dann
      gibt es höchstens eine Regel $A \rightarrow \beta_i$
      mit
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \first_k(y) \in \first_k(\beta_i \alpha)
      \end{align*}
      $$
    </div>
    <p class="main-column">
      da ja nach obiger Beobachtung diese Mengen disjunkt
      sind. Wenn $\first_k(y)$ in
      <i>keiner</i>
      dieser Mengen
      enthalten ist, so kann die Ableitung offensichtlich
      nicht vervollständigt werden, und wir schließen, dass
      $xy \not \in L(G)$ ist. Wenn es
      <i>genau ein</i>
      $\beta_i$
      gibt mit
      <span class="nowrap">$\first_k(y) \in \first_k(\beta_i \alpha)$,</span>
      dann ist $A \rightarrow \beta_i$ die "richtige"
      Produktion. Wir wenden sie an, ersetzen also $A$ auf
      dem Stack durch
      <span class="nowrap">$\beta_i$.</span>
      Falls es zwei oder mehr
      Produktionen $A \rightarrow \beta_i$ gibt mit
      <span class="nowrap">$\first_k(y) \in \first_k(\beta_i \alpha)$,</span>
      dann ist
      die Grammatik nicht
      <span class="nowrap">LL$(k)$;</span>
      wir beenden den
      Parsing-Prozess mit einer Laufzeitfehlermeldung. Hier
      ist ein Entwurf eines allgemeinen Algorithmus für LL
      <span class="nowrap">$(k)$-Grammatiken:</span>
    </p>
    <div class="well highlight out">
      <p>
        <b>Generischer Algorithmus zum Parsen von
          <span class="nowrap">LL$(k)$-Gramatiken</span></b>
      </p>
      <ol>
        <li>
          <p>
            Lege \(S\texttt{\$}\) auf den Stack.
          </p>
        </li>
        <li>
          <p>
            <code>while</code>
            Stack nicht leer:
          </p>
          <ol>
            <li>
              <p>
                Sei $y$ das Resteingabewort.
              </p>
            </li>
            <li>
              <p>
                Wenn das oberste Symbol auf dem Stack ein
                Terminalsymbol $c$ ist:
              </p>
              <ul>
                <li>
                  <p>
                    Lies das nächste Eingabesymbol
                    <span class="nowrap">$c'$.</span>
                  </p>
                </li>
                <li>
                  <p>
                    Wenn
                    <span class="nowrap">$c = c'$,</span>
                    poppe $c$ vom Stack;
                  </p>
                </li>
                <li>
                  <p>
                    ansonsten
                    <span class="nowrap"><code>Reject</code>.</span>
                  </p>
                </li>
              </ul>
            </li>
            <li>
              <p>
                Wenn das oberste Symbol auf dem Stack ein
                Nichtterminalsymbol $A$ ist:
              </p>
              <ol>
                <li>
                  <p>
                    Schreibe den Stack als $A \alpha$
                  </p>
                </li>
                <li>
                  <p>
                    Seien
                    $A \rightarrow \beta_1, \dots, A \rightarrow \beta_l$
                    alle Produktionen mit $A$ auf der linken Seite.
                  </p>
                </li>
                <li>
                  <p>
                    <span style="color:red; font-weight: bold;">Berechne $\First_k(\beta_i\alpha)$ für alle $\beta_i$
                      und schaue, welches $\first_k(y)$ enthält</span>
                  </p>
                  <ul>
                    <li>
                      <p>
                        Wenn es genau eine solche Produktion
                        $A \rightarrow \beta_i$ gibt: wende Sie an; es ist
                        die richtige Produktion.
                      </p>
                    </li>
                    <li>
                      <p>
                        Wenn es keine gibt:
                        <span class="nowrap"><code>Reject</code>.</span>
                        Das Wort kann nicht
                        abgeleitet werden.
                      </p>
                    </li>
                    <li>
                      <p>
                        Wenn es mehrere gibt: ende mit einem Laufzeitfehler;
                        die Grammatik ist nicht
                        <span class="nowrap">LL$(k)$.</span>
                      </p>
                    </li>
                  </ul>
                </li>
              </ol>
            </li>
            <li>
              <p>
                Wenn das oberste Symbol \(\texttt{\$}\) ist: wenn
                Eingabewort zu Ende
                <code>Accept</code>
                ansonsten
                <code>Reject</code>
              </p>
            </li>
          </ol>
        </li>
      </ol>
    </div>
    <p class="main-column">
      Die rot und fett gedruckte Zeile ist das "Herz"
      dieses Algorithmus. Um den Algorithmus implementieren
      zu können, müssen wir es schaffen, die Menge
      $\First_k(\beta_i\alpha)$ zu berechnen.
    </p>
    <h2 class="main-column topic-announcement">
      $\First_k(A)$ und $\First_k(\alpha)$ berechnen.
    </h2>
    <div class="well statement out">
      <p>
        <b>Definition 6.4.7</b>
        Seien $K, L \subseteq \Sigma^*$ zwei Mengen. Mit
        $K \circ L$ bezeichnen wir die Menge
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        K \circ L := \{xy \ | \ x \in K, y \in L\} \ .
        \end{align*}
        $$
      </div>
      <p>
        (Diese Definition haben Sie schon im Kapitel über
        reguläre Sprachen kennengelernt). Für eine natürliche
        Zahl $k$ definieren wir
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k(L) := \{\first_k(x) \ | \ x \in L\} \ .
        \end{align*}
        $$
      </div>
      <p>
        Weiterhin bezeichnen wir mit $K \circ_k L$ die Menge
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        K \circ_k L&amp;:= \First(K \circ L) \\
        &amp;= \{\first_k(xy) \ | \ x \in K, y \in L\} \ .
        \end{align*}
        $$
      </div>
    </div>
    <p class="main-column">
      Im Allgemeinen gilt
      <span class="nowrap">$\First_k(S_1 \circ \dots \circ S_l) = S_1 \circ_k
        S_2 \circ_k \dots \circ_k S_l$.</span>
      In Worten: der
      <span class="nowrap">$\circ_k$-Operator</span>
      bildet alle
      möglichen Kombinationen von Wörtern und nimmt von
      jedem die ersten $k$ Zeichen.
    </p>
    <div class="well statement out">
      <p>
        <b>Beispiel 6.4.8</b>
        Sei
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        K&amp;:= \{\epsilon, a, ab, aba\} \\
        L&amp;:= \{c, bb, b\}
        \end{align*}
        $$
      </div>
      <p>
        Dann ist
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        K \circ L = \{c, bb, b, ac, abb, ab, abc, abbb, abb, abac, ababb, abab\}
        \end{align*}
        $$
      </div>
      <p>
        und somit
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        K \circ_2 L&amp;= \{c, bb, b, ac, ab, ab, ab, ab, ab, ab, ab, ab\} \\
        &amp;=\{c, bb, b, ac, ab\}
        \end{align*}
        $$
      </div>
    </div>
    <div class="well statement out">
      <p>
        <b>Beobachtung 6.4.9 - wie man $\First_k(\alpha)$ berechnet.</b>
        Sei eine
        Wortform $\alpha$ gegeben, also
        <span class="nowrap">$\alpha \in (\Sigma \cup N)^*$.</span>
        Wir berechnen
        <span class="nowrap">$\First_k(\alpha)$,</span>
        indem wir als erstes $\alpha$
        aussschreiben als
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \alpha = (\sigma_1 \sigma_2 \sigma_3 \dots \sigma_n)
        \end{align*}
        $$
      </div>
      <p>
        wobei jedes $\sigma_i$ ein Terminalsymbol oder ein
        Nichtterminalsymbol ist, und berechnen dann
        $\First_k(\alpha)$ wie folgt:
      </p>
      <div class="math-block">
        $$
        \begin{align}
        \First_k(\alpha) = \First_k(\sigma_1) \circ_k \First_k(\sigma_2) \circ_k \dots \circ_k \First_k
        (\sigma_n) \ .
        \label{first-k-wortform}
        \end{align}
        $$
      </div>
      <p>
        Wir können dies schön der Reihe nach tun:
      </p>
      <ol>
        <li>
          <p>
            Initialisiere $K := \{\epsilon\}$
          </p>
        </li>
        <li>
          <p>
            <code>for</code>
            $i=n$
            <code>down to</code>
            1
            <code>do:</code>
          </p>
          <ul>
            <li>
              <p>
                $K := \First_k(\sigma_i) \circ_k K$<span class="comment">// $K$ ist jetzt
                  $\First_k(\sigma_i) \circ_k \dots \circ_k
                  \First_k(\sigma_n)$</span>
              </p>
            </li>
          </ul>
        </li>
        <li>
          <p>
            <code>return</code>
            $K$
          </p>
        </li>
      </ol>
      <p>
        Wir müssen nur noch herausfinden, wie wir
        $\First_k(\sigma)$ für einzelne Zeichen $\sigma$
        berechnen.
      </p>
    </div>
    <p class="main-column">
      Für ein Terminalsymbol $c$ ist es trivial,
      $\First_k(c)$ zu berechnen: es ist
      <span class="nowrap">$\{c\}$,</span>
      da sich
      aus $c$ natürlich nur das Wort $c$ ableiten lässt.
      Für Nichtterminale müssen wir uns anstrengen. Die
      erste Idee ist, dass wir für $\First_k(X)$ eine
      Gleichung schreiben können, die
      $(\ref{first-k-wortform})$ verwendet.
    </p>
    <div class="well statement out">
      <p>
        <b>Beobachtung 6.4.10</b>
        Sei $X$ ein Nichtterminal und
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        X&amp;\rightarrow \alpha_1 \\
        X&amp;\rightarrow \alpha_2 \\
        &amp;\vdots \\
        X&amp;\rightarrow \alpha_k
        \end{align*}
        $$
      </div>
      <p>
        die Produktionen der Grammatik mit $X$ auf der linken
        Seite. Dann gilt
      </p>
      <div class="math-block">
        $$
        \begin{align}
        \First_k(X) = \bigcup_{i=1}^k \First_k(\alpha_i)
        \label{first-k-nonterminal}
        \end{align}
        $$
      </div>
      <p>
        Was ja eigentlich offensichtlich ist: wenn sich ein
        Wort $X \Step{}^* w$ aus $X$ ableiten lässt, dann
        muss dies mittels einer der obigen Produktionen
        geschehen:
        <span class="nowrap">$X \Step{} \alpha_i \Step{}^* w$,</span>
        und
        somit gilt
        <span class="nowrap">$\first_k(w)\in \First_k(\alpha_i)$.</span>
      </p>
    </div>
    <p class="main-column">
      Die Gleichungen $(\ref{first-k-wortform})$ und
      $(\ref{first-k-nonterminal})$ leuchten zwar ein,
      scheinen aber erstmal nicht hilfreich, diese Mengen
      auch tatsächlich zu berechnen. Denn eventuell taucht
      $X$ selbst wieder auf einer rechten Seite auf, sagen
      wir
      <span class="nowrap">$\alpha_1$.</span>
      Um $\First_k(X)$ zu berechnen, müssen
      wir also laut $(\ref{first-k-nonterminal})$ die Menge
      $\First_k(\alpha_1)$ kennen; um diese zu berechnen,
      brauchen wir laut $(\ref{first-k-wortform})$
      allerdings zuerst unter Anderem die Menge
      <span class="nowrap">$\First_k(X)$.</span>
      Wo sollen wir also anfangen? In
      solchen Situationen, wo sich "die Katze in den Schwanz
      beißt", hilft es oft, die Definition vorerst
      <i>komplexere</i>
      un
      <i>genauer</i>
      zu machen. Wir führen nun,
      zusätzlich zu $\First_k(X)$ und
      <span class="nowrap">$\First_k(\alpha)$,</span>
      noch eine feinere Unterteilung an:
    </p>
    <div class="well statement out">
      <p>
        <b>Definition 6.4.11</b>
        Sei $\sigma$ ein Symbol und
        <span class="nowrap">$d \in \N$.</span>
        Dann ist
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k^{(d)}(\sigma) := \{\first_k(w) \ | \ \textnormal{ es gibt einen Ableitungsbaum für
        $\sigma \Step{}^* w$ der Höhe höchstens $d$}\}
        \end{align*}
        $$
      </div>
    </div>
    <div class="well statement out">
      <p>
        <b>Beispiel 6.4.12</b>
        Sei unsere Grammatik
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\rightarrow Xa \\
        X&amp;\rightarrow Sb \ | c
        \end{align*}
        $$
      </div>
      <p>
        Dann ist beispielsweise
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:8em"
            src="./img/context-free/LL/tree-depth-2.svg"
          >
        </figure>
      </div>
      <p>
        ein Ableitungsbaum der Höhe 2 von $S \Step{}^* ca$ ,
        und somit gilt
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        c \in \First_1^{(d)} (S) \ .
        \end{align*}
        $$
      </div>
      <p>
        Ein Baum der Höhe 1, der mit $S$ beginnt, könnte ja
        nur $Xa$ ableiten und somit gar kein Wort. Es gilt
        also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_1^{(1)} (S) = \emptyset \ .
        \end{align*}
        $$
      </div>
      <p>
        Für eine Wortform
        $\alpha = \sigma_1 \sigma_2 \dots \sigma_n \in
        (\Sigma \cup N)^*$
        definieren wir
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k^{(d)}(\alpha) = \First_k^{(d)}(\sigma_1) \circ_k \First_k^{(d)}(\sigma_2) \circ_k \dots
        \circ_k \First_k^{(d)}
        \end{align*}
        $$
      </div>
      <p>
        Eine Ableitung $\alpha \Step{}^* w$ der Höhe maximal
        $d$ entspricht also einer Folge von $n$
        Ableitungsbäumen, von denen jeder Höhe maximal $d$
        hat.
      </p>
    </div>
    <p class="main-column">
      Mit dieser Definition können wir nun Gleichungen für
      $\First_k^{(d)}(X)$ und $\First_k^{(d)}(\alpha)$
      angeben. Seien
      $X \rightarrow \alpha_1 \ | \ \dots \ | \ \alpha_k$
      die Produktionen mit $X$ auf der linken Seite. Dann
      gilt für
      <span class="nowrap">$k \geq 1$:</span>
    </p>
    <div class="well statement out">
      <p>
        <b>Lemma 6.4.13</b>
        Für $d \geq 1$ gilt
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k^{(d)}(X)&amp;= \bigcup_{i=1}^k \First_k^{(d-1)} (\alpha_i) \\
        \First_k^{(d)}(\alpha)&amp;= \First_k^{(d)}(\sigma_1) \circ_k \First_k^{(d)}(\sigma_2) \circ_k
        \dots \circ_k \First_k^{(d)}
        \end{align*}
        $$
      </div>
      <p>
        Für $d = 0$ gilt
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k^{(0)}(X)&amp;:= \emptyset \tag{für jedes Nichtterminal}
        \end{align*}
        $$
      </div>
      <p>
        und schließlich
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k^{(d)}(a)&amp;:= \{a\} \tag{für jedes Terminalsymbol und jedes \(d \in \N\)}
        \end{align*}
        $$
      </div>
    </div>
    <p class="main-column">
      Die Gleichungen sagen, dass wir, falls wir
      $\First_{k}^{(d-1)}(X)$ für alle Nichtterminale
      kennen, dann auch $\First_{k}^{(d)}(X)$ berechnen
      können. Daraus folgt auch: wenn
      $\First_{k}^{(d-1)}(X)=\First_{k}^{(d)}(X)$ für alle
      <span class="nowrap">$X \in N$,</span>
      dann auch
      $\First_{k}^{(d)}(X)=\First_{k}^{(d+1)}(X)$ für alle
      <span class="nowrap">$X \in N$,</span>
      und somit werden die Mengen
      $\First_{k}^{(d)}(X)$ für alle $d$ von nun an gleich
      bleiben.
    </p>
    <div class="well statement out">
      <p>
        <b>Beobachtung 6.4.14</b>
        Falls $\First_{k}^{(d-1)}(X)=\First_{k}^{(d)}(X)$ für
        alle
        <span class="nowrap">$X \in N$,</span>
        dann gilt
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k (X) = \First_k^{(d)}(X)
        \end{align*}
        $$
      </div>
      <p>
        für alle
        <span class="nowrap">$X \in N$.</span>
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Demo. 6.4.15 - Berechnung der Menge $\First_k(A)$ für die
          Nichtterminale einer Sprache.</b>
        Wir betrachten die
        Grammatik
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\rightarrow Xa \ | \ \epsilon \\
        X&amp;\rightarrow b \ | \ Sc \ | \ SX
        \end{align*}
        $$
      </div>
    </div>
    <div class="pseudowell">
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/01.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/02.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/03.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/04.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/05.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/06.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/07.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/08.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/09.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/10.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/11.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/12.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/13.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/14.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/15.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/16.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/17.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/18.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/19.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/20.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/21.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/22.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/23.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/24.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/25.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/26.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/27.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/28.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/29.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/30.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/30.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/31.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/32.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/33.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/34.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/35.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/36.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/37.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/38.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/39.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/40.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/41.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/42.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/43.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/44.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/45.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/46.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/47.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/48.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/49.svg">
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="end-of-page-elt">
    </div>
    <hr id="bottom-menu-hr">
    <div id="bottom-menu">
      <div id="bottom-menu-left">
        <a href="./6-3.html">&lt;&lt; Kapitel 6.3<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >Rechnerübung: Gute kontextfreie Grammatiken entwerfen</span></a>
      </div>
      <div id="bottom-menu-right">
        <a href="./6-5.html">Kapitel 6.5 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >LR-Parser per Hand entwerfen</span></a>
      </div>
    </div>
  </div>
</body>
</html>
