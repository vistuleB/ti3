<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 6.4 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 6, Section 4</title>
</head>
<body>
  <div class="body-wrapper">
    <div id="top-menu">
      <div class="top-menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./6-3.html"
        >&lt;&lt; Kapitel 6.3<span
            style="visibility:hidden"
            id="prev-page-tooltip"
          >Rechnerübung: Gute kontextfreie Grammatiken entwerfen</span></a>
      </div>
      <div class="top-menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./6-5.html"
        >Kapitel 6.5 &gt;&gt;<span
            style="visibility:hidden"
            id="next-page-tooltip"
          >LR-Parser per Hand entwerfen</span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        <span class="nowrap">6.4&ensp;LL($k$)-Grammatiken</span>
        (nicht im Sommersemester 2025)
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>6.4.1</b>
        <b>Grenzform</b>
        Sei $G = (\Sigma, N, S, P)$ eine kontextfreie
        Grammatik. Eine Wortform $A \alpha$ - also eine Wortform, die
        mit einem Nichtterminal beginnt - heißt
        <span class="nowrap"><i>Grenzform</i>,</span>
        wenn es ein
        $w \in \Sigma^*$ gibt, so dass es eine Linksableitung
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S \Step{}^* w A \alpha
        \end{align*}
        $$
      </div>
      <p>
        gibt. In anderen Worten: eine Grenzform ist das, was bei einem
        Kellerautomaten auf dem Stack liegt, wenn ein Nichtterminal ganz
        oben liegt.
      </p>
    </div>
    <p class="main-column">
      Grenzformen sind also diejenigen Wortformen, bei denen der
      Kellerautomat eine Entscheidung treffen muss, weil er eventuell
      mehrere Produktionen $A \rightarrow \beta$ zur Auswahl hat. In
      diesem Teilkapitel wollen wir herausarbeiten, unter welchen
      Umständen wir die richtige Auswahl treffen können, auch wenn wir
      nur wenige weitere Zeichen unseres Inputwortes lesen dürfen.
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>6.4.2</b>
        Für ein Wort $w \in \Sigma^*$ und eine natürliche Zahl $k \in \N$
        sei $\first_k(w)$ wie folgt definiert:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \first_k(w) := \begin{cases}
        w&amp;\textnormal{ wenn $|w| \lt k$} \\
        u&amp;\textnormal{ wenn $w = uv$ und $|u| = k$}
        \end{cases}
        \end{align*}
        $$
      </div>
      <p>
        In Worten: $\first_{k}(w)$ besteht aus den ersten $k$ Zeichen
        von $w$ (oder aus ganz
        <span class="nowrap">$w$,</span>
        falls es weniger als $k$ lang ist).
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>6.4.3</b>
        <b><span class="nowrap">LL($k$)-Grammatiken</span></b>
        Eine kontextfreie Grammatik
        $G = (\Sigma, N, S, P)$ ist eine
        <span class="nowrap">LL($k$</span>
        )-Grammatik, wenn für
        jede Grenzform $A \alpha$ und für jedes Paar
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        A&amp;\step{1} \beta \\
        A&amp;\step{2} \gamma
        \end{align*}
        $$
      </div>
      <p>
        verschiedener Produktionen (also
        <span class="nowrap">$\beta \ne \gamma$)</span>
        folgendes
        gilt: wenn
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        A\alpha&amp;\Step{1} \beta \alpha \Step{}^* x \\
        A\alpha&amp;\Step{2} \gamma \alpha \Step{}^* y \\
        \end{align*}
        $$
      </div>
      <p>
        dann müssen sich $x$ und $y$ in den ersten $k$ Zeichen
        unterscheiden, also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \first_k(x) \ne \first_k(y) \ .
        \end{align*}
        $$
      </div>
    </div>
    <p class="main-column">
      Intuitiv gesprochen: wenn wir bereits eine ersten Teil $w$ unseres
      Zielwortes abgeleitet haben, dann können wir die nächste
      anzuwendende Produktion eindeutig bestimmen, indem wir die nächsten
      $k$ Zeichen des Zielwortes lesen.
    </p>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 6.4.1</b>
        Negieren Sie die Definition, d.h., schreiben Sie eine Aussage
        der Form
        <i>Wenn $G$ nicht
          <span class="nowrap">LL($k$)</span>
          ist, dann gibt es...</i>
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Beispiel</b>
        <b>6.4.4</b>
        Die Klammern-Grammatik
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\step{1} \epsilon \\
        S&amp;\step{2} (S)S
        \end{align*}
        $$
      </div>
      <p>
        ist LL(1).
      </p>
      <div class="well remark">
        <p>
          <b>Beweis.</b>
          Folgen wir der Definition von LL(1): für jedes Paar
          verschiedener Regeln muss etwas gelten. Wir haben hier keine
          Auswahl, denn es gibt ja nur ein Paar. Also müssen wir zeigen,
          dass, falls
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          S \Step{}^* wS\alpha&amp;\Step{1} w \alpha \Step{}^* w x \\
          S \Step{}^* wS\alpha&amp;\Step{2} w \texttt{(}S\texttt{)}S \alpha \Step{}^* w y \\
          \end{align*}
          $$
        </div>
        <p>
          gilt, dann auch $\first_1(x) \ne \first_2(y)$ gilt.
          Offensichtlich ist $\first_2(y) =$ "
          <span class="nowrap">$\texttt{(}$".</span>
          Was kann
          $\first_k(x)$ sein?
        </p>
        <p>
          <b>Behauptung.</b>
          Wenn
          <span class="nowrap">$S \rightarrow \delta \in (\Sigma \cup N)^*$,</span>
          dann steht jedes
          $S$ in $\delta$ entweder am Ende von $\delta$ oder unmittelbar
          vor einem "
          <span class="nowrap">$\texttt{)}$".</span>
          Das folgt per Induktion über die
          Länge der Ableitung. Wenn es also für $\delta$ gilt und wir
          die Produktion $S \rightarrow (S)S$ auf $\delta$ anwenden,
          dann gilt es für jedes "alte" $S$ und auch für die beiden neu
          erzeugten; wenn wir $S \rightarrow \epsilon$ anwenden, dann
          verschwindet ein
          <span class="nowrap">$S$,</span>
          die Behauptung gilt aber nach wie vor
          für alle anderen $S$ in
          <span class="nowrap">$\delta$.</span><span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>Wir folgern also, dass für das $\alpha$ den beiden obigne
          Herleitungen $\first_k(\alpha) \in \{\epsilon, \texttt{)}\}$
          gilt. Keines davon ist ein Nichtterminal, und so muss auch
          $\first_k(\alpha) = \first_k(x)$ gelten. Zusammenfassend
          gesagt:
        </p>
        <div class="math-block">
          $$
          \begin{align*}
          \first_k(x)&amp;\in \{\epsilon, \texttt{)}\} \\
          \first_y(y)&amp;= \texttt{(} \ ,
          \end{align*}
          $$
        </div>
        <p>
          und somit sind sie verschieden. Wir folgern, dass $G$ eine
          LL(1)-Grammatik ist.
        </p>
      </div>
    </div>
    <p class="main-column">
      Sehen Sie, dass die
      <span class="nowrap">LL($k$)-Bedingung</span>
      der Aussage "der
      Backtrack-Baum hat keine langen Sackgassen" ähnelt (aber nicht
      völlig äquivalent dazu ist). Wenn $G$ eine LL(
      <span class="nowrap">$k$)-Grammatik</span>
      ist
      und wir den Backtrack-Baum für ein Wort bauen, dann gilt: sobald
      wir in einer Sackgasse $k$ neue Terminalsymbole am
      "Terminalpräfix" der Wortform hergeleitet haben, merken wir, dass
      wir in einer Sackgasse sind. Mit Terminalpräfix meine ich den
      längsten Präfix einer Wortform, der ausschließlich aus Terminalen
      besteht. Allerdings muss nicht jeder Ableitungsschritt den
      Terminalpräfix wachsen lassen (Regeln wie $X \rightarrow YbZ$ zum
      Beispiel ersetzen einfach das erste Nichtterminal), aber
      "moralisch" geschieht etwas ähnliches). Wenn umgekehrt eine
      Grammatik
      <i>nicht</i>
      LL(
      <span class="nowrap">$k$)</span>
      ist, dann muss der Backtrack-Baum
      beiden Ableitungen
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      w A \alpha&amp;\Rightarrow w \beta \alpha \\
      w A \alpha&amp;\Rightarrow w \gamma \alpha \\
      \end{align*}
      $$
    </div>
    <p class="main-column">
      mindestens so lange weiterverfolgen, bis der Terminalpräfix $k$
      weitere Zeichen dazugewonnen hat. Der Baum bekommt also
      dementsprechend lange Sackgassen.
    </p>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 6.4.2</b>
        (Beispiel 5.3 aus
        <i>The Theory of Parsing, Translation, and
          Compiling</i>
        von Alfred V. Aho und Jeffrey D. Ullman). Betrachten
        wir die Grammatik
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\step{1} \epsilon \\
        S&amp;\step{2} ab A \\
        A&amp;\step{3} Saa \\
        A&amp;\step{4} b
        \end{align*}
        $$
      </div>
      <p>
        Zeigen Sie, dass diese Grammatik LL(2) ist, aber nicht LL(1).
        <b>Tip.</b>
        Leiten Sie erst einmal ein Dutzend verschiedene Wörter ab
        und finden dann eine "normalsprachliche" Beschreibung dieser
        Sprache. Beschreiben Sie dann alle möglichen Wortformen $\alpha$
        mit
        <span class="nowrap">$S \Step{}^* \alpha$.</span>
      </p>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 6.4.3</b>
        Schreiben Sie eine äquivalente Grammatik zu der vorherigen
        Sprache, die LL(1) ist. (Warnung: Ich weiß nicht, ob das
        überhaupt geht).
      </p>
    </div>
    <div
      id="_25_hgi_"
      class="well exercise out"
    >
      <p>
        <b>Übungsaufgabe 6.4.4</b>
        Betrachten wir die Grammatik
        <span class="nowrap">$G$:</span>
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\step{1} a S b \\
        S&amp;\step{2} a S \\
        S&amp;\step{3} \epsilon
        \end{align*}
        $$
      </div>
      <p>
        Sie erzeugt die Sprache
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        L(G) := \{ a^{m+k} b^m \ | \ m, k \in \N \} \ ,
        \end{align*}
        $$
      </div>
      <p>
        also Wörter, wo auf beliebig viele
        <span class="nowrap">$a$'s</span>
        eine Folge von
        <i>höchstens</i>
        so vielen
        <span class="nowrap">$b$'s</span>
        folgt. Geben Sie diese Grammatik in
        den
        <a href="href=https://www.tu-chemnitz.de/informatik/theoretische-informatik/demos/drawManualGrammar.html">Parser-Simulator</a>
        ein und finden Wörter mit langen Sackgassen. Zeigen Sie, dass
        diese Grammatik nicht
        <span class="nowrap">LL$(k)$</span>
        ist, für kein
        <span class="nowrap">$k \in \N$.</span>
      </p>
    </div>
    <div class="well exercise out">
      <p>
        <b>Übungsaufgabe 6.4.5</b>
        Sei $t \in \N$ eine feste, im Voraus bekannte Zahl. Betrachten
        wir die Sprache
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        L_t := \{a^{m + l} b^m \ | \ m \geq 0, l \leq t\} \ ,
        \end{align*}
        $$
      </div>
      <p>
        also die Wörter der Form $a^m b^n$ mit
        <span class="nowrap">$n \leq m \leq n+t$.</span>
        Schreiben Sie für $L_3$ eine Grammatik, geben Sie diese im
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/demos/drawManualGrammar.html">Parser-Simulator</a>
        ein und schauen, wie lang die Sackgassen werden können. Zeigen
        Sie, dass $L_3$ eine
        <span class="nowrap">LL$(k)$</span>
        -Grammatik ist. Für welchen Wert
        von
        <span class="nowrap">$k$?</span>
        Ist $L_t$ (für im Voraus bekanntes $t$ ) eine
        <span class="nowrap">LL$(k)$</span>
        -Grammatik? Für welchen Wert von
        <span class="nowrap">$k$?</span>
      </p>
    </div>
    <h2 class="main-column topic-announcement">
      <span class="nowrap">LL$(k)$-Grammatiken</span>
      parsen
    </h2>
    <p class="main-column">
      Wir wollen nun erarbeiten, wie wir für eine LL $(k)$ -Grammatik
      einen Parser, also im Prinzip einen deterministischen
      Pushdown-Automaten schreiben können. Wir tasten uns langsam voran.
      Wir beginnen mit einer Verallgemeinerung von $\first_k$ von
      Wörtern auf
      <i>Wortformen</i>
      (die also Nichtterminale beinhalten
      können).
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>6.4.5</b>
        Sei eine kontextfreie Grammatik $G = (\Sigma, N, S, P)$ und eine
        Wortform $\alpha \in (\Sigma \cup N)^*$ gegeben. Wir definieren
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k(\alpha) := \{ \first_k(w) \ | \ w \in \Sigma^*, \alpha \Step{}^* w\}
        \end{align*}
        $$
      </div>
    </div>
    <p class="main-column">
      Wir können nun die
      <span class="nowrap">LL$(k)$-Bedingung</span>
      äquivalent formulieren:
    </p>
    <div class="well statement out">
      <p>
        <b>Definition/Beobachtung</b>
        <b>6.4.6</b>
        Eine Grammatik $G$ ist
        <span class="nowrap">LL$(k)$</span>
        genau dann, wenn für alle
        Grenzformen $A \alpha$ und alle Produktionen mit $A$ auf der
        linken Seite, also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        A&amp;\rightarrow \beta_1 \\
        A&amp;\rightarrow \beta_2 \\
        &amp;\vdots\\
        A&amp;\rightarrow \beta_l
        \end{align*}
        $$
      </div>
      <p>
        die Mengen $\First(\beta_i \alpha)$ paarweise disjunkt sind
        (wenn also keine zwei dieser Mengen ein gemeinsames Element
        enthalten).
      </p>
    </div>
    <p class="main-column">
      Nehmen wir eine Momentaufnahme unseres Kellerautomaten. Er hat den
      Präfix $x$ des Eingabewortes $xy$ gelesen und eine Linksableitung
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      S \Rightarrow^*{} x \alpha
      \end{align*}
      $$
    </div>
    <p class="main-column">
      durchgeführt. Die Wortform $\alpha$ ist genau das, was im Moment
      auf dem Stack des Automaten liegt (um ganz genau zu sein:
      \(\alpha\texttt{\$}\) liegt auf dem Stack). Wenn $\alpha$ mit
      einem Terminalsymbol $c$ beginnt, so ist klar, was wir machen
      müssen: wir schauen, ob $y$ mit $c$ beginnt. Wenn ja, lesen wir $c$
      und poppen es vom Stack. Der schwierige Fall ist, wenn $\alpha$
      mit einem Nichtterminal beginnt. Nochmal von vorn: im schwierigen
      Fall liegt auf dem Stack (oberhalb vom
      <span class="nowrap">\(\$\))</span>
      eine Wortform, die
      mit einem Nichtterminal beginnt, also
      <span class="nowrap">$A \alpha$.</span>
      Das bedeutet,
      dass der Automat per Linksableitung bis jetzt
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      S \Step{}^* x A \alpha
      \end{align*}
      $$
    </div>
    <p class="main-column">
      hergeleitet hat. Der Automat muss sich nun zwischen allen Regeln
      für $A$ entscheiden:
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      A&amp;\rightarrow \beta_1 \\
      A&amp;\rightarrow \beta_2 \\
      &amp;\vdots\\
      A&amp;\rightarrow \beta_l \ .
      \end{align*}
      $$
    </div>
    <p class="main-column">
      Der Automat betrachtet nun die nächsten $k$ Eingabesymbole, also
      $\first_k(y)$ (wir gehen mal davon aus, dass er das kann;
      programmieren könnten wir das auf jeden Fall; ob man es im strengen
      Framework des Kellerautomaten hinkriegt, werden wir später sehen).
      Wenn $G$ eine
      <span class="nowrap">LL$(k)$-Grammatik</span>
      ist, dann gibt es höchstens eine
      Regel $A \rightarrow \beta_i$ mit
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      \first_k(y) \in \first_k(\beta_i \alpha)
      \end{align*}
      $$
    </div>
    <p class="main-column">
      da ja nach obiger Beobachtung diese Mengen disjunkt sind. Wenn
      $\first_k(y)$ in
      <i>keiner</i>
      dieser Mengen enthalten ist, so kann die
      Ableitung offensichtlich nicht vervollständigt werden, und wir
      schließen, dass $xy \not \in L(G)$ ist. Wenn es
      <i>genau ein</i>
      $\beta_i$ gibt mit
      <span class="nowrap">$\first_k(y) \in \first_k(\beta_i \alpha)$,</span>
      dann ist $A \rightarrow \beta_i$ die "richtige" Produktion. Wir
      wenden sie an, ersetzen also $A$ auf dem Stack durch
      <span class="nowrap">$\beta_i$.</span>
      Falls es zwei oder mehr Produktionen $A \rightarrow \beta_i$ gibt
      mit
      <span class="nowrap">$\first_k(y) \in \first_k(\beta_i \alpha)$,</span>
      dann ist die
      Grammatik nicht
      <span class="nowrap">LL$(k)$;</span>
      wir beenden den Parsing-Prozess mit einer
      Laufzeitfehlermeldung. Hier ist ein Entwurf eines allgemeinen
      Algorithmus für LL
      <span class="nowrap">$(k)$-Grammatiken:</span>
    </p>
    <div class="well highlight out">
      <p>
        <b>Generischer Algorithmus zum Parsen von
          <span class="nowrap">LL$(k)$-Gramatiken</span></b>
      </p>
      <ol>
        <li>
          <p>
            Lege \(S\texttt{\$}\) auf den Stack.
          </p>
        </li>
        <li>
          <p>
            <code>while</code>
            Stack nicht leer:
          </p>
          <ol>
            <li>
              <p>
                Sei $y$ das Resteingabewort.
              </p>
            </li>
            <li>
              <p>
                Wenn das oberste Symbol auf dem Stack ein Terminalsymbol
                $c$ ist:
              </p>
              <ul>
                <li>
                  <p>
                    Lies das nächste Eingabesymbol
                    <span class="nowrap">$c'$.</span>
                  </p>
                </li>
                <li>
                  <p>
                    Wenn
                    <span class="nowrap">$c = c'$,</span>
                    poppe $c$ vom Stack;
                  </p>
                </li>
                <li>
                  <p>
                    ansonsten
                    <span class="nowrap"><code>Reject</code>.</span>
                  </p>
                </li>
              </ul>
            </li>
            <li>
              <p>
                Wenn das oberste Symbol auf dem Stack ein
                Nichtterminalsymbol $A$ ist:
              </p>
              <ol>
                <li>
                  <p>
                    Schreibe den Stack als $A \alpha$
                  </p>
                </li>
                <li>
                  <p>
                    Seien
                    $A \rightarrow \beta_1, \dots, A \rightarrow
                    \beta_l$
                    alle Produktionen mit $A$ auf der linken Seite.
                  </p>
                </li>
                <li>
                  <p>
                    <span style="color:red; font-weight: bold;">Berechne $\First_k(\beta_i\alpha)$ für alle
                      $\beta_i$ und schaue, welches $\first_k(y)$
                      enthält</span>
                  </p>
                  <ul>
                    <li>
                      <p>
                        Wenn es genau eine solche Produktion
                        $A \rightarrow \beta_i$ gibt: wende Sie an; es
                        ist die richtige Produktion.
                      </p>
                    </li>
                    <li>
                      <p>
                        Wenn es keine gibt:
                        <span class="nowrap"><code>Reject</code>.</span>
                        Das Wort kann
                        nicht abgeleitet werden.
                      </p>
                    </li>
                    <li>
                      <p>
                        Wenn es mehrere gibt: ende mit einem
                        Laufzeitfehler; die Grammatik ist nicht
                        <span class="nowrap">LL$(k)$.</span>
                      </p>
                    </li>
                  </ul>
                </li>
              </ol>
            </li>
            <li>
              <p>
                Wenn das oberste Symbol \(\texttt{\$}\) ist: wenn
                Eingabewort zu Ende
                <code>Accept</code>
                ansonsten
                <code>Reject</code>
              </p>
            </li>
          </ol>
        </li>
      </ol>
    </div>
    <p class="main-column">
      Die rot und fett gedruckte Zeile ist das "Herz" dieses
      Algorithmus. Um den Algorithmus implementieren zu können, müssen
      wir es schaffen, die Menge $\First_k(\beta_i\alpha)$ zu berechnen.
    </p>
    <h2 class="main-column topic-announcement">
      $\First_k(A)$ und $\First_k(\alpha)$ berechnen.
    </h2>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>6.4.7</b>
        Seien $K, L \subseteq \Sigma^*$ zwei Mengen. Mit $K \circ L$
        bezeichnen wir die Menge
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        K \circ L := \{xy \ | \ x \in K, y \in L\} \ .
        \end{align*}
        $$
      </div>
      <p>
        (Diese Definition haben Sie schon im Kapitel über reguläre
        Sprachen kennengelernt). Für eine natürliche Zahl $k$ definieren
        wir
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k(L) := \{\first_k(x) \ | \ x \in L\} \ .
        \end{align*}
        $$
      </div>
      <p>
        Weiterhin bezeichnen wir mit $K \circ_k L$ die Menge
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        K \circ_k L&amp;:= \First(K \circ L) \\
        &amp;= \{\first_k(xy) \ | \ x \in K, y \in L\} \ .
        \end{align*}
        $$
      </div>
    </div>
    <p class="main-column">
      Im Allgemeinen gilt
      <span class="nowrap">$\First_k(S_1 \circ \dots \circ S_l) = S_1 \circ_k S_2 \circ_k
        \dots \circ_k S_l$.</span>
      In Worten: der
      <span class="nowrap">$\circ_k$-Operator</span>
      bildet alle möglichen
      Kombinationen von Wörtern und nimmt von jedem die ersten $k$
      Zeichen.
    </p>
    <div class="well statement out">
      <p>
        <b>Beispiel</b>
        <b>6.4.8</b>
        Sei
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        K&amp;:= \{\epsilon, a, ab, aba\} \\
        L&amp;:= \{c, bb, b\}
        \end{align*}
        $$
      </div>
      <p>
        Dann ist
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        K \circ L = \{c, bb, b, ac, abb, ab, abc, abbb, abb, abac, ababb, abab\}
        \end{align*}
        $$
      </div>
      <p>
        und somit
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        K \circ_2 L&amp;= \{c, bb, b, ac, ab, ab, ab, ab, ab, ab, ab, ab\} \\
        &amp;=\{c, bb, b, ac, ab\}
        \end{align*}
        $$
      </div>
    </div>
    <div class="well statement out">
      <p>
        <b>Beobachtung</b>
        <b>6.4.9</b>
        <b>- Wie man $\First_k(\alpha)$ berechnet.</b>
        Sei eine Wortform
        $\alpha$ gegeben, also
        <span class="nowrap">$\alpha \in (\Sigma \cup N)^*$.</span>
        Wir
        berechnen
        <span class="nowrap">$\First_k(\alpha)$,</span>
        indem wir als erstes $\alpha$
        aussschreiben als
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \alpha = (\sigma_1 \sigma_2 \sigma_3 \dots \sigma_n)
        \end{align*}
        $$
      </div>
      <p>
        wobei jedes $\sigma_i$ ein Terminalsymbol oder ein
        Nichtterminalsymbol ist, und berechnen dann $\First_k(\alpha)$
        wie folgt:
      </p>
      <div class="math-block">
        $$
        \begin{align}
        \First_k(\alpha) = \First_k(\sigma_1) \circ_k \First_k(\sigma_2) \circ_k \dots \circ_k \First_k
        (\sigma_n) \ .
        \label{first-k-wortform}
        \end{align}
        $$
      </div>
      <p>
        Wir können dies schön der Reihe nach tun:
      </p>
      <ol>
        <li>
          <p>
            Initialisiere $K := \{\epsilon\}$
          </p>
        </li>
        <li>
          <p>
            <code>for</code>
            $i=n$
            <code>down to</code>
            1
            <code>do:</code>
          </p>
          <ul>
            <li>
              <p>
                $K := \First_k(\sigma_i) \circ_k K$<span class="comment">// $K$ ist jetzt
                  $\First_k(\sigma_i) \circ_k \dots \circ_k
                  \First_k(\sigma_n)$</span>
              </p>
            </li>
          </ul>
        </li>
        <li>
          <p>
            <code>return</code>
            $K$
          </p>
        </li>
      </ol>
      <p>
        Wir müssen nur noch herausfinden, wie wir $\First_k(\sigma)$ für
        einzelne Zeichen $\sigma$ berechnen.
      </p>
    </div>
    <p class="main-column">
      Für ein Terminalsymbol $c$ ist es trivial, $\First_k(c)$ zu
      berechnen: es ist
      <span class="nowrap">$\{c\}$,</span>
      da sich aus $c$ natürlich nur das Wort
      $c$ ableiten lässt. Für Nichtterminale müssen wir uns anstrengen.
      Die erste Idee ist, dass wir für $\First_k(X)$ eine Gleichung
      schreiben können, die $(\ref{first-k-wortform})$ verwendet.
    </p>
    <div class="well statement out">
      <p>
        <b>Beobachtung</b>
        <b>6.4.10</b>
        Sei $X$ ein Nichtterminal und
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        X&amp;\rightarrow \alpha_1 \\
        X&amp;\rightarrow \alpha_2 \\
        &amp;\vdots \\
        X&amp;\rightarrow \alpha_k
        \end{align*}
        $$
      </div>
      <p>
        die Produktionen der Grammatik mit $X$ auf der linken Seite.
        Dann gilt
      </p>
      <div class="math-block">
        $$
        \begin{align}
        \First_k(X) = \bigcup_{i=1}^k \First_k(\alpha_i)
        \label{first-k-nonterminal}
        \end{align}
        $$
      </div>
      <p>
        Was ja eigentlich offensichtlich ist: wenn sich ein Wort
        $X \Step{}^* w$ aus $X$ ableiten lässt, dann muss dies mittels
        einer der obigen Produktionen geschehen:
        <span class="nowrap">$X \Step{} \alpha_i \Step{}^* w$,</span>
        und somit gilt
        <span class="nowrap">$\first_k(w)\in \First_k(\alpha_i)$.</span>
      </p>
    </div>
    <p class="main-column">
      Die Gleichungen $(\ref{first-k-wortform})$ und
      $(\ref{first-k-nonterminal})$ leuchten zwar ein, scheinen aber
      erstmal nicht hilfreich, diese Mengen auch tatsächlich zu
      berechnen. Denn eventuell taucht $X$ selbst wieder auf einer
      rechten Seite auf, sagen wir
      <span class="nowrap">$\alpha_1$.</span>
      Um $\First_k(X)$ zu
      berechnen, müssen wir also laut $(\ref{first-k-nonterminal})$ die
      Menge $\First_k(\alpha_1)$ kennen; um diese zu berechnen, brauchen
      wir laut $(\ref{first-k-wortform})$ allerdings zuerst unter
      Anderem die Menge
      <span class="nowrap">$\First_k(X)$.</span>
      Wo sollen wir also anfangen? In
      solchen Situationen, wo sich "die Katze in den Schwanz beißt",
      hilft es oft, die Definition vorerst
      <i>komplexere</i>
      un
      <i>genauer</i>
      zu
      machen. Wir führen nun, zusätzlich zu $\First_k(X)$ und
      <span class="nowrap">$\First_k(\alpha)$,</span>
      noch eine feinere Unterteilung an:
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>6.4.11</b>
        Sei $\sigma$ ein Symbol und
        <span class="nowrap">$d \in \N$.</span>
        Dann ist
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k^{(d)}(\sigma) := \{\first_k(w) \ | \ \textnormal{ es gibt einen Ableitungsbaum für
        $\sigma \Step{}^* w$ der Höhe höchstens $d$}\}
        \end{align*}
        $$
      </div>
    </div>
    <div class="well statement out">
      <p>
        <b>Beispiel</b>
        <b>6.4.12</b>
        Sei unsere Grammatik
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\rightarrow Xa \\
        X&amp;\rightarrow Sb \ | c
        \end{align*}
        $$
      </div>
      <p>
        Dann ist beispielsweise
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:8em"
            src="./img/context-free/LL/tree-depth-2.svg"
          >
        </figure>
      </div>
      <p>
        ein Ableitungsbaum der Höhe 2 von $S \Step{}^* ca$ , und somit
        gilt
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        c \in \First_1^{(d)} (S) \ .
        \end{align*}
        $$
      </div>
      <p>
        Ein Baum der Höhe 1, der mit $S$ beginnt, könnte ja nur $Xa$
        ableiten und somit gar kein Wort. Es gilt also
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_1^{(1)} (S) = \emptyset \ .
        \end{align*}
        $$
      </div>
      <p>
        Für eine Wortform
        $\alpha = \sigma_1 \sigma_2 \dots \sigma_n \in (\Sigma \cup
        N)^*$
        definieren wir
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k^{(d)}(\alpha) = \First_k^{(d)}(\sigma_1) \circ_k \First_k^{(d)}(\sigma_2) \circ_k \dots
        \circ_k \First_k^{(d)}
        \end{align*}
        $$
      </div>
      <p>
        Eine Ableitung $\alpha \Step{}^* w$ der Höhe maximal $d$
        entspricht also einer Folge von $n$ Ableitungsbäumen, von denen
        jeder Höhe maximal $d$ hat.
      </p>
    </div>
    <p class="main-column">
      Mit dieser Definition können wir nun Gleichungen für
      $\First_k^{(d)}(X)$ und $\First_k^{(d)}(\alpha)$ angeben. Seien
      $X \rightarrow \alpha_1 \ | \ \dots \ | \ \alpha_k$ die
      Produktionen mit $X$ auf der linken Seite. Dann gilt für
      <span class="nowrap">$k \geq 1$:</span>
    </p>
    <div class="well statement out">
      <p>
        <b>Lemma</b>
        <b>6.4.13</b>
        Für $d \geq 1$ gilt
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k^{(d)}(X)&amp;= \bigcup_{i=1}^k \First_k^{(d-1)} (\alpha_i) \\
        \First_k^{(d)}(\alpha)&amp;= \First_k^{(d)}(\sigma_1) \circ_k \First_k^{(d)}(\sigma_2) \circ_k
        \dots \circ_k \First_k^{(d)}
        \end{align*}
        $$
      </div>
      <p>
        Für $d = 0$ gilt
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k^{(0)}(X)&amp;:= \emptyset \tag{für jedes Nichtterminal}
        \end{align*}
        $$
      </div>
      <p>
        und schließlich
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k^{(d)}(a)&amp;:= \{a\} \tag{für jedes Terminalsymbol und jedes \(d \in \N\)}
        \end{align*}
        $$
      </div>
    </div>
    <p class="main-column">
      Die Gleichungen sagen, dass wir, falls wir $\First_{k}^{(d-1)}(X)$
      für alle Nichtterminale kennen, dann auch $\First_{k}^{(d)}(X)$
      berechnen können. Daraus folgt auch: wenn
      $\First_{k}^{(d-1)}(X)=\First_{k}^{(d)}(X)$ für alle
      <span class="nowrap">$X \in N$,</span>
      dann auch $\First_{k}^{(d)}(X)=\First_{k}^{(d+1)}(X)$ für alle
      <span class="nowrap">$X \in N$,</span>
      und somit werden die Mengen $\First_{k}^{(d)}(X)$ für
      alle $d$ von nun an gleich bleiben.
    </p>
    <div class="well statement out">
      <p>
        <b>Beobachtung</b>
        <b>6.4.14</b>
        Falls $\First_{k}^{(d-1)}(X)=\First_{k}^{(d)}(X)$ für alle
        <span class="nowrap">$X \in N$,</span>
        dann gilt
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \First_k (X) = \First_k^{(d)}(X)
        \end{align*}
        $$
      </div>
      <p>
        für alle
        <span class="nowrap">$X \in N$.</span>
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Demo.</b>
        <b>6.4.15</b>
        <b>- Berechnung der Menge $\First_k(A)$ für die Nichtterminale
          einer Sprache.</b>
        Wir betrachten die Grammatik
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        S&amp;\rightarrow Xa \ | \ \epsilon \\
        X&amp;\rightarrow b \ | \ Sc \ | \ SX
        \end{align*}
        $$
      </div>
    </div>
    <div class="pseudowell">
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/01.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/02.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/03.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/04.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/05.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/06.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/07.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/08.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/09.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/10.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/11.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/12.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/13.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/14.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/15.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/16.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/17.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/18.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/19.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/20.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/21.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/22.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/23.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/24.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/25.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/26.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/27.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/28.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/29.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/30.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/30.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/31.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/32.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/33.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/34.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/35.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/36.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/37.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/38.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/39.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/40.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/41.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/42.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/43.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/44.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/45.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/46.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/47.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/48.svg">
            </div>
            <div class="carousel__item">
              <img src="./img/context-free/LL/compute-first-2/49.svg">
            </div>
          </div>
        </div>
      </div>
    </div>
    <div id="end-of-page-elt">
    </div>
    <div id="bottom-menu">
      <div class="bottom-menu-left">
        <a href="./6-3.html">&lt;&lt; Kapitel 6.3<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >Rechnerübung: Gute kontextfreie Grammatiken entwerfen</span></a>
      </div>
      <div class="bottom-menu-right">
        <a href="./6-5.html">Kapitel 6.5 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >LR-Parser per Hand entwerfen</span></a>
      </div>
    </div>
  </div>
</body>
</html>
