<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 9.5 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="ti3.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./ti3.js"></script>
  <title>TI3 - Chapter 9, Section 5</title>
</head>
<body class="page-sub chapter-9 sub-5">
  <div
    path="./9-5.html"
    class="subchapter"
  >
    <div class="menu">
      <div class="menu-left">
        <a href="./index.html">Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./9-4.html"
        >&lt;&lt; Kapitel 9.4</a>
      </div>
      <div class="menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./9-6.html"
        >Kapitel 9.6  &gt;&gt;</a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        9.5 
        Reduktionen
      </p>
    </div>
    <p class="main-column">
      <span style="font-variant:small-caps;">3-Colorability</span>
      und
      <span style="font-variant:small-caps;">CNF-Satisfiability</span>
      sind in NP: gegeben ein Graph $G$ und eine Färbung
      <span class="nowrap">$c$,</span>
      so können wir effizient feststellen, ob $c$ eine
      gültige 3-Färbung von $G$ darstellt; gegeben eine
      CNF-Formel $F$ und eine Belegung
      <span class="nowrap">$\alpha$,</span>
      so können
      wir effizient überprüfen, ob $F$ unter $\alpha$ zu
      <code>True</code>
      auswertet. Können wir
      <span style="font-variant:small-caps;">3-Colorability</span>
      und<span style="font-variant:small-caps;">CNF-Satisfiability</span>
      auch effizient entscheiden? Sind sie in P? Das ist
      (Stand: 2025) nicht bekannt. Was wir aber sagen können:
      entweder sind beide effizient lösbar oder beide nicht.
      Sie sind gewissermaßen gleich schwer.
    </p>
    <div
      id="_32_hgi_"
      class="well statement out"
    >
      <p>
        <b>Theorem</b>
        <b>9.5.1</b>
        Falls
        <span style="font-variant:small-caps;">CNF-Satisfiability</span>
        in P ist, dann auch
        <span style="font-variant:small-caps;">3-Colorability</span>.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Wir nehmen an, wir hätten einen effizienten
        AlgorithmUs
        <code><span class="nowrap">is_satisfiable($F$)</span></code>. Wir verwenden diesen,
        um einen Algorithmus
        <code>is_3_colorable</code>
        zu entwerfen.
        Sei nun $G = (V,E)$ ein Graph und
        $v_1, \dots, v_n$ seine Knoten. Wir führen $3n$ Boolesche
        Variable ein:
        <span class="nowrap">$r_1, \dots, r_n, g_1, \dots, g_n, b_1, \dots, b_n$.</span>
        Die Intention hierbei ist, dass $r_i$ anzeigt, ob
        $v_i$ rot ist und so weiter. Wir müssen jetzt Klauseln
        erschaffen, die die Aussage "das ist eine gültige 3-Färbung"
        als CNF-Formel codieren. Wir erschaffen folgende Klauseln:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        &amp;(r_i \vee g_i \vee b_i) \tag{$v_i$ hat mindestens eine Farbe}\\
        &amp;(\bar{r}_i \vee \bar{g}_i) \wedge (\bar{r}_i \vee \bar{b}_i)
        \wedge (\bar{g}_i \vee \bar{b}_i) \tag{$v_i$ hat nicht zwei Farben gleichzeitig}
        \end{align*}
        $$
      </div>
      <p>
        Dies tun wir für jedes
        <span class="nowrap">$i$.</span>
        Wir sehen nun: jede Belegung,
        die die obigen Klauseln erfüllt, entspricht einer
        <span class="nowrap">$3$-Färbung</span>
        <span class="nowrap">$c: V \rightarrow \{1,2,3\}$,</span>
        und umgekehrt.
        Nun müssen wir die Aussage
        <i>Kante $\{v_i,v_j\}$ ist
          gültig gefärbt</i>
        formulieren:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        &amp;(\bar{r}_i \vee \bar{r}_j) \tag{$v_i$ und $v_j$ sind nicht beide rot}\\
        &amp;(\bar{g}_i \vee \bar{g}_j) \tag{$v_i$ und $v_j$ sind nicht beide grün}\\
        &amp;(\bar{b}_i \vee \bar{b}_j) \tag{$v_i$ und $v_j$ sind nicht beide blau}\\
        \end{align*}
        $$
      </div>
      <p>
        und dann alles zusammenwerfen:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        F:=&amp;\quad \bigwedge_{i=1}^n \left( (r_i \vee g_i \vee b_i) \wedge(\bar{r}_i \vee \bar{g}_i)
        \wedge
        (\bar{r}_i \vee \bar{b}_i)
        \wedge (\bar{g}_i \vee \bar{b}_i) \right) \wedge \\
        &amp;\bigwedge_{\{v_i, v_j\} \in E} \left(
        (\bar{r}_i \vee \bar{r}_j) \wedge
        (\bar{g}_i \vee \bar{g}_j) \wedge
        (\bar{b}_i \vee \bar{b}_j)
        \right)
        \end{align*}
        $$
      </div>
      <p>
        Es gilt nun: $G$ ist genau dann
        <span class="nowrap">$3$-färbbar,</span>
        wenn
        $F$ erfüllbar ist. Und hier ist nun unser Code für
        <code>is_3_colorable:</code>
      </p>
<pre class="listing">
<span class="listing-bol"></span><span>def is_3_colorable(graph):</span>
<span class="listing-bol"></span><span>    F = convert_to_CNF_formula(graph)</span>
<span class="listing-bol"></span><span class="orange-comment">    # F ist die oben beschriebene Formel mit 3n Variablen</span>
<span class="listing-bol"></span><span>    return is_satisfiable(F)</span>
</pre>
      <p>
        Falls Ihnen eine Funktion
        <code>find_satisying_assignment</code>
        zur Verfügung steht, so können Sie natürlich die erfüllende
        Belegung direkt in eine gültige 3-Färbung übersetzen.
        <span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p class="main-column">
      Das ging recht schnell und direkt, weil die Aussagenlogik
      allgemein genug ist, um Aussagen über endliche Objekte
      (hier: Graphen) effizient zu codieren. Geht es auch
      andersrum? Wenn uns eine Funktion
      <code>is_3_colorable</code>
      zur Verfügung steht, können wir dann auch eine Funktion
      <code>is_satisfiable</code>
      schreiben? Wir machen einen Zwischenschritt
      und schreiben mithilfe von
      <code>is_3_colorable</code>
      einen effizienten
      Algorithmus für
      <span class="nowrap">$3$-SAT;</span>
      dies ist
      <span style="font-variant:small-caps;">CNF-Satisfiability</span>
      mit der Einschränkung, dass $F$ eine
      <span class="nowrap">$3$-CNF-Formel</span>
      ist, dass also jede Klausel nur drei Literale enthält.
      Beachten Sie, dass die Formel
      <span class="nowrap">$F$,</span>
      die wir im Beweis
      von
      <a
        href="./9-5.html#_32_hgi_"
        class=""
      >Theorem 9.5.1</a>
      erstellt haben,
      eine solche 3-CNF ist.
    </p>
    <div
      id="_33_hgi_"
      class="well statement out"
    >
      <p>
        <b>Theorem</b>
        <b>9.5.2</b>
        Falls
        <span style="font-variant:small-caps;">3-Colorability</span>
        in P ist, dann auch<span style="font-variant:small-caps;">3-SAT</span>.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Wir gehen konzeptuell ähnlich vor wie oben.
        Uns ist eine 3-CNF-Formel $F$ gegeben. Wir müssen
        jetzt einen Graphen $G = (V,E)$ bauen, der die Aussage
        <i>$F$ ist erfüllbar</i>
        irgendwie in seiner 3-Färbbarkeit
        oder eben Nicht-3-Färbbarkeit codiert. Dies ist schwieriger.
        Als ersten Schritt legen wir fest, dass die drei Farben
        nicht
        <span class="nowrap">$1$,</span>
        <span class="nowrap">$2$,</span>
        $3$ sein sollen, sondern
        <code>True</code>,
        <code>False</code>,
        <code>Neutral</code>.
      </p>
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-01.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-02.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-03.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-04.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-05.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-06.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-07.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-08.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-09.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-10.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-11.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-12.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-13.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-14.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-15.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-16.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-17.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-18.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-19.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-20.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-21.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-22.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-23.svg">
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-24.svg">
              </p>
            </div>
          </div>
        </div>
      </div>
      <p>
        Wir wiederholen die beschriebene Konstruktion für
        jede Klausel in
        <span class="nowrap">$F$.</span>
        Wir erhalten einen Graphen
        <span class="nowrap">$G$,</span>
        der genau dann
        <span class="nowrap">$3$-färbbar</span>
        ist, wenn $F$ erfüllbar
        ist. Auch können wir direkt eine gültige
        <span class="nowrap">$3$-Färbung</span>
        in eine erfüllende Belegung übersetzen und umgekehrt.
        Hier ist also der Code:
      </p>
<pre class="listing orange-comments">
<span class="listing-bol"></span>def is_3CNF_satisfiable(the_3_cnf_formula):
<span class="listing-bol"></span>    G = cOnvert_to_graph(the_3_cnf_formula)
<span class="listing-bol"></span>    <span class="actual-orange-comment"># G ist der oben konstruierte Graph</span>
<span class="listing-bol"></span>    return is_3_colorable(G)
</pre>
      <p>
        <span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p class="main-column">
      Wir haben also gezeigt, wie man eine
      <span class="nowrap">$3$-CNF</span>
      $F$ in
      einen Graphen $G$ umwandelt, so dass
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      F \textnormal{ ist erfüllbar } \Longleftrightarrow G \textnormal{ ist $3$-färbbar}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      gilt. Allerdings ging das nur unter der Annahme, dass
      $F$ eine
      <span class="nowrap">$3$-CNF</span>
      ist. Wie verhält es sich, wenn
      $F$ eine allgemeine CNF-Formel ist?
    </p>
    <div
      id="_34_hgi_"
      class="well statement out"
    >
      <p>
        <b>Theorem</b>
        <b>9.5.3</b>
        Es gibt einen effizienten Algorithmus, der als Input
        eine CNF-Formel $F$ nimmt und eine 3-CNF-Formel
        $F'$ ausgibt, so dass gilt:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        F \textnormal{ ist erfüllbar } \Longleftrightarrow F' \textnormal{ ist erfüllbar } \ .
        \end{align*}
        $$
      </div>
      <p>
        Falls es einen effizienten Algorithmus für
        <span class="nowrap">$3$-SAT</span>
        gibt, dann also auch einen für CNF-SAT.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Wir starten mit $F_0 := F$ und definieren
        eine Folge $F_0, F_1, \dots$ von CNF-Formeln. Sei
        $F_i$ die derzeit letzte erzeugte CNF-Formel. Falls
        $F_i$ eine Klausel $C$ mit vier oder mehr Literalen
        enthält, führen wir eine Operation durch, die $C$
        durch zwei neue, kleinere Klauseln ersetzt: sei
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        C = (u_1 \vee u_2 \vee u_3 \vee u_4 \vee \dots \vee u_k)
        \end{align*}
        $$
      </div>
      <p>
        mit
        <span class="nowrap">$k \geq 4$.</span>
        Wir führen eine neue, bisher nicht
        verwendete Variable $z$ ein und erschaffen die Klauseln
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        C_1 := (\bar{z} \vee u_1 \vee u_2) \\
        C_2 := (z \vee u_3 \vee \dots \vee u_k)
        \end{align*}
        $$
      </div>
      <p>
        Wir entfernen nun $C$ und fügen $C_1$ und $C_2$ ein
        und erhalten eine neue CNF-Formel
        <span class="nowrap">$F_{i+1}$.</span>
        Wir sehen
        nun: wenn $\alpha$ die Formel $F_{i+1}$ erfüllt, dann
        erfüllt sie auch
        <span class="nowrap">$F_i$;</span>
        umgekehrt wenn die Belegung
        $\beta$ die Formel $F_i$ erfüllt, dann erfüllt
        $\beta$ insbesondere
        <span class="nowrap">$C$;</span>
        wir bauen nun eine neue
        Belegung, die auch $z$ einen Wert zuweist und dann
        $C_1$ und $C_2$ erfüllt: falls (1) $\beta$ die Klausel
        $(u_1 \vee u_2)$ erfüllt, dann setzen wir $z$ auf
        <span class="nowrap">$1$,</span>
        also
        <span class="nowrap">$\alpha := \beta \cup [z \mapsto 1]$.</span>
        Die
        Belegung $\alpha$ erfüllt nun
        <span class="nowrap">$C_1$,</span>
        weil $\beta$
        das bereits tut, und
        <span class="nowrap">$C_2$,</span>
        weil $\alpha(z)=1$ ist;
        falls jedoch (2) $\beta$ die Klausel
        $(u_1 \vee u_2)$ nicht erfüllt, dann muss sie, da
        sie ja $C$ erfüllt, die Klausel
        $(u_3 \vee \dots \vee u_k)$ erfüllen und erfüllt somit
        <span class="nowrap">$C_2$,</span>
        auch ohne Verwendung von
        <span class="nowrap">$z$.</span>
        Wir setzen nun
        $z$ auf
        <span class="nowrap">$0$,</span>
        also
        $\alpha := \beta \cup [z \mapsto 0]$ und erfüllen
        sowohl $C_1$ als auch
        <span class="nowrap">$C_2$.</span>
        Alle anderen Klauseln
        sind sowieso erfüllt, weil $\beta$ sie bereits erfüllt.
        Wir sehen:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        F_i \textnormal{ ist erfüllbar } \Longleftrightarrow F_{i+1} \textnormal{ ist erfüllbar } \ .
        \end{align*}
        $$
      </div>
      <p>
        Die beiden neuen Klauseln $C_1$ und $C_2$ sind jeweils
        echt kleiner als
        <span class="nowrap">$C$.</span>
        Der Prozess endet irgendwann
        mit einer Formel
        <span class="nowrap">$F_t$,</span>
        in der jede Klausel höchstens
        drei Literale hat. Dies ist unser
        <span class="nowrap">$F'$.</span><span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p class="main-column">
      Wir haben nun also eine Kette von Implikationen erschaffen:
    </p>
    <div class="main-column">
      <ul>
        <li>
          <p>
            Wenn
            <span style="font-variant:small-caps;">CNF-Satisfiability</span>
            in P, dann auch
            <span style="font-variant:small-caps;">3-Colorability</span>(Theorem
            <a href="./9-5.html#_32_hgi_">9.5.1</a>).
          </p>
        </li>
        <li>
          <p>
            Wenn
            <span style="font-variant:small-caps;">3-Colorability</span>
            in P, dann auch
            <span style="font-variant:small-caps;">3-SAT</span>(Theorem
            <a href="./9-5.html#_33_hgi_">9.5.2</a>).
          </p>
        </li>
        <li>
          <p>
            Wenn
            <span style="font-variant:small-caps;">3-SAT</span>
            in P, dann auch<span style="font-variant:small-caps;">CNF-Satisfiability</span>(Theorem
            <a href="./9-5.html#_34_hgi_">9.5.3</a>).
          </p>
        </li>
      </ul>
    </div>
    <p class="main-column">
      Beachten Sie, dass alle Beweise eine ähnliche Form
      haben: um die Aussage
      <i>wenn
        <span class="nowrap">$L_1 \in P$,</span>
        dann auch
        $L_2 \in P$</i>
      zu zeigen, nehmen wir eine beliebiges
      $x \in \Sigma_1$ (eine
      <span class="nowrap">$L_1$-Instanz)</span>
      und wandeln
      es um in ein $y \in \Sigma_2$ (eine
      <span class="nowrap">$L_2$-Instanz),</span>
      so dass
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      x \in L_1 \Longleftrightarrow y \in L_2
      \end{align*}
      $$
    </div>
    <p class="main-column">
      garantiert ist. Wenn es also einen effizienten Algorithmus
      <code>is_in_L2</code>
      gibt, dann können wir mit folgendem Code
      auch $L_1$ effizient entscheiden:
    </p>
    <div class="main-column">
<pre class="listing">
<span class="listing-bol"></span>def is_in_L1(x):
<span class="listing-bol"></span>    y = convert_from_L1_instance_to_L2_instance(x)
<span class="listing-bol"></span>    return is_in_L2(y)
</pre>
    </div>
    <p class="main-column">
      Dies ist eine
      <i>Reduktion</i>, wie wir sie schon in Definition
      <a href="./8-8.html#_24_hgi_">8.8.4</a>
      kennengelernt haben, nun aber
      mit einer Aussage über die Laufzeit.
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>9.5.4</b>
        <b>(Polynomialzeitreduktion)</b>. Seien
        $L_1 \subseteq \Sigma_1^*$ und
        $L_2 \subseteq \Sigma_2^*$ zwei Sprachen. Eine Funktion
        $f: \Sigma_1^* \rightarrow \Sigma_2^*$ heißt
        <i>Polynomialzeitreduktion
          von $L_1$ auf $L_2$</i>
        wenn
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \forall x \in \Sigma_1^*: \quad x \in L_1
        \Longleftrightarrow f(x) \in L_2
        \end{align*}
        $$
      </div>
      <p>
        und $f$ in Zeit $\poly(n)$ berechnet werden kann.
        Wenn es also ein Polynom $p: \N \rightarrow \N$ und
        eine Turingmaschine $M$ mit Eingabealphabet
        $\Sigma_1$ und Ausgabealphabet $\Sigma_2$ gibt, die
        Laufzeit $p$ hat und $f$ berechnet. Wir schreiben
        dann
        <span class="nowrap">$L_1 \leq_p L_2$.</span>
      </p>
    </div>
    <p class="main-column">
      Wenn wir eine Reduktion von $L_1$ auf $L_2$ haben
      und einen effizienten Algorithmus für
      <span class="nowrap">$L_2$,</span>
      dann
      können wir wie in
      <code>is_in_L1(x)</code>
      oben skizziert
      $L_1$ effizient entscheiden. Formal:
    </p>
    <div class="well statement out">
      <p>
        <b>Beobachtung</b>
        <b>9.5.5</b>
        Wenn $L_1 \leq_p L_2$ ist und
        <span class="nowrap">$L_2 \in {\rm P}$,</span>
        dann
        auch
        <span class="nowrap">$L_1 \in {\rm P}$.</span>
      </p>
    </div>
    <p class="main-column">
      Wir haben die folgenden Polynomialzeitreduktionen
      bereits kennengelernt:
    </p>
    <div class="main-column">
      <ol>
        <li>
          <p>
            <span style="font-variant:small-caps;">3-Colorability $\leq_p$ CNF-Satisfiability</span>
          </p>
        </li>
        <li>
          <p>
            <span style="font-variant:small-caps;">CNF-Satisfiability $\leq_p$ 3-SAT</span>
          </p>
        </li>
        <li>
          <p>
            <span style="font-variant:small-caps;">3-SAT $\leq_p$ 3-Colorability</span>
          </p>
        </li>
      </ol>
    </div>
    <p class="main-column">
      Erinnern Sie sich an
      <span style="font-variant:small-caps;">Independent Set</span>: gegeben ein Graph $G$ und eine Zahl
      <span class="nowrap">$k$,</span>
      gibt es
      eine unabhängige Menge $X \subseteq V$ mit
      <span class="nowrap">$|X| \geq k$?</span>
    </p>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>9.5.6</b>
        <span style="font-variant:small-caps;">3-SAT $\leq_p$ Independent Set</span>.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Gegeben sei eine 3-CNF-Formel $F$ mit
        $n$ Variablen und $m$ Klauseln. Wir bauen folgenden
        Graphen
        <span class="nowrap">$G$:</span>
      </p>
      <figure>
        <img
          style="height:20em"
          src="img/09-complexity-theory/sat-to-independent-set/3sat-to-IS.svg"
          class="constrained transition-all"
          onClick="onImgClick(event)"
        >
      </figure>
      <p>
        und setzen
        <span class="nowrap">$k:=n+m$.</span>
        Wir müssen nun folgendes zeigen:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        F \textnormal{ ist erfüllbar} \Longleftrightarrow
        G \textnormal{ hat eine unabhängige Menge der Größe $k$}
        \end{align*}
        $$
      </div>
      <p>
        Falls $\alpha$ eine erfüllende Belegung von $F$ ist,
        dann gibt es folgende unabhängige Menge der Größe
        <span class="nowrap">$k$:</span>
      </p>
      <ul>
        <li>
          <p>
            Für jede Variable $x$ nehmen wir $x$ in $I$ auf, falls
            $\alpha(x)=1$ ist, ansonsten
            <span class="nowrap">$\bar{x}$.</span>
          </p>
        </li>
        <li>
          <p>
            Für jede Klausel $C = (u \vee v \vee w)$ gibt es ein
            erfülltes Literal, sagen wir
            <span class="nowrap">$u$.</span>
            Dieser entspricht
            dem Klauselknoten
            <span class="nowrap">$u_C$,</span>
            der mit mit dem Literalknoten
            $\bar{u}$ verbunden. Da $\alpha(u) = 1$ und
            $\alpha(\bar{u}) = 0$ ist, ist $u \not \in I$ und
            wir können $u_C$ in $I$ aufnehmen.
          </p>
        </li>
        <li>
          <p>
            Unsere Menge $I$ enthält $n$ Literalknoten und $m$
            Klauselknoten, also insgesamt $k$ Knoten.
          </p>
        </li>
      </ul>
      <p>
        Für die Gegenrichtung nehmen wir an, dass $I$ eine
        unabhängige Menge von $G$ ist und $|I| = n+m$ gilt.
        Da $I$ pro Literalpaar und pro Klauseldreieck höchstens
        einen Knoten enthalten kann, enthält $I$
        <i>genau</i>
        einen
        pro Literalpaar und Klauseldreieck. Wir definieren
        nun eine Belegung $\alpha$ wie folgt: wenn für eine
        Variable $x$ der Literalknoten $x$ in $I$ ist, setzen
        wir
        <span class="nowrap">$\alpha(x)=1$;</span>
        falls $\bar{x}$ in $I$ ist, setzen
        wir
        <span class="nowrap">$\alpha(x)=0$.</span>
        Wir behaupten nun, dass
        $\alpha$ die Formel $F$ erfüllt. Sei
        $C= (u \vee v \vee w)$ eine beliebige Klausel von
        <span class="nowrap">$F$.</span>
        Nach obiger Überlegung enthält $I$ genau einen
        Klauselknoten von
        <span class="nowrap">$C$,</span>
        sagen wir
        <span class="nowrap">$u_C$.</span>
        Das heißt
        somit, dass der Literalknoten $\bar{u}$ nicht in
        $I$ ist - sonst wäre $I$ ja nicht unabhängig. Somit
        muss $u \in I$ gelten und
        <span class="nowrap">$\alpha(u) = 1$,</span>
        und
        $\alpha$ erfüllt
        <span class="nowrap">$C$.</span><span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Übungsaufgabe</b>
        <b>9.5.7</b>
        Zeigen Sie
        <span style="font-variant:small-caps;">Independent Set $\leq_p$ SAT</span>. Also: Gegeben einen Graphen $G$ und eine Zahl
        <span class="nowrap">$k \in \N$,</span>
        zeigen Sie, wie man die Aussage
        <i>$G$ hat
          eine unabhängige Menge der Größe $k$</i>
        als aussagenlogische
        Formel in CNF darstellen kann.
        <b>Hinweis:</b>
        Die Aussage
        <i><span class="nowrap">"$I$</span>
          ist eine unabhängige Menge von $G$</i>
        ist leicht
        darzustellen als CNF-Formeln. Die Aussage
        <i><span class="nowrap">"$I$</span>
          hat
          Größe
          <span class="nowrap">$k$"</span></i>
        ist schwieriger. Sie müssen quasi
        <i>zählen</i>.
      </p>
    </div>
    <h2 class="main-column">
      <span style="font-variant:small-caps;">Hamilton Path</span>und
      <span style="font-variant:small-caps;">Hamilton Cycle</span>
    </h2>
    <p class="main-column">
      Sei $G = (V,E)$ ein Graph. Ein
      <i>Hamiltonscher Kreis</i>
      ist ein Kreis, der durch alle Knoten geht. Es muss
      ein
      <i>Kreis</i>
      sein; Kantenzüge, die einen Knoten mehrmals
      durchlaufen, sind also nicht erlaubt. Hier sehen Sie
      einen Graphen mit Hamiltonschem Kreis:
    </p>
    <div class="carousel__container main-column">
      <div class="carousel">
        <div class="carousel__items">
          <div class="carousel__item">
            <p>
              <img
                src="img/09-complexity-theory/hamilton-path-and-cycle/hamilton-01-01.svg"
                style="height: 20em;"
              >
            </p>
          </div>
          <div class="carousel__item">
            <p>
              <img
                src="img/09-complexity-theory/hamilton-path-and-cycle/hamilton-01-02.svg"
                style="height: 20em;"
              >
            </p>
          </div>
        </div>
      </div>
    </div>
    <p class="main-column">
      Ein
      <i>Hamiltonscher Pfad</i>
      ist ein Pfad mit $|V|$ Knoten.
      Auch hier gilt: kein Knoten darf mehrfach besucht werden.
      Der untere Graph, der
      <i>Petersen-Graph</i>, hat keinen
      Hamiltonschen Kreis, dafür aber einen Hamiltonschen
      Pfad:
    </p>
    <figure class="main-column">
      <img
        style="height:20em"
        src="img/09-complexity-theory/hamilton-path-and-cycle/hamilton-02-01.svg"
        class="constrained transition-all"
        onClick="onImgClick(event)"
      >
    </figure>
    <p class="main-column">
      Wir definieren nun die zwei entsprechenden Entscheidungsprobleme:
    </p>
    <div class="well statement out">
      <p>
        <b>Problem</b>
        <b>9.5.8</b>
        <span style="font-variant:small-caps;">(Hamilton Cycle).</span>
        Gegeben ein Graph
        <span class="nowrap">$G=(V,E)$,</span>
        gibt es in $G$ einen
        Kreis der Länge
        <span class="nowrap">$|V|$,</span>
        der also durch alle Knoten
        geht?
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Problem</b>
        <b>9.5.9</b>
        <span style="font-variant:small-caps;">(Hamilton Path).</span>
        Gegeben ein Graph
        <span class="nowrap">$G=(V,E)$,</span>
        gibt es in $G$ einen
        Pfad der Länge
        <span class="nowrap">$|V|-1$,</span>
        der also alle $|V|$ Knoten
        enthält?
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>9.5.10</b>
        <span style="font-variant:small-caps;">Hamilton Cycle $\leq_p$ Hamilton Path</span>
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>(Falscher) Beweis.</b>
        Tasten wir uns langsam heran.
        Wir stellen uns vor, eine Bibliotheksfunktion
        <code>has_hamilton_path(G)</code>
        zu haben und wollen mithilfe dieser eine neue Funktion
        <code>has_hamilton_cycle(G)</code>
        schreiben. Sei $u$ ein beliebiger
        Knoten. Wir wissen: wenn $G$ einen Hamiltonschen Kreis
        hat, dann besucht dieser auch $u$ und im Anschluss
        einen Nachbarnknoten
        <span class="nowrap">$v$,</span>
        also mit
        <span class="nowrap">$\{u,v\} \in E$.</span>
        Der Graph
        <span class="nowrap">$G' := G - \{u,v\}$,</span>
        in welchem wir diese
        Kante löschen, besitzt somit einen Hamiltonschen Pfad.
        Allerdings kann es sein, dass $G'$ sowieso einen Hamiltonschen
        Pfad besitzt, der allerdings nicht $u$ und $v$ als
        Endknoten hat, so dass er sich mit $\{u,v\}$ nicht
        zu einem Hamiltonschen Kreis schließt. Wir müssen irgendwie
        die Frage beantworten können: besitzt $G'$ einen Hamiltonschen
        Pfad, der $u$ und $v$ als Start- bzw. Endknoten hat?
        Dies ist einfach: wir können neue Knoten $s$ und
        $t$ und die Kanten $\{s,u\}$ und $\{t,v\}$ einführen.
        Da $s$ und $t$ nun Grad $1$ haben, muss ein Hamiltonscher
        Pfad, wenn er denn existiert, $u$ und $v$ als Endknoten
        haben. Sei also
        <span class="nowrap">$G'' := G' + \{s,u\} + \{t,v\}$.</span>
      </p>
      <div class="well container-fluid subtheorem">
        <p>
          <b>Beobachtung:</b>
          $G$ hat genau dann einen Hamiltonschen
          Kreis durch die Kante
          <span class="nowrap">$\{u,v\}$,</span>
          wenn $G''$ einen
          Hamiltonschen Pfad hat.
        </p>
      </div>
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <p>
                <img
                  src="img/09-complexity-theory/hamilton-path-and-cycle/hamilton-03-01.svg"
                  style="height: 20em;"
                >
              </p>
            </div>
            <div class="carousel__item">
              <p>
                <img
                  src="img/09-complexity-theory/hamilton-path-and-cycle/hamilton-03-02.svg"
                  style="height: 20em;"
                >
              </p>
            </div>
          </div>
        </div>
      </div>
      <p>
        Woher wollen wir allerdings wissen, ob der Kreis in
        $G$ (wenn es ihn denn gibt) überhaupt durch
        $\{u,v\}$ geht? Vielleicht gibt es ja einen, aber
        keinen durch
        <span class="nowrap">$\{u,v\}$,</span>
        so dass dann
        <code>has_hamilton_path(
          <span class="nowrap">$G''$)</span></code>
        mit
        <code>False</code>
        antwortet, obwohl wir gerne ein
        <code>True</code>
        hätten. Um das zu verhindern, können wir ja
        <i>alle</i>
        Nachbarn von $u$ durchprobieren. Wenn einer
        klappt, dann haben wir unseren Kreis; wenn es überhaupt
        einen Kreis gibt, dann klappt es auch mit einem Nachbarn
        (in der Tat: sogar mit zweien).
      </p>
<pre
  class="listing"
  language=""
>
<span class="listing-bol"></span>def has_hamilton_cycle(G):
<span class="listing-bol"></span>    u = ein beliebiger Knoten
<span class="listing-bol"></span>    for v in neighbors[u]:
<span class="listing-bol"></span>    H = G - {u,v} + {s,u} + {t,v}
<span class="listing-bol"></span>    if has_hamilton_path(H):
<span class="listing-bol"></span>    return True
<span class="listing-bol"></span>    return False
</pre>
      <p>
        Falls nun
        <code>has_hamilton_path</code>
        polynomielle Laufzeit
        $O(n^k)$ hat, so hat
        <code>has_hamilton_cycle</code>
        eine Laufzeit
        von
        <span class="nowrap">$O(n^{k+1})$,</span>
        auch polynomiell.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p class="main-column">
      Was ist nun an diesem Beweis falsch? Nun, der Begriff
      der Reduktion, dem wir uns ja mit der Notation
      $\leq_p$ verpflichten, verlangt, dass wir auf Eingabe
      $G$
      <i>einen</i>
      Graphen $G'$ bauen, mit der Eigenschaft,
      dass $G$ genau dann einen Hamiltonschen Kreis hat,
      wenn $G'$ einen Hamiltonschen Pfad hat. Uns steht
      also genau
      <i>ein</i>
      Aufruf von
      <code>has_hamilton_path</code>
      zu.
      Aber ganz wertlos ist der obige Beweis dennoch nicht,
      zeigt er doch, dass, falls
      <span style="font-variant:small-caps;">Hamilton Path $\in$ P</span>
      ist, dann auch
      <span style="font-variant:small-caps;">Hamilton Cycle $\in$ P</span>. Der Fachbegriff für das, was unsere obige Funktion
      <code>has_hamilton_cycle</code>
      tut, nennt sich
      <i>Cook-Reduktion</i>,
      nach Stephen Cook, einem der Väter der Klasse NP. Eine
      Reduktion, die dem strengen Reduktionsbegriff folgt,
      also
      <span
        data-ref="definition-polynomial-reduction"
        class="reference"
      ></span>, nennt man in Abgrenzung dazu
      <i>Karp-Reduktion</i>
      nach
      Richard Karp, ein weiterer NP-Vater.
    </p>
    <div class="well statement out">
      <p>
        <b>Übungsaufgabe</b>
        <b>9.5.11</b>
        Geben Sie einen "richtigen" Beweis für<span
          data-ref="theorem-ham-cycle-to-path"
          class="reference"
        ></span>, also eine Karp-Reduktion.
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Übungsaufgabe</b>
        <b>9.5.12</b>
        Zeigen Sie
        <span style="font-variant:small-caps;">Hamilton Path $\leq_p$ Hamilton Cycle</span>. Wenn es Ihnen einfacher scheint, geben Sie erst
        einmal eine Cook-Reduktion.
      </p>
    </div>
  </div>
</body>
</html>
