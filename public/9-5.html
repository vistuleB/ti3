<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
  <meta name="description" content="Section 9.5 of TI3 - Theoretische Informatik 2">
  <link rel="stylesheet" type="text/css" href="app.css" />
  <script type="text/javascript" src="./mathjax_setup.js"></script>
  <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
  <script type="text/javascript" src="./app.js"></script>
  <title>TI3 - Chapter 9, Section 5</title>
</head>
<body>
  <div class="body-wrapper">
    <div id="menu">
      <div class="menu-left">
        <a href="./index.html"><span class="inhalts_arrows">&lt;&lt;
          </span>Inhaltsverzeichnis</a><a
          id="prev-page"
          href="./9-4.html"
        >&lt;&lt; Kapitel 9.4<span
            style="visibility:hidden"
            id="prev-page-tooltip"
          >
            <p>
              Viele Beispiele aus NP
            </p>
          </span></a>
      </div>
      <div class="menu-right">
        <a href="https://www.tu-chemnitz.de/informatik/theoretische-informatik/TI-2/index.html.en">zür Kursübersicht</a><a
          id="next-page"
          href="./9-6.html"
        >Kapitel 9.6 &gt;&gt;<span
            style="visibility:hidden"
            id="next-page-tooltip"
          >
            <p>
              Ganz NP reduziert auf SAT: das Cook-Levin-Theorem
            </p>
          </span></a>
      </div>
    </div>
    <div class="main-column page-title">
      <p>
        9.5&ensp;Reduktionen
      </p>
    </div>
    <p class="main-column">
      <span class="sc">3-Colorability</span>
      und
      <span class="sc">CNF-Satisfiability</span>
      sind in NP:
      gegeben ein Graph $G$ und eine Färbung $c$ , so können wir
      effizient feststellen, ob $c$ eine gültige 3-Färbung von $G$
      darstellt; gegeben eine CNF-Formel $F$ und eine Belegung
      <span class="nowrap">$\alpha$,</span>
      so können wir effizient überprüfen, ob $F$ unter $\alpha$ zu
      <code>True</code>
      auswertet. Können wir
      <span class="sc">3-Colorability</span>
      und<span class="sc">CNF-Satisfiability</span>
      auch effizient entscheiden? Sind sie in
      P? Das ist (Stand: 2025) nicht bekannt. Was wir aber sagen können:
      entweder sind beide effizient lösbar oder beide nicht. Sie sind
      gewissermaßen gleich schwer.
    </p>
    <div
      id="_44_hgi_"
      class="well statement out"
    >
      <p>
        <b>Theorem</b>
        <b>9.5.1</b>
        Falls
        <span class="sc">CNF-Satisfiability</span>
        in P ist, dann auch
        <span class="sc">3-Colorability</span>.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Wir nehmen an, wir hätten einen effizienten
        AlgorithmUs
        <span class="nowrap"><code>is_satisfiable(
            <span class="nowrap">$F$)</span></code>.</span>
        Wir verwenden diesen, um
        einen Algorithmus
        <code>is_3_colorable</code>
        zu entwerfen. Sei nun
        $G = (V,E)$ ein Graph und $v_1, \dots, v_n$ seine Knoten. Wir
        führen $3n$ Boolesche Variable ein:
        <span class="nowrap">$r_1, \dots, r_n, g_1, \dots, g_n, b_1, \dots, b_n$.</span>
        Die
        Intention hierbei ist, dass $r_i$ anzeigt, ob $v_i$ rot ist und
        so weiter. Wir müssen jetzt Klauseln erschaffen, die die Aussage
        "das ist eine gültige 3-Färbung" als CNF-Formel codieren. Wir
        erschaffen folgende Klauseln:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        &amp;(r_i \vee g_i \vee b_i) \tag{$v_i$ hat mindestens eine Farbe}\\
        &amp;(\bar{r}_i \vee \bar{g}_i) \wedge (\bar{r}_i \vee \bar{b}_i)
        \wedge (\bar{g}_i \vee \bar{b}_i) \tag{$v_i$ hat nicht zwei Farben gleichzeitig}
        \end{align*}
        $$
      </div>
      <p>
        Dies tun wir für jedes
        <span class="nowrap">$i$.</span>
        Wir sehen nun: jede Belegung, die
        die obigen Klauseln erfüllt, entspricht einer $3$ -Färbung
        <span class="nowrap">$c: V \rightarrow \{1,2,3\}$,</span>
        und umgekehrt. Nun müssen wir die
        Aussage
        <i>Kante $\{v_i,v_j\}$ ist gültig gefärbt</i>
        formulieren:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        &amp;(\bar{r}_i \vee \bar{r}_j) \tag{$v_i$ und $v_j$ sind nicht beide rot}\\
        &amp;(\bar{g}_i \vee \bar{g}_j) \tag{$v_i$ und $v_j$ sind nicht beide grün}\\
        &amp;(\bar{b}_i \vee \bar{b}_j) \tag{$v_i$ und $v_j$ sind nicht beide blau}\\
        \end{align*}
        $$
      </div>
      <p>
        und dann alles zusammenwerfen:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        F:=&amp;\quad \bigwedge_{i=1}^n \left( (r_i \vee g_i \vee b_i) \wedge(\bar{r}_i \vee \bar{g}_i)
        \wedge
        (\bar{r}_i \vee \bar{b}_i)
        \wedge (\bar{g}_i \vee \bar{b}_i) \right) \wedge \\
        &amp;\bigwedge_{\{v_i, v_j\} \in E} \left(
        (\bar{r}_i \vee \bar{r}_j) \wedge
        (\bar{g}_i \vee \bar{g}_j) \wedge
        (\bar{b}_i \vee \bar{b}_j)
        \right)
        \end{align*}
        $$
      </div>
      <p>
        Es gilt nun: $G$ ist genau dann
        <span class="nowrap">$3$-färbbar,</span>
        wenn $F$ erfüllbar
        ist. Und hier ist nun unser Code für
        <code>is_3_colorable:</code>
      </p>
      <p>
<pre class="listing orange-comments">
<span class="listing-bol"></span>def is_3_colorable(graph):
<span class="listing-bol"></span>    F = convert_to_CNF_formula(graph)
<span class="listing-bol"></span>    <span class="actual-orange-comment"># F ist die oben beschriebene Formel mit 3n Variablen</span>
<span class="listing-bol"></span>    return is_satisfiable(F)
</pre>
      </p>
      <p>
        Falls Ihnen eine Funktion
        <code>find_satisying_assignment</code>
        zur
        Verfügung steht, so können Sie natürlich die erfüllende Belegung
        direkt in eine gültige 3-Färbung übersetzen.
        <span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p class="main-column">
      Das ging recht schnell und direkt, weil die Aussagenlogik
      allgemein genug ist, um Aussagen über endliche Objekte (hier:
      Graphen) effizient zu codieren. Geht es auch andersrum? Wenn uns
      eine Funktion
      <code>is_3_colorable</code>
      zur Verfügung steht, können wir dann
      auch eine Funktion
      <code>is_satisfiable</code>
      schreiben? Wir machen einen
      Zwischenschritt und schreiben mithilfe von
      <code>is_3_colorable</code>
      einen
      effizienten Algorithmus für
      <span class="nowrap">$3$-SAT;</span>
      dies ist
      <span class="sc">CNF-Satisfiability</span>
      mit der Einschränkung, dass $F$ eine $3$
      -CNF-Formel ist, dass also jede Klausel nur drei Literale enthält.
      Beachten Sie, dass die Formel
      <span class="nowrap">$F$,</span>
      die wir im Beweis von
      <a
        href="./9-5.html#_44_hgi_"
        class=""
      >Theorem 9.5.1</a>
      erstellt haben, eine solche 3-CNF ist.
    </p>
    <div
      id="_45_hgi_"
      class="well statement out"
    >
      <p>
        <b>Theorem</b>
        <b>9.5.2</b>
        Falls
        <span class="sc">3-Colorability</span>
        in P ist, dann auch<span class="sc">3-SAT</span>.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Wir gehen konzeptuell ähnlich vor wie oben. Uns ist
        eine 3-CNF-Formel $F$ gegeben. Wir müssen jetzt einen Graphen
        $G = (V,E)$ bauen, der die Aussage
        <i>$F$ ist erfüllbar</i>
        irgendwie
        in seiner 3-Färbbarkeit oder eben Nicht-3-Färbbarkeit codiert.
        Dies ist schwieriger. Als ersten Schritt legen wir fest, dass die
        drei Farben nicht
        <span class="nowrap">$1$,</span>
        <span class="nowrap">$2$,</span>
      </p>
      <p>
        $3$ sein sollen, sondern
        <span class="nowrap"><code>True</code>,</span>
        <span class="nowrap"><code>False</code>,</span>
        <span class="nowrap"><code>Neutral</code>.</span>
      </p>
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-01.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-02.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-03.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-04.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-05.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-06.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-07.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-08.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-09.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-10.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-11.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-12.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-13.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-14.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-15.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-16.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-17.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-18.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-19.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-20.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-21.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-22.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-23.svg">
            </div>
            <div class="carousel__item">
              <img src="img/09-complexity-theory/sat-to-col/sat-to-col-01-24.svg">
            </div>
          </div>
        </div>
      </div>
      <p>
        Wir wiederholen die beschriebene Konstruktion für jede Klausel
        in
        <span class="nowrap">$F$.</span>
        Wir erhalten einen Graphen
        <span class="nowrap">$G$,</span>
        der genau dann
        <span class="nowrap">$3$-färbbar</span>
        ist, wenn $F$ erfüllbar ist. Auch können wir direkt
        eine gültige
        <span class="nowrap">$3$-Färbung</span>
        in eine erfüllende Belegung übersetzen
        und umgekehrt. Hier ist also der Code:
      </p>
      <p>
<pre class="listing orange-comments">
<span class="listing-bol"></span>def is_3CNF_satisfiable(the_3_cnf_formula):
<span class="listing-bol"></span>    G = cOnvert_to_graph(the_3_cnf_formula)
<span class="listing-bol"></span>    <span class="actual-orange-comment"># G ist der oben konstruierte Graph</span>
<span class="listing-bol"></span>    return is_3_colorable(G)
</pre>
      </p>
      <p>
        <span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p class="main-column">
      Wir haben also gezeigt, wie man eine
      <span class="nowrap">$3$-CNF</span>
      $F$ in einen Graphen
      $G$ umwandelt, so dass
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      F \textnormal{ ist erfüllbar } \Longleftrightarrow G \textnormal{ ist $3$-färbbar}
      \end{align*}
      $$
    </div>
    <p class="main-column">
      gilt. Allerdings ging das nur unter der Annahme, dass $F$ eine $3$
      -CNF ist. Wie verhält es sich, wenn $F$ eine allgemeine CNF-Formel
      ist?
    </p>
    <div
      id="_46_hgi_"
      class="well statement out"
    >
      <p>
        <b>Theorem</b>
        <b>9.5.3</b>
        Es gibt einen effizienten Algorithmus, der als Input eine
        CNF-Formel $F$ nimmt und eine 3-CNF-Formel $F'$ ausgibt, so dass
        gilt:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        F \textnormal{ ist erfüllbar } \Longleftrightarrow F' \textnormal{ ist erfüllbar } \ .
        \end{align*}
        $$
      </div>
      <p>
        Falls es einen effizienten Algorithmus für $3$ -SAT gibt, dann
        also auch einen für CNF-SAT.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Wir starten mit $F_0 := F$ und definieren eine Folge
        $F_0, F_1, \dots$ von CNF-Formeln. Sei $F_i$ die derzeit letzte
        erzeugte CNF-Formel. Falls $F_i$ eine Klausel $C$ mit vier oder
        mehr Literalen enthält, führen wir eine Operation durch, die $C$
        durch zwei neue, kleinere Klauseln ersetzt: sei
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        C = (u_1 \vee u_2 \vee u_3 \vee u_4 \vee \dots \vee u_k)
        \end{align*}
        $$
      </div>
      <p>
        mit
        <span class="nowrap">$k \geq 4$.</span>
        Wir führen eine neue, bisher nicht verwendete
        Variable $z$ ein und erschaffen die Klauseln
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        C_1 := (\bar{z} \vee u_1 \vee u_2) \\
        C_2 := (z \vee u_3 \vee \dots \vee u_k)
        \end{align*}
        $$
      </div>
      <p>
        Wir entfernen nun $C$ und fügen $C_1$ und $C_2$ ein und erhalten
        eine neue CNF-Formel
        <span class="nowrap">$F_{i+1}$.</span>
        Wir sehen nun: wenn $\alpha$ die
        Formel $F_{i+1}$ erfüllt, dann erfüllt sie auch
        <span class="nowrap">$F_i$;</span>
        umgekehrt
        wenn die Belegung $\beta$ die Formel $F_i$ erfüllt, dann erfüllt
        $\beta$ insbesondere
        <span class="nowrap">$C$;</span>
        wir bauen nun eine neue Belegung, die
        auch $z$ einen Wert zuweist und dann $C_1$ und $C_2$ erfüllt:
        falls (1) $\beta$ die Klausel $(u_1 \vee u_2)$ erfüllt, dann
        setzen wir $z$ auf
        <span class="nowrap">$1$,</span>
        also
        <span class="nowrap">$\alpha := \beta \cup [z \mapsto 1]$.</span>
        Die Belegung $\alpha$
        erfüllt nun
        <span class="nowrap">$C_1$,</span>
        weil $\beta$ das bereits tut, und
        <span class="nowrap">$C_2$,</span>
        weil
        $\alpha(z)=1$ ist; falls jedoch (2) $\beta$ die Klausel
        $(u_1 \vee u_2)$ nicht erfüllt, dann muss sie, da sie ja $C$
        erfüllt, die Klausel $(u_3 \vee \dots \vee u_k)$ erfüllen und
        erfüllt somit
        <span class="nowrap">$C_2$,</span>
        auch ohne Verwendung von
        <span class="nowrap">$z$.</span>
        Wir setzen
        nun $z$ auf
        <span class="nowrap">$0$,</span>
        also $\alpha := \beta \cup [z \mapsto 0]$ und
        erfüllen sowohl $C_1$ als auch
        <span class="nowrap">$C_2$.</span>
        Alle anderen Klauseln sind
        sowieso erfüllt, weil $\beta$ sie bereits erfüllt. Wir sehen:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        F_i \textnormal{ ist erfüllbar } \Longleftrightarrow F_{i+1} \textnormal{ ist erfüllbar } \ .
        \end{align*}
        $$
      </div>
      <p>
        Die beiden neuen Klauseln $C_1$ und $C_2$ sind jeweils echt
        kleiner als
        <span class="nowrap">$C$.</span>
        Der Prozess endet irgendwann mit einer Formel
        <span class="nowrap">$F_t$,</span>
        in der jede Klausel höchstens drei Literale hat. Dies ist
        unser
        <span class="nowrap">$F'$.</span><span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p class="main-column">
      Wir haben nun also eine Kette von Implikationen erschaffen:
    </p>
    <div class="main-column">
      <ul>
        <li>
          <p>
            Wenn
            <span class="sc">CNF-Satisfiability</span>
            in P, dann auch
            <span class="sc">3-Colorability</span>(Theorem
            <a href="./9-5.html#_44_hgi_">9.5.1</a>).
          </p>
        </li>
        <li>
          <p>
            Wenn
            <span class="sc">3-Colorability</span>
            in P, dann auch
            <span class="sc">3-SAT</span>(Theorem
            <a href="./9-5.html#_45_hgi_">9.5.2</a>).
          </p>
        </li>
        <li>
          <p>
            Wenn
            <span class="sc">3-SAT</span>
            in P, dann
            auch<span class="sc">CNF-Satisfiability</span>(Theorem
            <a href="./9-5.html#_46_hgi_">9.5.3</a>).
          </p>
        </li>
      </ul>
    </div>
    <p class="main-column">
      Beachten Sie, dass alle Beweise eine ähnliche Form haben: um die
      Aussage
      <i>wenn
        <span class="nowrap">$L_1 \in P$,</span>
        dann auch $L_2 \in P$</i>
      zu zeigen,
      nehmen wir eine beliebiges $x \in \Sigma_1$ (eine
      <span class="nowrap">$L_1$-Instanz)</span>
      und wandeln es um in ein $y \in \Sigma_2$ (eine
      <span class="nowrap">$L_2$-Instanz),</span>
      so
      dass
    </p>
    <div class="math-block main-column">
      $$
      \begin{align*}
      x \in L_1 \Longleftrightarrow y \in L_2
      \end{align*}
      $$
    </div>
    <p class="main-column">
      garantiert ist. Wenn es also einen effizienten Algorithmus
      <code>is_in_L2</code>
      gibt, dann können wir mit folgendem Code auch $L_1$
      effizient entscheiden:
    </p>
    <div class="main-column">
<pre class="listing">
<span class="listing-bol"></span>def is_in_L1(x):
<span class="listing-bol"></span>    y = convert_from_L1_instance_to_L2_instance(x)
<span class="listing-bol"></span>    return is_in_L2(y)
</pre>
    </div>
    <p class="main-column">
      Dies ist eine
      <span class="nowrap"><i>Reduktion</i>,</span>
      wie wir sie schon in
      <a
        href="./8-8.html#_35_hgi_"
        class=""
      >Definition 8.8.4</a>
      kennengelernt haben, nun aber mit einer
      Aussage über die Laufzeit.
    </p>
    <div class="well statement out">
      <p>
        <b>Definition</b>
        <b>9.5.4</b>
        <span class="nowrap"><b>(Polynomialzeitreduktion)</b>.</span>
        Seien $L_1 \subseteq \Sigma_1^*$
        und $L_2 \subseteq \Sigma_2^*$ zwei Sprachen. Eine Funktion
        $f: \Sigma_1^* \rightarrow \Sigma_2^*$ heißt
        _Polynomialzeitreduktion von $L_1$ auf $L_2$ _ wenn
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        \forall x \in \Sigma_1^*: \quad x \in L_1
        \Longleftrightarrow f(x) \in L_2
        \end{align*}
        $$
      </div>
      <p>
        und $f$ in Zeit $\poly(n)$ berechnet werden kann. Wenn es also
        ein Polynom $p: \N \rightarrow \N$ und eine Turingmaschine $M$
        mit Eingabealphabet $\Sigma_1$ und Ausgabealphabet $\Sigma_2$
        gibt, die Laufzeit $p$ hat und $f$ berechnet. Wir schreiben dann
        <span class="nowrap">$L_1 \leq_p L_2$.</span>
      </p>
    </div>
    <p class="main-column">
      Wenn wir eine Reduktion von $L_1$ auf $L_2$ haben und einen
      effizienten Algorithmus für
      <span class="nowrap">$L_2$,</span>
      dann können wir wie in
      <code>is_in_L1(x)</code>
      oben skizziert $L_1$ effizient entscheiden. Formal:
    </p>
    <div class="well statement out">
      <p>
        <b>Beobachtung</b>
        <b>9.5.5</b>
        Wenn $L_1 \leq_p L_2$ ist und
        <span class="nowrap">$L_2 \in {\rm P}$,</span>
        dann auch
        <span class="nowrap">$L_1 \in {\rm P}$.</span>
      </p>
    </div>
    <p class="main-column">
      Wir haben die folgenden Polynomialzeitreduktionen bereits
      kennengelernt:
    </p>
    <div class="main-column">
      <ol>
        <li>
          <p>
            <span class="sc">3-Colorability $\leq_p$ CNF-Satisfiability</span>
          </p>
        </li>
        <li>
          <p>
            <span class="sc">CNF-Satisfiability $\leq_p$ 3-SAT</span>
          </p>
        </li>
        <li>
          <p>
            <span class="sc">3-SAT $\leq_p$ 3-Colorability</span>
          </p>
        </li>
      </ol>
    </div>
    <p class="main-column">
      Erinnern Sie sich an
      <span class="sc">Independent Set</span>: gegeben ein Graph $G$
      und eine Zahl
      <span class="nowrap">$k$,</span>
      gibt es eine unabhängige Menge $X \subseteq V$
      mit
      <span class="nowrap">$|X| \geq k$?</span>
    </p>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>9.5.6</b>
        <span class="sc">3-SAT $\leq_p$ Independent Set</span>.
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>Beweis.</b>
        Gegeben sei eine 3-CNF-Formel $F$ mit $n$ Variablen
        und $m$ Klauseln. Wir bauen folgenden Graphen
        <span class="nowrap">$G$:</span>
      </p>
      <div class="figure__container">
        <figure>
          <img
            style="height:20em"
            src="img/09-complexity-theory/sat-to-independent-set/3sat-to-IS.svg"
          >
        </figure>
      </div>
      <p>
        und setzen
        <span class="nowrap">$k:=n+m$.</span>
        Wir müssen nun folgendes zeigen:
      </p>
      <div class="math-block">
        $$
        \begin{align*}
        F \textnormal{ ist erfüllbar} \Longleftrightarrow
        G \textnormal{ hat eine unabhängige Menge der Größe $k$}
        \end{align*}
        $$
      </div>
      <p>
        Falls $\alpha$ eine erfüllende Belegung von $F$ ist, dann gibt
        es folgende unabhängige Menge der Größe
        <span class="nowrap">$k$:</span>
      </p>
      <ul>
        <li>
          <p>
            Für jede Variable $x$ nehmen wir $x$ in $I$ auf, falls
            $\alpha(x)=1$ ist, ansonsten
            <span class="nowrap">$\bar{x}$.</span>
          </p>
        </li>
        <li>
          <p>
            Für jede Klausel $C = (u \vee v \vee w)$ gibt es ein
            erfülltes Literal, sagen wir
            <span class="nowrap">$u$.</span>
            Dieser entspricht dem
            Klauselknoten
            <span class="nowrap">$u_C$,</span>
            der mit mit dem Literalknoten $\bar{u}$
            verbunden. Da $\alpha(u) = 1$ und $\alpha(\bar{u}) = 0$ ist,
            ist $u \not \in I$ und wir können $u_C$ in $I$ aufnehmen.
          </p>
        </li>
        <li>
          <p>
            Unsere Menge $I$ enthält $n$ Literalknoten und $m$
            Klauselknoten, also insgesamt $k$ Knoten.
          </p>
        </li>
      </ul>
      <p>
        Für die Gegenrichtung nehmen wir an, dass $I$ eine unabhängige
        Menge von $G$ ist und $|I| = n+m$ gilt. Da $I$ pro Literalpaar
        und pro Klauseldreieck höchstens einen Knoten enthalten kann,
        enthält $I$
        <i>genau</i>
        einen pro Literalpaar und Klauseldreieck.
        Wir definieren nun eine Belegung $\alpha$ wie folgt: wenn für
        eine Variable $x$ der Literalknoten $x$ in $I$ ist, setzen wir
        <span class="nowrap">$\alpha(x)=1$;</span>
        falls $\bar{x}$ in $I$ ist, setzen wir
        <span class="nowrap">$\alpha(x)=0$.</span>
        Wir behaupten nun, dass $\alpha$ die Formel $F$
        erfüllt. Sei $C= (u \vee v \vee w)$ eine beliebige Klausel von
        <span class="nowrap">$F$.</span>
        Nach obiger Überlegung enthält $I$ genau einen
        Klauselknoten von
        <span class="nowrap">$C$,</span>
        sagen wir $u_C$ . Das heißt somit, dass
        der Literalknoten $\bar{u}$ nicht in $I$ ist - sonst wäre $I$ ja
        nicht unabhängig. Somit muss $u \in I$ gelten und
        <span class="nowrap">$\alpha(u) = 1$,</span>
        und $\alpha$ erfüllt $C$ .<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Übungsaufgabe</b>
        <b>9.5.7</b>
        Zeigen Sie
        <span class="sc">Independent Set $\leq_p$ SAT</span>. Also: Gegeben
        einen Graphen $G$ und eine Zahl
        <span class="nowrap">$k \in \N$,</span>
        zeigen Sie, wie man
        die Aussage
        <i>$G$ hat eine unabhängige Menge der Größe $k$</i>
        als
        aussagenlogische Formel in CNF darstellen kann.
      </p>
      <p>
        <b>Hinweis:</b>
        Die Aussage
        <i><span class="nowrap">"$I$</span>
          ist eine unabhängige Menge von $G$</i>
        ist leicht darzustellen als CNF-Formeln. Die Aussage
        <i>" $I$ hat
          Größe
          <span class="nowrap">$k$"</span></i>
        ist schwieriger. Sie müssen quasi
        <span class="nowrap"><i>zählen</i>.</span>
      </p>
    </div>
    <h3 class="main-column subtopic-announcement">
      <span class="sc">Hamilton Path</span>und
      <span class="sc">Hamilton Cycle</span>
    </h3>
    <p class="main-column">
      Sei $G = (V,E)$ ein Graph. Ein
      <i>Hamiltonscher Kreis</i>
      ist ein
      Kreis, der durch alle Knoten geht. Es muss ein
      <i>Kreis</i>
      sein;
      Kantenzüge, die einen Knoten mehrmals durchlaufen, sind also nicht
      erlaubt. Hier sehen Sie einen Graphen mit Hamiltonschem Kreis:
    </p>
    <div class="pseudowell">
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img
                style="height:20em"
                src="img/09-complexity-theory/hamilton-path-and-cycle/hamilton-01-01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:20em"
                src="img/09-complexity-theory/hamilton-path-and-cycle/hamilton-01-02.svg"
              >
            </div>
          </div>
        </div>
      </div>
    </div>
    <p class="main-column">
      Ein
      <i>Hamiltonscher Pfad</i>
      ist ein Pfad mit $|V|$ Knoten. Auch hier
      gilt: kein Knoten darf mehrfach besucht werden. Der untere Graph,
      der
      <span class="nowrap"><i>Petersen-Graph</i>,</span>
      hat keinen Hamiltonschen Kreis, dafür aber
      einen Hamiltonschen Pfad:
    </p>
    <div class="pseudowell">
      <figure>
        <img
          style="height:20em"
          src="img/09-complexity-theory/hamilton-path-and-cycle/hamilton-02-01.svg"
        >
      </figure>
    </div>
    <p class="main-column">
      Wir definieren nun die zwei entsprechenden Entscheidungsprobleme:
    </p>
    <div class="well statement out">
      <p>
        <b>Problem</b>
        <b>9.5.8</b>
        <span class="sc">(Hamilton Cycle).</span>
        Gegeben ein Graph
        <span class="nowrap">$G=(V,E)$,</span>
        gibt es in
        $G$ einen Kreis der Länge
        <span class="nowrap">$|V|$,</span>
        der also durch alle Knoten
        geht?
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Problem</b>
        <b>9.5.9</b>
        <span class="sc">(Hamilton Path).</span>
        Gegeben ein Graph $G=(V,E)$ , gibt es in
        $G$ einen Pfad der Länge
        <span class="nowrap">$|V|-1$,</span>
        der also alle $|V|$ Knoten
        enthält?
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Theorem</b>
        <b>9.5.10</b>
        <span class="sc">Hamilton Cycle $\leq_p$ Hamilton Path</span>
      </p>
    </div>
    <div class="well highlight out">
      <p>
        <b>(Falscher) Beweis.</b>
        Tasten wir uns langsam heran. Wir stellen
        uns vor, eine Bibliotheksfunktion
        <code>has_hamilton_path(G)</code>
        zu haben
        und wollen mithilfe dieser eine neue Funktion
        <code>has_hamilton_cycle(G)</code>
        schreiben. Sei $u$ ein beliebiger
        Knoten. Wir wissen: wenn $G$ einen Hamiltonschen Kreis hat, dann
        besucht dieser auch $u$ und im Anschluss einen Nachbarnknoten
        <span class="nowrap">$v$,</span>
        also mit
        <span class="nowrap">$\{u,v\} \in E$.</span>
        Der Graph
        <span class="nowrap">$G' := G - \{u,v\}$,</span>
        in
        welchem wir diese Kante löschen, besitzt somit einen
        Hamiltonschen Pfad. Allerdings kann es sein, dass $G'$ sowieso
        einen Hamiltonschen Pfad besitzt, der allerdings nicht $u$ und
        $v$ als Endknoten hat, so dass er sich mit $\{u,v\}$ nicht zu
        einem Hamiltonschen Kreis schließt. Wir müssen irgendwie die
        Frage beantworten können: besitzt $G'$ einen Hamiltonschen Pfad,
        der $u$ und $v$ als Start- bzw. Endknoten hat? Dies ist einfach:
        wir können neue Knoten $s$ und $t$ und die Kanten $\{s,u\}$ und
        $\{t,v\}$ einführen. Da $s$ und $t$ nun Grad $1$ haben, muss ein
        Hamiltonscher Pfad, wenn er denn existiert, $u$ und $v$ als
        Endknoten haben. Sei also
        <span class="nowrap">$G'' := G' + \{s,u\} + \{t,v\}$.</span>
      </p>
      <div class="well container-fluid subtheorem">
        <p>
          <b>Beobachtung:</b>
          $G$ hat genau dann einen Hamiltonschen Kreis
          durch die Kante $\{u,v\}$ , wenn $G''$ einen Hamiltonschen
          Pfad hat.
        </p>
      </div>
      <div class="carousel__container">
        <div class="carousel">
          <div class="carousel__items">
            <div class="carousel__item">
              <img
                style="height:20em"
                src="img/09-complexity-theory/hamilton-path-and-cycle/hamilton-03-01.svg"
              >
            </div>
            <div class="carousel__item">
              <img
                style="height:20em"
                src="img/09-complexity-theory/hamilton-path-and-cycle/hamilton-03-02.svg"
              >
            </div>
          </div>
        </div>
      </div>
      <p>
        Woher wollen wir allerdings wissen, ob der Kreis in $G$ (wenn es
        ihn denn gibt) überhaupt durch $\{u,v\}$ geht? Vielleicht gibt
        es ja einen, aber keinen durch
        <span class="nowrap">$\{u,v\}$,</span>
        so dass dann
        <code>has_hamilton_path(
          <span class="nowrap">$G''$)</span></code>
        mit
        <code>False</code>
        antwortet, obwohl wir
        gerne ein
        <code>True</code>
        hätten. Um das zu verhindern, können wir ja
        <i>alle</i>
        Nachbarn von $u$ durchprobieren. Wenn einer klappt, dann
        haben wir unseren Kreis; wenn es überhaupt einen Kreis gibt, dann
        klappt es auch mit einem Nachbarn (in der Tat: sogar mit zweien).
      </p>
      <p>
<pre class="listing">
<span class="listing-bol"></span>def has_hamilton_cycle(G):
<span class="listing-bol"></span>    u = ein beliebiger Knoten
<span class="listing-bol"></span>    for v in neighbors[u]:
<span class="listing-bol"></span>    H = G - {u,v} + {s,u} + {t,v}
<span class="listing-bol"></span>    if has_hamilton_path(H):
<span class="listing-bol"></span>    return True
<span class="listing-bol"></span>    return False
</pre>
      </p>
      <p>
        Falls nun
        <code>has_hamilton_path</code>
        polynomielle Laufzeit $O(n^k)$
        hat, so hat
        <code>has_hamilton_cycle</code>
        eine Laufzeit von
        <span class="nowrap">$O(n^{k+1})$,</span>
        auch polynomiell.<span style="color:#0000;visibility:none;">A</span><span class="qed">\(\square\)</span>
      </p>
    </div>
    <p class="main-column">
      Was ist nun an diesem Beweis falsch? Nun, der Begriff der
      Reduktion, dem wir uns ja mit der Notation $\leq_p$ verpflichten,
      verlangt, dass wir auf Eingabe $G$
      <i>einen</i>
      Graphen $G'$ bauen, mit
      der Eigenschaft, dass $G$ genau dann einen Hamiltonschen Kreis
      hat, wenn $G'$ einen Hamiltonschen Pfad hat. Uns steht also genau
      <i>ein</i>
      Aufruf von
      <code>has_hamilton_path</code>
      zu. Aber ganz wertlos ist der
      obige Beweis dennoch nicht, zeigt er doch, dass, falls
      <span class="sc">Hamilton
        Path $\in$ P</span>
      ist, dann auch
      <span class="sc">Hamilton Cycle $\in$ P</span>. Der
      Fachbegriff für das, was unsere obige Funktion
      <code>has_hamilton_cycle</code>
      tut, nennt sich
      <span class="nowrap"><i>Cook-Reduktion</i>,</span>
      nach Stephen Cook, einem der
      Väter der Klasse NP. Eine Reduktion, die dem strengen
      Reduktionsbegriff folgt, also
      <span
        data-ref="definition-polynomial-reduction"
        class="reference"
      ></span>, nennt man in Abgrenzung dazu
      <i>Karp-Reduktion</i>
      nach Richard Karp,
      ein weiterer NP-Vater.
    </p>
    <div class="well statement out">
      <p>
        <b>Übungsaufgabe</b>
        <b>9.5.11</b>
        Geben Sie einen "richtigen" Beweis für<span
          data-ref="theorem-ham-cycle-to-path"
          class="reference"
        ></span>, also eine Karp-Reduktion.
      </p>
    </div>
    <div class="well statement out">
      <p>
        <b>Übungsaufgabe</b>
        <b>9.5.12</b>
        Zeigen Sie
        <span class="sc">Hamilton Path $\leq_p$ Hamilton Cycle</span>. Wenn es
        Ihnen einfacher scheint, geben Sie erst einmal eine
        Cook-Reduktion.
      </p>
    </div>
    <div id="end-of-page-elt">
    </div>
    <div id="bottom-menu">
      <div class="bottom-menu-left">
        <a href="./9-4.html">&lt;&lt; Kapitel 9.4<span
            style="visibility:hidden"
            id="bottom-prev-page-tooltip"
          >
            <p>
              Viele Beispiele aus NP
            </p>
          </span></a>
      </div>
      <div class="bottom-menu-right">
        <a href="./9-6.html">Kapitel 9.6 &gt;&gt;<span
            style="visibility:hidden"
            id="bottom-next-page-tooltip"
          >
            <p>
              Ganz NP reduziert auf SAT: das Cook-Levin-Theorem
            </p>
          </span></a>
      </div>
    </div>
  </div>
</body>
</html>
